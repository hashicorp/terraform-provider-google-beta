// ----------------------------------------------------------------------------
//
//     ***     AUTO GENERATED CODE    ***    Type: MMv1     ***
//
// ----------------------------------------------------------------------------
//
//     This file is automatically generated by Magic Modules and manual
//     changes will be clobbered when the file is regenerated.
//
//     Please read more about how to change this file in
//     .github/CONTRIBUTING.md.
//
// ----------------------------------------------------------------------------

package google

import (
	"fmt"
	"log"
	"reflect"
	"strconv"
	"strings"
	"time"

	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/schema"
	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/validation"
)

func resourceBigqueryReservationCapacityCommitments() *schema.Resource {
	return &schema.Resource{
		Create: resourceBigqueryReservationCapacityCommitmentsCreate,
		Read:   resourceBigqueryReservationCapacityCommitmentsRead,
		Update: resourceBigqueryReservationCapacityCommitmentsUpdate,
		Delete: resourceBigqueryReservationCapacityCommitmentsDelete,

		Importer: &schema.ResourceImporter{
			State: resourceBigqueryReservationCapacityCommitmentsImport,
		},

		Timeouts: &schema.ResourceTimeout{
			Create: schema.DefaultTimeout(4 * time.Minute),
			Update: schema.DefaultTimeout(4 * time.Minute),
			Delete: schema.DefaultTimeout(4 * time.Minute),
		},

		Schema: map[string]*schema.Schema{
			"plan": {
				Type:         schema.TypeString,
				Required:     true,
				ValidateFunc: validation.StringInSlice([]string{"FLEX", "TRIAL", "MONTHLY", "ANNUAL"}, false),
				Description: `Commitment plan defines the current committed period. Capacity commitment cannot be deleted during it's committed period. The following values are supported:
FLEX: Flex commitments have committed period of 1 minute after becoming ACTIVE. After that, they are not in a committed period anymore and can be removed any time.
TRIAL: Trial commitments have a committed period of 182 days after becoming ACTIVE. After that, they are converted to a new commitment based on the renewalPlan. Default renewalPlan for Trial commitment is Flex so that it can be deleted right after committed period ends.
MONTHLY: Monthly commitments have a committed period of 30 days after becoming ACTIVE. After that, they are not in a committed period anymore and can be removed any time.
ANNUAL: Annual commitments have a committed period of 365 days after becoming ACTIVE. After that they are converted to a new commitment based on the renewalPlan. Possible values: ["FLEX", "TRIAL", "MONTHLY", "ANNUAL"]`,
			},
			"slot_count": {
				Type:        schema.TypeInt,
				Required:    true,
				Description: `Number of slots in this commitment.`,
			},
			"capacity_commitment_id": {
				Type:        schema.TypeString,
				Optional:    true,
				Description: `The optional capacity commitment ID. Capacity commitment name will be generated automatically if this field is empty. This field must only contain lower case alphanumeric characters or dash. Max length is 64 characters.`,
			},
			"is_enforce_single_admin_project_per_org": {
				Type:        schema.TypeBool,
				Optional:    true,
				ForceNew:    true,
				Description: `If true, fail the request if another project in the organization has a capacity commitment.`,
				Default:     false,
			},
			"location": {
				Type:     schema.TypeString,
				Optional: true,
				ForceNew: true,
				Description: `The geographic location where the transfer config should reside.
Examples: US, EU, asia-northeast1. The default value is US.`,
				Default: "US",
			},
			"renewal_plan": {
				Type:         schema.TypeString,
				Optional:     true,
				ValidateFunc: validation.StringInSlice([]string{"FLEX", "TRIAL", "MONTHLY", "ANNUAL", ""}, false),
				Description: `The plan this capacity commitment is converted to after commitmentEndTime passes. Once the plan is changed, committed period is extended according to commitment plan. Only applicable for ANNUAL commitments.
FLEX: Flex commitments have committed period of 1 minute after becoming ACTIVE. After that, they are not in a committed period anymore and can be removed any time.
TRIAL: Trial commitments have a committed period of 182 days after becoming ACTIVE. After that, they are converted to a new commitment based on the renewalPlan. Default renewalPlan for Trial commitment is Flex so that it can be deleted right after committed period ends.
MONTHLY: Monthly commitments have a committed period of 30 days after becoming ACTIVE. After that, they are not in a committed period anymore and can be removed any time.
ANNUAL: Annual commitments have a committed period of 365 days after becoming ACTIVE. After that they are converted to a new commitment based on the renewalPlan. Possible values: ["FLEX", "TRIAL", "MONTHLY", "ANNUAL"]`,
			},
			"project": {
				Type:     schema.TypeString,
				Optional: true,
				Computed: true,
				ForceNew: true,
			},
		},
		UseJSONNumber: true,
	}
}

func resourceBigqueryReservationCapacityCommitmentsCreate(d *schema.ResourceData, meta interface{}) error {
	config := meta.(*Config)
	userAgent, err := generateUserAgentString(d, config.userAgent)
	if err != nil {
		return err
	}

	obj := make(map[string]interface{})
	isEnforceSingleAdminProjectPerOrgProp, err := expandBigqueryReservationCapacityCommitmentsIsEnforceSingleAdminProjectPerOrg(d.Get("is_enforce_single_admin_project_per_org"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("is_enforce_single_admin_project_per_org"); !isEmptyValue(reflect.ValueOf(isEnforceSingleAdminProjectPerOrgProp)) && (ok || !reflect.DeepEqual(v, isEnforceSingleAdminProjectPerOrgProp)) {
		obj["isEnforceSingleAdminProjectPerOrg"] = isEnforceSingleAdminProjectPerOrgProp
	}
	capacityCommitmentIdProp, err := expandBigqueryReservationCapacityCommitmentsCapacityCommitmentId(d.Get("capacity_commitment_id"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("capacity_commitment_id"); !isEmptyValue(reflect.ValueOf(capacityCommitmentIdProp)) && (ok || !reflect.DeepEqual(v, capacityCommitmentIdProp)) {
		obj["capacityCommitmentId"] = capacityCommitmentIdProp
	}
	slotCountProp, err := expandBigqueryReservationCapacityCommitmentsSlotCount(d.Get("slot_count"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("slot_count"); !isEmptyValue(reflect.ValueOf(slotCountProp)) && (ok || !reflect.DeepEqual(v, slotCountProp)) {
		obj["slotCount"] = slotCountProp
	}
	planProp, err := expandBigqueryReservationCapacityCommitmentsPlan(d.Get("plan"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("plan"); !isEmptyValue(reflect.ValueOf(planProp)) && (ok || !reflect.DeepEqual(v, planProp)) {
		obj["plan"] = planProp
	}
	renewalPlanProp, err := expandBigqueryReservationCapacityCommitmentsRenewalPlan(d.Get("renewal_plan"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("renewal_plan"); !isEmptyValue(reflect.ValueOf(renewalPlanProp)) && (ok || !reflect.DeepEqual(v, renewalPlanProp)) {
		obj["renewalPlan"] = renewalPlanProp
	}

	url, err := replaceVars(d, config, "{{BigqueryReservationBasePath}}projects/{{project}}/locations/{{location}}/capacityCommitments?enforceSingleAdminProjectPerOrg={{isEnforceSingleAdminProjectPerOrg}}&capacityCommitmentsId={{name}}")
	if err != nil {
		return err
	}

	log.Printf("[DEBUG] Creating new CapacityCommitments: %#v", obj)
	billingProject := ""

	project, err := getProject(d, config)
	if err != nil {
		return fmt.Errorf("Error fetching project for CapacityCommitments: %s", err)
	}
	billingProject = project

	// err == nil indicates that the billing_project value was found
	if bp, err := getBillingProject(d, config); err == nil {
		billingProject = bp
	}

	res, err := sendRequestWithTimeout(config, "POST", billingProject, url, userAgent, obj, d.Timeout(schema.TimeoutCreate))
	if err != nil {
		return fmt.Errorf("Error creating CapacityCommitments: %s", err)
	}

	// Store the ID now
	id, err := replaceVars(d, config, "projects/{{project}}/locations/{{location}}/capacityCommitments/{{name}}")
	if err != nil {
		return fmt.Errorf("Error constructing id: %s", err)
	}
	d.SetId(id)

	log.Printf("[DEBUG] Finished creating CapacityCommitments %q: %#v", d.Id(), res)

	return resourceBigqueryReservationCapacityCommitmentsRead(d, meta)
}

func resourceBigqueryReservationCapacityCommitmentsRead(d *schema.ResourceData, meta interface{}) error {
	config := meta.(*Config)
	userAgent, err := generateUserAgentString(d, config.userAgent)
	if err != nil {
		return err
	}

	url, err := replaceVars(d, config, "{{BigqueryReservationBasePath}}projects/{{project}}/locations/{{location}}/capacityCommitments/{{name}}")
	if err != nil {
		return err
	}

	billingProject := ""

	project, err := getProject(d, config)
	if err != nil {
		return fmt.Errorf("Error fetching project for CapacityCommitments: %s", err)
	}
	billingProject = project

	// err == nil indicates that the billing_project value was found
	if bp, err := getBillingProject(d, config); err == nil {
		billingProject = bp
	}

	res, err := sendRequest(config, "GET", billingProject, url, userAgent, nil)
	if err != nil {
		return handleNotFoundError(err, d, fmt.Sprintf("BigqueryReservationCapacityCommitments %q", d.Id()))
	}

	if err := d.Set("project", project); err != nil {
		return fmt.Errorf("Error reading CapacityCommitments: %s", err)
	}

	if err := d.Set("is_enforce_single_admin_project_per_org", flattenBigqueryReservationCapacityCommitmentsIsEnforceSingleAdminProjectPerOrg(res["isEnforceSingleAdminProjectPerOrg"], d, config)); err != nil {
		return fmt.Errorf("Error reading CapacityCommitments: %s", err)
	}
	if err := d.Set("capacity_commitment_id", flattenBigqueryReservationCapacityCommitmentsCapacityCommitmentId(res["capacityCommitmentId"], d, config)); err != nil {
		return fmt.Errorf("Error reading CapacityCommitments: %s", err)
	}
	if err := d.Set("slot_count", flattenBigqueryReservationCapacityCommitmentsSlotCount(res["slotCount"], d, config)); err != nil {
		return fmt.Errorf("Error reading CapacityCommitments: %s", err)
	}
	if err := d.Set("plan", flattenBigqueryReservationCapacityCommitmentsPlan(res["plan"], d, config)); err != nil {
		return fmt.Errorf("Error reading CapacityCommitments: %s", err)
	}
	if err := d.Set("renewal_plan", flattenBigqueryReservationCapacityCommitmentsRenewalPlan(res["renewalPlan"], d, config)); err != nil {
		return fmt.Errorf("Error reading CapacityCommitments: %s", err)
	}

	return nil
}

func resourceBigqueryReservationCapacityCommitmentsUpdate(d *schema.ResourceData, meta interface{}) error {
	config := meta.(*Config)
	userAgent, err := generateUserAgentString(d, config.userAgent)
	if err != nil {
		return err
	}

	billingProject := ""

	project, err := getProject(d, config)
	if err != nil {
		return fmt.Errorf("Error fetching project for CapacityCommitments: %s", err)
	}
	billingProject = project

	obj := make(map[string]interface{})
	capacityCommitmentIdProp, err := expandBigqueryReservationCapacityCommitmentsCapacityCommitmentId(d.Get("capacity_commitment_id"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("capacity_commitment_id"); !isEmptyValue(reflect.ValueOf(v)) && (ok || !reflect.DeepEqual(v, capacityCommitmentIdProp)) {
		obj["capacityCommitmentId"] = capacityCommitmentIdProp
	}
	slotCountProp, err := expandBigqueryReservationCapacityCommitmentsSlotCount(d.Get("slot_count"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("slot_count"); !isEmptyValue(reflect.ValueOf(v)) && (ok || !reflect.DeepEqual(v, slotCountProp)) {
		obj["slotCount"] = slotCountProp
	}
	planProp, err := expandBigqueryReservationCapacityCommitmentsPlan(d.Get("plan"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("plan"); !isEmptyValue(reflect.ValueOf(v)) && (ok || !reflect.DeepEqual(v, planProp)) {
		obj["plan"] = planProp
	}
	renewalPlanProp, err := expandBigqueryReservationCapacityCommitmentsRenewalPlan(d.Get("renewal_plan"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("renewal_plan"); !isEmptyValue(reflect.ValueOf(v)) && (ok || !reflect.DeepEqual(v, renewalPlanProp)) {
		obj["renewalPlan"] = renewalPlanProp
	}

	url, err := replaceVars(d, config, "{{BigqueryReservationBasePath}}projects/{{project}}/locations/{{location}}/capacityCommitments/{{name}}")
	if err != nil {
		return err
	}

	log.Printf("[DEBUG] Updating CapacityCommitments %q: %#v", d.Id(), obj)
	updateMask := []string{}

	if d.HasChange("capacity_commitment_id") {
		updateMask = append(updateMask, "capacityCommitmentId")
	}

	if d.HasChange("slot_count") {
		updateMask = append(updateMask, "slotCount")
	}

	if d.HasChange("plan") {
		updateMask = append(updateMask, "plan")
	}

	if d.HasChange("renewal_plan") {
		updateMask = append(updateMask, "renewalPlan")
	}
	// updateMask is a URL parameter but not present in the schema, so replaceVars
	// won't set it
	url, err = addQueryParams(url, map[string]string{"updateMask": strings.Join(updateMask, ",")})
	if err != nil {
		return err
	}

	// err == nil indicates that the billing_project value was found
	if bp, err := getBillingProject(d, config); err == nil {
		billingProject = bp
	}

	res, err := sendRequestWithTimeout(config, "PATCH", billingProject, url, userAgent, obj, d.Timeout(schema.TimeoutUpdate))

	if err != nil {
		return fmt.Errorf("Error updating CapacityCommitments %q: %s", d.Id(), err)
	} else {
		log.Printf("[DEBUG] Finished updating CapacityCommitments %q: %#v", d.Id(), res)
	}

	return resourceBigqueryReservationCapacityCommitmentsRead(d, meta)
}

func resourceBigqueryReservationCapacityCommitmentsDelete(d *schema.ResourceData, meta interface{}) error {
	config := meta.(*Config)
	userAgent, err := generateUserAgentString(d, config.userAgent)
	if err != nil {
		return err
	}

	billingProject := ""

	project, err := getProject(d, config)
	if err != nil {
		return fmt.Errorf("Error fetching project for CapacityCommitments: %s", err)
	}
	billingProject = project

	url, err := replaceVars(d, config, "{{BigqueryReservationBasePath}}projects/{{project}}/locations/{{location}}/capacityCommitments/{{name}}")
	if err != nil {
		return err
	}

	var obj map[string]interface{}
	log.Printf("[DEBUG] Deleting CapacityCommitments %q", d.Id())

	// err == nil indicates that the billing_project value was found
	if bp, err := getBillingProject(d, config); err == nil {
		billingProject = bp
	}

	res, err := sendRequestWithTimeout(config, "DELETE", billingProject, url, userAgent, obj, d.Timeout(schema.TimeoutDelete))
	if err != nil {
		return handleNotFoundError(err, d, "CapacityCommitments")
	}

	log.Printf("[DEBUG] Finished deleting CapacityCommitments %q: %#v", d.Id(), res)
	return nil
}

func resourceBigqueryReservationCapacityCommitmentsImport(d *schema.ResourceData, meta interface{}) ([]*schema.ResourceData, error) {
	config := meta.(*Config)
	if err := parseImportId([]string{
		"projects/(?P<project>[^/]+)/locations/(?P<location>[^/]+)/capacityCommitments/(?P<name>[^/]+)",
		"(?P<project>[^/]+)/(?P<location>[^/]+)/(?P<name>[^/]+)",
		"(?P<location>[^/]+)/(?P<name>[^/]+)",
	}, d, config); err != nil {
		return nil, err
	}

	// Replace import id for the resource id
	id, err := replaceVars(d, config, "projects/{{project}}/locations/{{location}}/capacityCommitments/{{name}}")
	if err != nil {
		return nil, fmt.Errorf("Error constructing id: %s", err)
	}
	d.SetId(id)

	return []*schema.ResourceData{d}, nil
}

func flattenBigqueryReservationCapacityCommitmentsIsEnforceSingleAdminProjectPerOrg(v interface{}, d *schema.ResourceData, config *Config) interface{} {
	return v
}

func flattenBigqueryReservationCapacityCommitmentsCapacityCommitmentId(v interface{}, d *schema.ResourceData, config *Config) interface{} {
	return v
}

func flattenBigqueryReservationCapacityCommitmentsSlotCount(v interface{}, d *schema.ResourceData, config *Config) interface{} {
	// Handles the string fixed64 format
	if strVal, ok := v.(string); ok {
		if intVal, err := strconv.ParseInt(strVal, 10, 64); err == nil {
			return intVal
		}
	}

	// number values are represented as float64
	if floatVal, ok := v.(float64); ok {
		intVal := int(floatVal)
		return intVal
	}

	return v // let terraform core handle it otherwise
}

func flattenBigqueryReservationCapacityCommitmentsPlan(v interface{}, d *schema.ResourceData, config *Config) interface{} {
	return v
}

func flattenBigqueryReservationCapacityCommitmentsRenewalPlan(v interface{}, d *schema.ResourceData, config *Config) interface{} {
	return v
}

func expandBigqueryReservationCapacityCommitmentsIsEnforceSingleAdminProjectPerOrg(v interface{}, d TerraformResourceData, config *Config) (interface{}, error) {
	return v, nil
}

func expandBigqueryReservationCapacityCommitmentsCapacityCommitmentId(v interface{}, d TerraformResourceData, config *Config) (interface{}, error) {
	return v, nil
}

func expandBigqueryReservationCapacityCommitmentsSlotCount(v interface{}, d TerraformResourceData, config *Config) (interface{}, error) {
	return v, nil
}

func expandBigqueryReservationCapacityCommitmentsPlan(v interface{}, d TerraformResourceData, config *Config) (interface{}, error) {
	return v, nil
}

func expandBigqueryReservationCapacityCommitmentsRenewalPlan(v interface{}, d TerraformResourceData, config *Config) (interface{}, error) {
	return v, nil
}
