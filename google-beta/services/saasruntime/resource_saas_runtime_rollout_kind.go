// Copyright (c) HashiCorp, Inc.
// SPDX-License-Identifier: MPL-2.0

// ----------------------------------------------------------------------------
//
//     ***     AUTO GENERATED CODE    ***    Type: MMv1     ***
//
// ----------------------------------------------------------------------------
//
//     This code is generated by Magic Modules using the following:
//
//     Configuration: https://github.com/GoogleCloudPlatform/magic-modules/tree/main/mmv1/products/saasservicemgmt/RolloutKind.yaml
//     Template:      https://github.com/GoogleCloudPlatform/magic-modules/tree/main/mmv1/templates/terraform/resource.go.tmpl
//
//     DO NOT EDIT this file directly. Any changes made to this file will be
//     overwritten during the next generation cycle.
//
// ----------------------------------------------------------------------------

package saasruntime

import (
	"bytes"
	"context"
	"encoding/base64"
	"encoding/json"
	"fmt"
	"log"
	"net/http"
	"reflect"
	"regexp"
	"slices"
	"sort"
	"strconv"
	"strings"
	"time"

	"github.com/hashicorp/errwrap"
	"github.com/hashicorp/go-cty/cty"
	"github.com/hashicorp/terraform-plugin-sdk/v2/diag"
	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/customdiff"
	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/id"
	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/logging"
	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/retry"
	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/schema"
	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/structure"
	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/validation"
	"github.com/hashicorp/terraform-plugin-sdk/v2/terraform"

	"github.com/hashicorp/terraform-provider-google-beta/google-beta/tpgresource"
	transport_tpg "github.com/hashicorp/terraform-provider-google-beta/google-beta/transport"
	"github.com/hashicorp/terraform-provider-google-beta/google-beta/verify"

	"google.golang.org/api/googleapi"
)

var (
	_ = bytes.Clone
	_ = context.WithCancel
	_ = base64.NewDecoder
	_ = json.Marshal
	_ = fmt.Sprintf
	_ = log.Print
	_ = http.Get
	_ = reflect.ValueOf
	_ = regexp.Match
	_ = slices.Min([]int{1})
	_ = sort.IntSlice{}
	_ = strconv.Atoi
	_ = strings.Trim
	_ = time.Now
	_ = errwrap.Wrap
	_ = cty.BoolVal
	_ = diag.Diagnostic{}
	_ = customdiff.All
	_ = id.UniqueId
	_ = logging.LogLevel
	_ = retry.Retry
	_ = schema.Noop
	_ = validation.All
	_ = structure.ExpandJsonFromString
	_ = terraform.State{}
	_ = tpgresource.SetLabels
	_ = transport_tpg.Config{}
	_ = verify.ValidateEnum
	_ = googleapi.Error{}
)

func ResourceSaasRuntimeRolloutKind() *schema.Resource {
	return &schema.Resource{
		Create: resourceSaasRuntimeRolloutKindCreate,
		Read:   resourceSaasRuntimeRolloutKindRead,
		Update: resourceSaasRuntimeRolloutKindUpdate,
		Delete: resourceSaasRuntimeRolloutKindDelete,

		Importer: &schema.ResourceImporter{
			State: resourceSaasRuntimeRolloutKindImport,
		},

		Timeouts: &schema.ResourceTimeout{
			Create: schema.DefaultTimeout(20 * time.Minute),
			Update: schema.DefaultTimeout(20 * time.Minute),
			Delete: schema.DefaultTimeout(20 * time.Minute),
		},

		CustomizeDiff: customdiff.All(
			tpgresource.SetAnnotationsDiff,
			tpgresource.SetLabelsDiff,
			tpgresource.DefaultProviderProject,
		),

		Schema: map[string]*schema.Schema{
			"location": {
				Type:        schema.TypeString,
				Required:    true,
				ForceNew:    true,
				Description: `Resource ID segment making up resource 'name'. It identifies the resource within its parent collection as described in https://google.aip.dev/122.`,
			},
			"rollout_kind_id": {
				Type:        schema.TypeString,
				Required:    true,
				ForceNew:    true,
				Description: `The ID value for the new rollout kind.`,
			},
			"unit_kind": {
				Type:     schema.TypeString,
				Required: true,
				ForceNew: true,
				Description: `UnitKind that this rollout kind corresponds to. Rollouts stemming from this
rollout kind will target the units of this unit kind. In other words, this
defines the population of target units to be upgraded by rollouts.`,
			},
			"annotations": {
				Type:     schema.TypeMap,
				Optional: true,
				Description: `Annotations is an unstructured key-value map stored with a resource that
may be set by external tools to store and retrieve arbitrary metadata.
They are not queryable and should be preserved when modifying objects.

More info: https://kubernetes.io/docs/user-guide/annotations

**Note**: This field is non-authoritative, and will only manage the annotations present in your configuration.
Please refer to the field 'effective_annotations' for all of the annotations present on the resource.`,
				Elem: &schema.Schema{Type: schema.TypeString},
			},
			"error_budget": {
				Type:     schema.TypeList,
				Optional: true,
				Description: `The configuration for error budget. If the number of failed units exceeds
max(allowed_count, allowed_ratio * total_units), the rollout will be paused.`,
				MaxItems: 1,
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						"allowed_count": {
							Type:     schema.TypeInt,
							Optional: true,
							Description: `The maximum number of failed units allowed in a location without pausing
the rollout.`,
						},
						"allowed_percentage": {
							Type:     schema.TypeInt,
							Optional: true,
							Description: `The maximum percentage of units allowed to fail (0, 100] within a location
without pausing the rollout.`,
						},
					},
				},
			},
			"labels": {
				Type:     schema.TypeMap,
				Optional: true,
				Description: `The labels on the resource, which can be used for categorization.
similar to Kubernetes resource labels.

**Note**: This field is non-authoritative, and will only manage the labels present in your configuration.
Please refer to the field 'effective_labels' for all of the labels present on the resource.`,
				Elem: &schema.Schema{Type: schema.TypeString},
			},
			"rollout_orchestration_strategy": {
				Type:     schema.TypeString,
				Optional: true,
				Description: `The strategy used for executing a Rollout. This is a required field.

There are two supported values strategies which are used to control a rollout.
- "Google.Cloud.Simple.AllAtOnce"
- "Google.Cloud.Simple.OneLocationAtATime"

A rollout with one of these simple strategies will rollout across
all locations defined in the associated UnitKind's Saas Locations.`,
			},
			"unit_filter": {
				Type:     schema.TypeString,
				Optional: true,
				Description: `CEL(https://github.com/google/cel-spec) formatted filter string against
Unit. The filter will be applied to determine the eligible unit population.
This filter can only reduce, but not expand the scope of the rollout.`,
			},
			"update_unit_kind_strategy": {
				Type:         schema.TypeString,
				Optional:     true,
				ValidateFunc: verify.ValidateEnum([]string{"UPDATE_UNIT_KIND_STRATEGY_ON_START", "UPDATE_UNIT_KIND_STRATEGY_NEVER", ""}),
				Description: `The config for updating the unit kind. By default, the unit kind will be
updated on the rollout start.
Possible values:
UPDATE_UNIT_KIND_STRATEGY_ON_START
UPDATE_UNIT_KIND_STRATEGY_NEVER Possible values: ["UPDATE_UNIT_KIND_STRATEGY_ON_START", "UPDATE_UNIT_KIND_STRATEGY_NEVER"]`,
			},
			"create_time": {
				Type:        schema.TypeString,
				Computed:    true,
				Description: `The timestamp when the resource was created.`,
			},
			"effective_annotations": {
				Type:        schema.TypeMap,
				Computed:    true,
				Description: `All of annotations (key/value pairs) present on the resource in GCP, including the annotations configured through Terraform, other clients and services.`,
				Elem:        &schema.Schema{Type: schema.TypeString},
			},
			"effective_labels": {
				Type:        schema.TypeMap,
				Computed:    true,
				Description: `All of labels (key/value pairs) present on the resource in GCP, including the labels configured through Terraform, other clients and services.`,
				Elem:        &schema.Schema{Type: schema.TypeString},
			},
			"name": {
				Type:     schema.TypeString,
				Computed: true,
				Description: `Identifier. The resource name (full URI of the resource) following the standard naming
scheme:

"projects/{project}/locations/{location}/rolloutKinds/{rollout_kind_id}"`,
			},
			"terraform_labels": {
				Type:     schema.TypeMap,
				Computed: true,
				Description: `The combination of labels configured directly on the resource
 and default labels configured on the provider.`,
				Elem: &schema.Schema{Type: schema.TypeString},
			},
			"uid": {
				Type:     schema.TypeString,
				Computed: true,
				Description: `The unique identifier of the resource. UID is unique in the time
and space for this resource within the scope of the service. It is
typically generated by the server on successful creation of a resource
and must not be changed. UID is used to uniquely identify resources
with resource name reuses. This should be a UUID4.`,
			},
			"update_time": {
				Type:     schema.TypeString,
				Computed: true,
				Description: `The timestamp when the resource was last updated. Any
change to the resource made by users must refresh this value.
Changes to a resource made by the service should refresh this value.`,
			},
			"project": {
				Type:     schema.TypeString,
				Optional: true,
				Computed: true,
				ForceNew: true,
			},
		},
		UseJSONNumber: true,
	}
}

func resourceSaasRuntimeRolloutKindCreate(d *schema.ResourceData, meta interface{}) error {
	config := meta.(*transport_tpg.Config)
	userAgent, err := tpgresource.GenerateUserAgentString(d, config.UserAgent)
	if err != nil {
		return err
	}

	obj := make(map[string]interface{})
	errorBudgetProp, err := expandSaasRuntimeRolloutKindErrorBudget(d.Get("error_budget"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("error_budget"); !tpgresource.IsEmptyValue(reflect.ValueOf(errorBudgetProp)) && (ok || !reflect.DeepEqual(v, errorBudgetProp)) {
		obj["errorBudget"] = errorBudgetProp
	}
	rolloutOrchestrationStrategyProp, err := expandSaasRuntimeRolloutKindRolloutOrchestrationStrategy(d.Get("rollout_orchestration_strategy"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("rollout_orchestration_strategy"); !tpgresource.IsEmptyValue(reflect.ValueOf(rolloutOrchestrationStrategyProp)) && (ok || !reflect.DeepEqual(v, rolloutOrchestrationStrategyProp)) {
		obj["rolloutOrchestrationStrategy"] = rolloutOrchestrationStrategyProp
	}
	unitFilterProp, err := expandSaasRuntimeRolloutKindUnitFilter(d.Get("unit_filter"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("unit_filter"); !tpgresource.IsEmptyValue(reflect.ValueOf(unitFilterProp)) && (ok || !reflect.DeepEqual(v, unitFilterProp)) {
		obj["unitFilter"] = unitFilterProp
	}
	unitKindProp, err := expandSaasRuntimeRolloutKindUnitKind(d.Get("unit_kind"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("unit_kind"); !tpgresource.IsEmptyValue(reflect.ValueOf(unitKindProp)) && (ok || !reflect.DeepEqual(v, unitKindProp)) {
		obj["unitKind"] = unitKindProp
	}
	updateUnitKindStrategyProp, err := expandSaasRuntimeRolloutKindUpdateUnitKindStrategy(d.Get("update_unit_kind_strategy"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("update_unit_kind_strategy"); !tpgresource.IsEmptyValue(reflect.ValueOf(updateUnitKindStrategyProp)) && (ok || !reflect.DeepEqual(v, updateUnitKindStrategyProp)) {
		obj["updateUnitKindStrategy"] = updateUnitKindStrategyProp
	}
	effectiveAnnotationsProp, err := expandSaasRuntimeRolloutKindEffectiveAnnotations(d.Get("effective_annotations"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("effective_annotations"); !tpgresource.IsEmptyValue(reflect.ValueOf(effectiveAnnotationsProp)) && (ok || !reflect.DeepEqual(v, effectiveAnnotationsProp)) {
		obj["annotations"] = effectiveAnnotationsProp
	}
	effectiveLabelsProp, err := expandSaasRuntimeRolloutKindEffectiveLabels(d.Get("effective_labels"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("effective_labels"); !tpgresource.IsEmptyValue(reflect.ValueOf(effectiveLabelsProp)) && (ok || !reflect.DeepEqual(v, effectiveLabelsProp)) {
		obj["labels"] = effectiveLabelsProp
	}

	url, err := tpgresource.ReplaceVars(d, config, "{{SaasRuntimeBasePath}}projects/{{project}}/locations/{{location}}/rolloutKinds?rolloutKindId={{rollout_kind_id}}")
	if err != nil {
		return err
	}

	log.Printf("[DEBUG] Creating new RolloutKind: %#v", obj)
	billingProject := ""

	project, err := tpgresource.GetProject(d, config)
	if err != nil {
		return fmt.Errorf("Error fetching project for RolloutKind: %s", err)
	}
	billingProject = project

	// err == nil indicates that the billing_project value was found
	if bp, err := tpgresource.GetBillingProject(d, config); err == nil {
		billingProject = bp
	}

	headers := make(http.Header)
	res, err := transport_tpg.SendRequest(transport_tpg.SendRequestOptions{
		Config:    config,
		Method:    "POST",
		Project:   billingProject,
		RawURL:    url,
		UserAgent: userAgent,
		Body:      obj,
		Timeout:   d.Timeout(schema.TimeoutCreate),
		Headers:   headers,
	})
	if err != nil {
		return fmt.Errorf("Error creating RolloutKind: %s", err)
	}

	// Store the ID now
	id, err := tpgresource.ReplaceVars(d, config, "projects/{{project}}/locations/{{location}}/rolloutKinds/{{rollout_kind_id}}")
	if err != nil {
		return fmt.Errorf("Error constructing id: %s", err)
	}
	d.SetId(id)

	log.Printf("[DEBUG] Finished creating RolloutKind %q: %#v", d.Id(), res)

	return resourceSaasRuntimeRolloutKindRead(d, meta)
}

func resourceSaasRuntimeRolloutKindRead(d *schema.ResourceData, meta interface{}) error {
	config := meta.(*transport_tpg.Config)
	userAgent, err := tpgresource.GenerateUserAgentString(d, config.UserAgent)
	if err != nil {
		return err
	}

	url, err := tpgresource.ReplaceVars(d, config, "{{SaasRuntimeBasePath}}projects/{{project}}/locations/{{location}}/rolloutKinds/{{rollout_kind_id}}")
	if err != nil {
		return err
	}

	billingProject := ""

	project, err := tpgresource.GetProject(d, config)
	if err != nil {
		return fmt.Errorf("Error fetching project for RolloutKind: %s", err)
	}
	billingProject = project

	// err == nil indicates that the billing_project value was found
	if bp, err := tpgresource.GetBillingProject(d, config); err == nil {
		billingProject = bp
	}

	headers := make(http.Header)
	res, err := transport_tpg.SendRequest(transport_tpg.SendRequestOptions{
		Config:    config,
		Method:    "GET",
		Project:   billingProject,
		RawURL:    url,
		UserAgent: userAgent,
		Headers:   headers,
	})
	if err != nil {
		return transport_tpg.HandleNotFoundError(err, d, fmt.Sprintf("SaasRuntimeRolloutKind %q", d.Id()))
	}

	if err := d.Set("project", project); err != nil {
		return fmt.Errorf("Error reading RolloutKind: %s", err)
	}

	if err := d.Set("annotations", flattenSaasRuntimeRolloutKindAnnotations(res["annotations"], d, config)); err != nil {
		return fmt.Errorf("Error reading RolloutKind: %s", err)
	}
	if err := d.Set("create_time", flattenSaasRuntimeRolloutKindCreateTime(res["createTime"], d, config)); err != nil {
		return fmt.Errorf("Error reading RolloutKind: %s", err)
	}
	if err := d.Set("error_budget", flattenSaasRuntimeRolloutKindErrorBudget(res["errorBudget"], d, config)); err != nil {
		return fmt.Errorf("Error reading RolloutKind: %s", err)
	}
	if err := d.Set("labels", flattenSaasRuntimeRolloutKindLabels(res["labels"], d, config)); err != nil {
		return fmt.Errorf("Error reading RolloutKind: %s", err)
	}
	if err := d.Set("name", flattenSaasRuntimeRolloutKindName(res["name"], d, config)); err != nil {
		return fmt.Errorf("Error reading RolloutKind: %s", err)
	}
	if err := d.Set("rollout_orchestration_strategy", flattenSaasRuntimeRolloutKindRolloutOrchestrationStrategy(res["rolloutOrchestrationStrategy"], d, config)); err != nil {
		return fmt.Errorf("Error reading RolloutKind: %s", err)
	}
	if err := d.Set("uid", flattenSaasRuntimeRolloutKindUid(res["uid"], d, config)); err != nil {
		return fmt.Errorf("Error reading RolloutKind: %s", err)
	}
	if err := d.Set("unit_filter", flattenSaasRuntimeRolloutKindUnitFilter(res["unitFilter"], d, config)); err != nil {
		return fmt.Errorf("Error reading RolloutKind: %s", err)
	}
	if err := d.Set("unit_kind", flattenSaasRuntimeRolloutKindUnitKind(res["unitKind"], d, config)); err != nil {
		return fmt.Errorf("Error reading RolloutKind: %s", err)
	}
	if err := d.Set("update_time", flattenSaasRuntimeRolloutKindUpdateTime(res["updateTime"], d, config)); err != nil {
		return fmt.Errorf("Error reading RolloutKind: %s", err)
	}
	if err := d.Set("update_unit_kind_strategy", flattenSaasRuntimeRolloutKindUpdateUnitKindStrategy(res["updateUnitKindStrategy"], d, config)); err != nil {
		return fmt.Errorf("Error reading RolloutKind: %s", err)
	}
	if err := d.Set("effective_annotations", flattenSaasRuntimeRolloutKindEffectiveAnnotations(res["annotations"], d, config)); err != nil {
		return fmt.Errorf("Error reading RolloutKind: %s", err)
	}
	if err := d.Set("terraform_labels", flattenSaasRuntimeRolloutKindTerraformLabels(res["labels"], d, config)); err != nil {
		return fmt.Errorf("Error reading RolloutKind: %s", err)
	}
	if err := d.Set("effective_labels", flattenSaasRuntimeRolloutKindEffectiveLabels(res["labels"], d, config)); err != nil {
		return fmt.Errorf("Error reading RolloutKind: %s", err)
	}

	return nil
}

func resourceSaasRuntimeRolloutKindUpdate(d *schema.ResourceData, meta interface{}) error {
	config := meta.(*transport_tpg.Config)
	userAgent, err := tpgresource.GenerateUserAgentString(d, config.UserAgent)
	if err != nil {
		return err
	}

	billingProject := ""

	project, err := tpgresource.GetProject(d, config)
	if err != nil {
		return fmt.Errorf("Error fetching project for RolloutKind: %s", err)
	}
	billingProject = project

	obj := make(map[string]interface{})
	errorBudgetProp, err := expandSaasRuntimeRolloutKindErrorBudget(d.Get("error_budget"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("error_budget"); !tpgresource.IsEmptyValue(reflect.ValueOf(v)) && (ok || !reflect.DeepEqual(v, errorBudgetProp)) {
		obj["errorBudget"] = errorBudgetProp
	}
	rolloutOrchestrationStrategyProp, err := expandSaasRuntimeRolloutKindRolloutOrchestrationStrategy(d.Get("rollout_orchestration_strategy"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("rollout_orchestration_strategy"); !tpgresource.IsEmptyValue(reflect.ValueOf(v)) && (ok || !reflect.DeepEqual(v, rolloutOrchestrationStrategyProp)) {
		obj["rolloutOrchestrationStrategy"] = rolloutOrchestrationStrategyProp
	}
	unitFilterProp, err := expandSaasRuntimeRolloutKindUnitFilter(d.Get("unit_filter"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("unit_filter"); !tpgresource.IsEmptyValue(reflect.ValueOf(v)) && (ok || !reflect.DeepEqual(v, unitFilterProp)) {
		obj["unitFilter"] = unitFilterProp
	}
	updateUnitKindStrategyProp, err := expandSaasRuntimeRolloutKindUpdateUnitKindStrategy(d.Get("update_unit_kind_strategy"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("update_unit_kind_strategy"); !tpgresource.IsEmptyValue(reflect.ValueOf(v)) && (ok || !reflect.DeepEqual(v, updateUnitKindStrategyProp)) {
		obj["updateUnitKindStrategy"] = updateUnitKindStrategyProp
	}
	effectiveAnnotationsProp, err := expandSaasRuntimeRolloutKindEffectiveAnnotations(d.Get("effective_annotations"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("effective_annotations"); !tpgresource.IsEmptyValue(reflect.ValueOf(v)) && (ok || !reflect.DeepEqual(v, effectiveAnnotationsProp)) {
		obj["annotations"] = effectiveAnnotationsProp
	}
	effectiveLabelsProp, err := expandSaasRuntimeRolloutKindEffectiveLabels(d.Get("effective_labels"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("effective_labels"); !tpgresource.IsEmptyValue(reflect.ValueOf(v)) && (ok || !reflect.DeepEqual(v, effectiveLabelsProp)) {
		obj["labels"] = effectiveLabelsProp
	}

	url, err := tpgresource.ReplaceVars(d, config, "{{SaasRuntimeBasePath}}projects/{{project}}/locations/{{location}}/rolloutKinds/{{rollout_kind_id}}")
	if err != nil {
		return err
	}

	log.Printf("[DEBUG] Updating RolloutKind %q: %#v", d.Id(), obj)
	headers := make(http.Header)
	updateMask := []string{}

	if d.HasChange("error_budget") {
		updateMask = append(updateMask, "errorBudget")
	}

	if d.HasChange("rollout_orchestration_strategy") {
		updateMask = append(updateMask, "rolloutOrchestrationStrategy")
	}

	if d.HasChange("unit_filter") {
		updateMask = append(updateMask, "unitFilter")
	}

	if d.HasChange("update_unit_kind_strategy") {
		updateMask = append(updateMask, "updateUnitKindStrategy")
	}

	if d.HasChange("effective_annotations") {
		updateMask = append(updateMask, "annotations")
	}

	if d.HasChange("effective_labels") {
		updateMask = append(updateMask, "labels")
	}
	// updateMask is a URL parameter but not present in the schema, so ReplaceVars
	// won't set it
	url, err = transport_tpg.AddQueryParams(url, map[string]string{"updateMask": strings.Join(updateMask, ",")})
	if err != nil {
		return err
	}

	// err == nil indicates that the billing_project value was found
	if bp, err := tpgresource.GetBillingProject(d, config); err == nil {
		billingProject = bp
	}

	// if updateMask is empty we are not updating anything so skip the post
	if len(updateMask) > 0 {
		res, err := transport_tpg.SendRequest(transport_tpg.SendRequestOptions{
			Config:    config,
			Method:    "PATCH",
			Project:   billingProject,
			RawURL:    url,
			UserAgent: userAgent,
			Body:      obj,
			Timeout:   d.Timeout(schema.TimeoutUpdate),
			Headers:   headers,
		})

		if err != nil {
			return fmt.Errorf("Error updating RolloutKind %q: %s", d.Id(), err)
		} else {
			log.Printf("[DEBUG] Finished updating RolloutKind %q: %#v", d.Id(), res)
		}

	}

	return resourceSaasRuntimeRolloutKindRead(d, meta)
}

func resourceSaasRuntimeRolloutKindDelete(d *schema.ResourceData, meta interface{}) error {
	config := meta.(*transport_tpg.Config)
	userAgent, err := tpgresource.GenerateUserAgentString(d, config.UserAgent)
	if err != nil {
		return err
	}

	billingProject := ""

	project, err := tpgresource.GetProject(d, config)
	if err != nil {
		return fmt.Errorf("Error fetching project for RolloutKind: %s", err)
	}
	billingProject = project

	url, err := tpgresource.ReplaceVars(d, config, "{{SaasRuntimeBasePath}}projects/{{project}}/locations/{{location}}/rolloutKinds/{{rollout_kind_id}}")
	if err != nil {
		return err
	}

	var obj map[string]interface{}

	// err == nil indicates that the billing_project value was found
	if bp, err := tpgresource.GetBillingProject(d, config); err == nil {
		billingProject = bp
	}

	headers := make(http.Header)

	log.Printf("[DEBUG] Deleting RolloutKind %q", d.Id())
	res, err := transport_tpg.SendRequest(transport_tpg.SendRequestOptions{
		Config:    config,
		Method:    "DELETE",
		Project:   billingProject,
		RawURL:    url,
		UserAgent: userAgent,
		Body:      obj,
		Timeout:   d.Timeout(schema.TimeoutDelete),
		Headers:   headers,
	})
	if err != nil {
		return transport_tpg.HandleNotFoundError(err, d, "RolloutKind")
	}

	log.Printf("[DEBUG] Finished deleting RolloutKind %q: %#v", d.Id(), res)
	return nil
}

func resourceSaasRuntimeRolloutKindImport(d *schema.ResourceData, meta interface{}) ([]*schema.ResourceData, error) {
	config := meta.(*transport_tpg.Config)
	if err := tpgresource.ParseImportId([]string{
		"^projects/(?P<project>[^/]+)/locations/(?P<location>[^/]+)/rolloutKinds/(?P<rollout_kind_id>[^/]+)$",
		"^(?P<project>[^/]+)/(?P<location>[^/]+)/(?P<rollout_kind_id>[^/]+)$",
		"^(?P<location>[^/]+)/(?P<rollout_kind_id>[^/]+)$",
	}, d, config); err != nil {
		return nil, err
	}

	// Replace import id for the resource id
	id, err := tpgresource.ReplaceVars(d, config, "projects/{{project}}/locations/{{location}}/rolloutKinds/{{rollout_kind_id}}")
	if err != nil {
		return nil, fmt.Errorf("Error constructing id: %s", err)
	}
	d.SetId(id)

	return []*schema.ResourceData{d}, nil
}

func flattenSaasRuntimeRolloutKindAnnotations(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return v
	}

	transformed := make(map[string]interface{})
	if l, ok := d.GetOkExists("annotations"); ok {
		for k := range l.(map[string]interface{}) {
			transformed[k] = v.(map[string]interface{})[k]
		}
	}

	return transformed
}

func flattenSaasRuntimeRolloutKindCreateTime(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenSaasRuntimeRolloutKindErrorBudget(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return nil
	}
	original := v.(map[string]interface{})
	if len(original) == 0 {
		return nil
	}
	transformed := make(map[string]interface{})
	transformed["allowed_count"] =
		flattenSaasRuntimeRolloutKindErrorBudgetAllowedCount(original["allowedCount"], d, config)
	transformed["allowed_percentage"] =
		flattenSaasRuntimeRolloutKindErrorBudgetAllowedPercentage(original["allowedPercentage"], d, config)
	return []interface{}{transformed}
}
func flattenSaasRuntimeRolloutKindErrorBudgetAllowedCount(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	// Handles the string fixed64 format
	if strVal, ok := v.(string); ok {
		if intVal, err := tpgresource.StringToFixed64(strVal); err == nil {
			return intVal
		}
	}

	// number values are represented as float64
	if floatVal, ok := v.(float64); ok {
		intVal := int(floatVal)
		return intVal
	}

	return v // let terraform core handle it otherwise
}

func flattenSaasRuntimeRolloutKindErrorBudgetAllowedPercentage(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	// Handles the string fixed64 format
	if strVal, ok := v.(string); ok {
		if intVal, err := tpgresource.StringToFixed64(strVal); err == nil {
			return intVal
		}
	}

	// number values are represented as float64
	if floatVal, ok := v.(float64); ok {
		intVal := int(floatVal)
		return intVal
	}

	return v // let terraform core handle it otherwise
}

func flattenSaasRuntimeRolloutKindLabels(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return v
	}

	transformed := make(map[string]interface{})
	if l, ok := d.GetOkExists("labels"); ok {
		for k := range l.(map[string]interface{}) {
			transformed[k] = v.(map[string]interface{})[k]
		}
	}

	return transformed
}

func flattenSaasRuntimeRolloutKindName(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenSaasRuntimeRolloutKindRolloutOrchestrationStrategy(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenSaasRuntimeRolloutKindUid(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenSaasRuntimeRolloutKindUnitFilter(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenSaasRuntimeRolloutKindUnitKind(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenSaasRuntimeRolloutKindUpdateTime(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenSaasRuntimeRolloutKindUpdateUnitKindStrategy(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenSaasRuntimeRolloutKindEffectiveAnnotations(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenSaasRuntimeRolloutKindTerraformLabels(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return v
	}

	transformed := make(map[string]interface{})
	if l, ok := d.GetOkExists("terraform_labels"); ok {
		for k := range l.(map[string]interface{}) {
			transformed[k] = v.(map[string]interface{})[k]
		}
	}

	return transformed
}

func flattenSaasRuntimeRolloutKindEffectiveLabels(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func expandSaasRuntimeRolloutKindErrorBudget(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	if v == nil {
		return nil, nil
	}
	l := v.([]interface{})
	if len(l) == 0 || l[0] == nil {
		return nil, nil
	}
	raw := l[0]
	original := raw.(map[string]interface{})
	transformed := make(map[string]interface{})

	transformedAllowedCount, err := expandSaasRuntimeRolloutKindErrorBudgetAllowedCount(original["allowed_count"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedAllowedCount); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["allowedCount"] = transformedAllowedCount
	}

	transformedAllowedPercentage, err := expandSaasRuntimeRolloutKindErrorBudgetAllowedPercentage(original["allowed_percentage"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedAllowedPercentage); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["allowedPercentage"] = transformedAllowedPercentage
	}

	return transformed, nil
}

func expandSaasRuntimeRolloutKindErrorBudgetAllowedCount(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandSaasRuntimeRolloutKindErrorBudgetAllowedPercentage(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandSaasRuntimeRolloutKindRolloutOrchestrationStrategy(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandSaasRuntimeRolloutKindUnitFilter(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandSaasRuntimeRolloutKindUnitKind(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandSaasRuntimeRolloutKindUpdateUnitKindStrategy(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandSaasRuntimeRolloutKindEffectiveAnnotations(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (map[string]string, error) {
	if v == nil {
		return map[string]string{}, nil
	}
	m := make(map[string]string)
	for k, val := range v.(map[string]interface{}) {
		m[k] = val.(string)
	}
	return m, nil
}

func expandSaasRuntimeRolloutKindEffectiveLabels(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (map[string]string, error) {
	if v == nil {
		return map[string]string{}, nil
	}
	m := make(map[string]string)
	for k, val := range v.(map[string]interface{}) {
		m[k] = val.(string)
	}
	return m, nil
}
