// Copyright (c) HashiCorp, Inc.
// SPDX-License-Identifier: MPL-2.0

// ----------------------------------------------------------------------------
//
//     ***     AUTO GENERATED CODE    ***    Type: MMv1     ***
//
// ----------------------------------------------------------------------------
//
//     This code is generated by Magic Modules using the following:
//
//     Configuration: https://github.com/GoogleCloudPlatform/magic-modules/tree/main/mmv1/products/saasservicemgmt/Release.yaml
//     Template:      https://github.com/GoogleCloudPlatform/magic-modules/tree/main/mmv1/templates/terraform/resource.go.tmpl
//
//     DO NOT EDIT this file directly. Any changes made to this file will be
//     overwritten during the next generation cycle.
//
// ----------------------------------------------------------------------------

package saasruntime

import (
	"bytes"
	"context"
	"encoding/base64"
	"encoding/json"
	"fmt"
	"log"
	"net/http"
	"reflect"
	"regexp"
	"slices"
	"sort"
	"strconv"
	"strings"
	"time"

	"github.com/hashicorp/errwrap"
	"github.com/hashicorp/go-cty/cty"
	"github.com/hashicorp/terraform-plugin-sdk/v2/diag"
	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/customdiff"
	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/id"
	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/logging"
	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/retry"
	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/schema"
	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/structure"
	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/validation"
	"github.com/hashicorp/terraform-plugin-sdk/v2/terraform"

	"github.com/hashicorp/terraform-provider-google-beta/google-beta/registry"
	"github.com/hashicorp/terraform-provider-google-beta/google-beta/tpgresource"
	transport_tpg "github.com/hashicorp/terraform-provider-google-beta/google-beta/transport"
	"github.com/hashicorp/terraform-provider-google-beta/google-beta/verify"

	"google.golang.org/api/googleapi"
)

var (
	_ = bytes.Clone
	_ = context.WithCancel
	_ = base64.NewDecoder
	_ = json.Marshal
	_ = fmt.Sprintf
	_ = log.Print
	_ = http.Get
	_ = reflect.ValueOf
	_ = regexp.Match
	_ = slices.Min([]int{1})
	_ = sort.IntSlice{}
	_ = strconv.Atoi
	_ = strings.Trim
	_ = time.Now
	_ = errwrap.Wrap
	_ = cty.BoolVal
	_ = diag.Diagnostic{}
	_ = customdiff.All
	_ = id.UniqueId
	_ = logging.LogLevel
	_ = retry.Retry
	_ = schema.Noop
	_ = validation.All
	_ = structure.ExpandJsonFromString
	_ = terraform.State{}
	_ = tpgresource.SetLabels
	_ = transport_tpg.Config{}
	_ = verify.ValidateEnum
	_ = googleapi.Error{}
)

func init() {
	registry.Schema{
		Name:        "google_saas_runtime_release",
		ProductName: "saasruntime",
		Type:        registry.SchemaTypeResource,
		Schema:      ResourceSaasRuntimeRelease(),
	}.Register()
}

func ResourceSaasRuntimeRelease() *schema.Resource {
	return &schema.Resource{
		Create: resourceSaasRuntimeReleaseCreate,
		Read:   resourceSaasRuntimeReleaseRead,
		Update: resourceSaasRuntimeReleaseUpdate,
		Delete: resourceSaasRuntimeReleaseDelete,

		Importer: &schema.ResourceImporter{
			State: resourceSaasRuntimeReleaseImport,
		},

		Timeouts: &schema.ResourceTimeout{
			Create: schema.DefaultTimeout(20 * time.Minute),
			Update: schema.DefaultTimeout(20 * time.Minute),
			Delete: schema.DefaultTimeout(20 * time.Minute),
		},

		CustomizeDiff: customdiff.All(
			tpgresource.SetAnnotationsDiff,
			tpgresource.SetLabelsDiff,
			tpgresource.DefaultProviderProject,
		),

		Schema: map[string]*schema.Schema{
			"location": {
				Type:        schema.TypeString,
				Required:    true,
				ForceNew:    true,
				Description: `Resource ID segment making up resource 'name'. It identifies the resource within its parent collection as described in https://google.aip.dev/122.`,
			},
			"release_id": {
				Type:        schema.TypeString,
				Required:    true,
				ForceNew:    true,
				Description: `The ID value for the new release.`,
			},
			"unit_kind": {
				Type:     schema.TypeString,
				Required: true,
				ForceNew: true,
				Description: `Reference to the UnitKind this Release corresponds to (required and
immutable once created).`,
			},
			"annotations": {
				Type:     schema.TypeMap,
				Optional: true,
				Description: `Annotations is an unstructured key-value map stored with a resource that
may be set by external tools to store and retrieve arbitrary metadata.
They are not queryable and should be preserved when modifying objects.

More info: https://kubernetes.io/docs/user-guide/annotations

**Note**: This field is non-authoritative, and will only manage the annotations present in your configuration.
Please refer to the field 'effective_annotations' for all of the annotations present on the resource.`,
				Elem: &schema.Schema{Type: schema.TypeString},
			},
			"blueprint": {
				Type:     schema.TypeList,
				Optional: true,
				Description: `Blueprints are OCI Images that contain all of the artifacts needed to
provision a unit. Metadata such as, type of the engine used to actuate the
blueprint (e.g. terraform, helm etc) and version will come from the image
manifest. If the hostname is omitted, it will be assumed to be the regional
path to Artifact Registry (eg. us-east1-docker.pkg.dev).`,
				MaxItems: 1,
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						"package": {
							Type:     schema.TypeString,
							Optional: true,
							ForceNew: true,
							Description: `URI to a blueprint used by the Unit (required unless unitKind or release is
set).`,
						},
						"engine": {
							Type:        schema.TypeString,
							Computed:    true,
							Description: `Type of the engine used to actuate the blueprint. e.g. terraform, helm etc.`,
						},
						"version": {
							Type:        schema.TypeString,
							Computed:    true,
							Description: `Version metadata if present on the blueprint.`,
						},
					},
				},
			},
			"input_variable_defaults": {
				Type:        schema.TypeList,
				Optional:    true,
				Description: `Mapping of input variables to default values. Maximum 100`,
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						"variable": {
							Type:        schema.TypeString,
							Required:    true,
							ForceNew:    true,
							Description: `Name of the variable from actuation configs.`,
						},
						"type": {
							Type:         schema.TypeString,
							Optional:     true,
							ForceNew:     true,
							ValidateFunc: verify.ValidateEnum([]string{"TYPE_UNSPECIFIED", "STRING", "INT", "BOOL", ""}),
							Description:  `Name of a supported variable type. Supported types are STRING, INT, BOOL. Possible values: ["TYPE_UNSPECIFIED", "STRING", "INT", "BOOL"]`,
						},
						"value": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: `String encoded value for the variable.`,
						},
					},
				},
			},
			"labels": {
				Type:     schema.TypeMap,
				Optional: true,
				Description: `The labels on the resource, which can be used for categorization.
similar to Kubernetes resource labels.

**Note**: This field is non-authoritative, and will only manage the labels present in your configuration.
Please refer to the field 'effective_labels' for all of the labels present on the resource.`,
				Elem: &schema.Schema{Type: schema.TypeString},
			},
			"release_requirements": {
				Type:        schema.TypeList,
				Optional:    true,
				Description: `Set of requirements to be fulfilled on the Unit when using this Release.`,
				MaxItems:    1,
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						"upgradeable_from_releases": {
							Type:     schema.TypeList,
							Optional: true,
							Description: `A list of releases from which a unit can be upgraded to this one
(optional). If left empty no constraints will be applied. When provided,
unit upgrade requests to this release will check and enforce this
constraint.`,
							Elem: &schema.Schema{
								Type: schema.TypeString,
							},
						},
					},
				},
			},
			"create_time": {
				Type:        schema.TypeString,
				Computed:    true,
				Description: `The timestamp when the resource was created.`,
			},
			"effective_annotations": {
				Type:        schema.TypeMap,
				Computed:    true,
				Description: `All of annotations (key/value pairs) present on the resource in GCP, including the annotations configured through Terraform, other clients and services.`,
				Elem:        &schema.Schema{Type: schema.TypeString},
			},
			"effective_labels": {
				Type:        schema.TypeMap,
				Computed:    true,
				Description: `All of labels (key/value pairs) present on the resource in GCP, including the labels configured through Terraform, other clients and services.`,
				Elem:        &schema.Schema{Type: schema.TypeString},
			},
			"etag": {
				Type:     schema.TypeString,
				Computed: true,
				Description: `An opaque value that uniquely identifies a version or
generation of a resource. It can be used to confirm that the client
and server agree on the ordering of a resource being written.`,
			},
			"input_variables": {
				Type:     schema.TypeList,
				Computed: true,
				Description: `List of input variables declared on the blueprint and can be present with
their values on the unit spec`,
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						"variable": {
							Type:        schema.TypeString,
							Required:    true,
							ForceNew:    true,
							Description: `Name of the variable from actuation configs.`,
						},
						"type": {
							Type:         schema.TypeString,
							Optional:     true,
							ForceNew:     true,
							ValidateFunc: verify.ValidateEnum([]string{"TYPE_UNSPECIFIED", "STRING", "INT", "BOOL", ""}),
							Description:  `Name of a supported variable type. Supported types are STRING, INT, BOOL. Possible values: ["TYPE_UNSPECIFIED", "STRING", "INT", "BOOL"]`,
						},
						"value": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: `String encoded value for the variable.`,
						},
					},
				},
			},
			"name": {
				Type:     schema.TypeString,
				Computed: true,
				Description: `Identifier. The resource name (full URI of the resource) following the standard naming
scheme:

"projects/{project}/locations/{location}/releases/{release}"`,
			},
			"output_variables": {
				Type:     schema.TypeList,
				Computed: true,
				Description: `List of output variables declared on the blueprint and can be present with
their values on the unit status`,
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						"variable": {
							Type:        schema.TypeString,
							Required:    true,
							ForceNew:    true,
							Description: `Name of the variable from actuation configs.`,
						},
						"type": {
							Type:         schema.TypeString,
							Optional:     true,
							ForceNew:     true,
							ValidateFunc: verify.ValidateEnum([]string{"TYPE_UNSPECIFIED", "STRING", "INT", "BOOL", ""}),
							Description:  `Name of a supported variable type. Supported types are STRING, INT, BOOL. Possible values: ["TYPE_UNSPECIFIED", "STRING", "INT", "BOOL"]`,
						},
						"value": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: `String encoded value for the variable.`,
						},
					},
				},
			},
			"terraform_labels": {
				Type:     schema.TypeMap,
				Computed: true,
				Description: `The combination of labels configured directly on the resource
 and default labels configured on the provider.`,
				Elem: &schema.Schema{Type: schema.TypeString},
			},
			"uid": {
				Type:     schema.TypeString,
				Computed: true,
				Description: `The unique identifier of the resource. UID is unique in the time
and space for this resource within the scope of the service. It is
typically generated by the server on successful creation of a resource
and must not be changed. UID is used to uniquely identify resources
with resource name reuses. This should be a UUID4.`,
			},
			"update_time": {
				Type:     schema.TypeString,
				Computed: true,
				Description: `The timestamp when the resource was last updated. Any
change to the resource made by users must refresh this value.
Changes to a resource made by the service should refresh this value.`,
			},
			"project": {
				Type:     schema.TypeString,
				Optional: true,
				Computed: true,
				ForceNew: true,
			},
		},
		UseJSONNumber: true,
	}
}

func resourceSaasRuntimeReleaseCreate(d *schema.ResourceData, meta interface{}) error {
	config := meta.(*transport_tpg.Config)
	userAgent, err := tpgresource.GenerateUserAgentString(d, config.UserAgent)
	if err != nil {
		return err
	}

	obj := make(map[string]interface{})
	blueprintProp, err := expandSaasRuntimeReleaseBlueprint(d.Get("blueprint"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("blueprint"); !tpgresource.IsEmptyValue(reflect.ValueOf(blueprintProp)) && (ok || !reflect.DeepEqual(v, blueprintProp)) {
		obj["blueprint"] = blueprintProp
	}
	inputVariableDefaultsProp, err := expandSaasRuntimeReleaseInputVariableDefaults(d.Get("input_variable_defaults"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("input_variable_defaults"); !tpgresource.IsEmptyValue(reflect.ValueOf(inputVariableDefaultsProp)) && (ok || !reflect.DeepEqual(v, inputVariableDefaultsProp)) {
		obj["inputVariableDefaults"] = inputVariableDefaultsProp
	}
	releaseRequirementsProp, err := expandSaasRuntimeReleaseReleaseRequirements(d.Get("release_requirements"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("release_requirements"); !tpgresource.IsEmptyValue(reflect.ValueOf(releaseRequirementsProp)) && (ok || !reflect.DeepEqual(v, releaseRequirementsProp)) {
		obj["releaseRequirements"] = releaseRequirementsProp
	}
	unitKindProp, err := expandSaasRuntimeReleaseUnitKind(d.Get("unit_kind"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("unit_kind"); !tpgresource.IsEmptyValue(reflect.ValueOf(unitKindProp)) && (ok || !reflect.DeepEqual(v, unitKindProp)) {
		obj["unitKind"] = unitKindProp
	}
	effectiveAnnotationsProp, err := expandSaasRuntimeReleaseEffectiveAnnotations(d.Get("effective_annotations"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("effective_annotations"); !tpgresource.IsEmptyValue(reflect.ValueOf(effectiveAnnotationsProp)) && (ok || !reflect.DeepEqual(v, effectiveAnnotationsProp)) {
		obj["annotations"] = effectiveAnnotationsProp
	}
	effectiveLabelsProp, err := expandSaasRuntimeReleaseEffectiveLabels(d.Get("effective_labels"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("effective_labels"); !tpgresource.IsEmptyValue(reflect.ValueOf(effectiveLabelsProp)) && (ok || !reflect.DeepEqual(v, effectiveLabelsProp)) {
		obj["labels"] = effectiveLabelsProp
	}

	url, err := tpgresource.ReplaceVars(d, config, "{{SaasRuntimeBasePath}}projects/{{project}}/locations/{{location}}/releases?releaseId={{release_id}}")
	if err != nil {
		return err
	}

	log.Printf("[DEBUG] Creating new Release: %#v", obj)
	billingProject := ""

	project, err := tpgresource.GetProject(d, config)
	if err != nil {
		return fmt.Errorf("Error fetching project for Release: %s", err)
	}
	billingProject = project

	// err == nil indicates that the billing_project value was found
	if bp, err := tpgresource.GetBillingProject(d, config); err == nil {
		billingProject = bp
	}

	headers := make(http.Header)
	res, err := transport_tpg.SendRequest(transport_tpg.SendRequestOptions{
		Config:    config,
		Method:    "POST",
		Project:   billingProject,
		RawURL:    url,
		UserAgent: userAgent,
		Body:      obj,
		Timeout:   d.Timeout(schema.TimeoutCreate),
		Headers:   headers,
	})
	if err != nil {
		return fmt.Errorf("Error creating Release: %s", err)
	}

	// Store the ID now
	id, err := tpgresource.ReplaceVars(d, config, "projects/{{project}}/locations/{{location}}/releases/{{release_id}}")
	if err != nil {
		return fmt.Errorf("Error constructing id: %s", err)
	}
	d.SetId(id)

	log.Printf("[DEBUG] Finished creating Release %q: %#v", d.Id(), res)

	return resourceSaasRuntimeReleaseRead(d, meta)
}

func resourceSaasRuntimeReleaseRead(d *schema.ResourceData, meta interface{}) error {
	config := meta.(*transport_tpg.Config)
	userAgent, err := tpgresource.GenerateUserAgentString(d, config.UserAgent)
	if err != nil {
		return err
	}

	url, err := tpgresource.ReplaceVars(d, config, "{{SaasRuntimeBasePath}}projects/{{project}}/locations/{{location}}/releases/{{release_id}}")
	if err != nil {
		return err
	}

	billingProject := ""

	project, err := tpgresource.GetProject(d, config)
	if err != nil {
		return fmt.Errorf("Error fetching project for Release: %s", err)
	}
	billingProject = project

	// err == nil indicates that the billing_project value was found
	if bp, err := tpgresource.GetBillingProject(d, config); err == nil {
		billingProject = bp
	}

	headers := make(http.Header)
	res, err := transport_tpg.SendRequest(transport_tpg.SendRequestOptions{
		Config:    config,
		Method:    "GET",
		Project:   billingProject,
		RawURL:    url,
		UserAgent: userAgent,
		Headers:   headers,
	})
	if err != nil {
		return transport_tpg.HandleNotFoundError(err, d, fmt.Sprintf("SaasRuntimeRelease %q", d.Id()))
	}

	if err := d.Set("project", project); err != nil {
		return fmt.Errorf("Error reading Release: %s", err)
	}

	if err := d.Set("annotations", flattenSaasRuntimeReleaseAnnotations(res["annotations"], d, config)); err != nil {
		return fmt.Errorf("Error reading Release: %s", err)
	}
	if err := d.Set("blueprint", flattenSaasRuntimeReleaseBlueprint(res["blueprint"], d, config)); err != nil {
		return fmt.Errorf("Error reading Release: %s", err)
	}
	if err := d.Set("create_time", flattenSaasRuntimeReleaseCreateTime(res["createTime"], d, config)); err != nil {
		return fmt.Errorf("Error reading Release: %s", err)
	}
	if err := d.Set("etag", flattenSaasRuntimeReleaseEtag(res["etag"], d, config)); err != nil {
		return fmt.Errorf("Error reading Release: %s", err)
	}
	if err := d.Set("input_variable_defaults", flattenSaasRuntimeReleaseInputVariableDefaults(res["inputVariableDefaults"], d, config)); err != nil {
		return fmt.Errorf("Error reading Release: %s", err)
	}
	if err := d.Set("input_variables", flattenSaasRuntimeReleaseInputVariables(res["inputVariables"], d, config)); err != nil {
		return fmt.Errorf("Error reading Release: %s", err)
	}
	if err := d.Set("labels", flattenSaasRuntimeReleaseLabels(res["labels"], d, config)); err != nil {
		return fmt.Errorf("Error reading Release: %s", err)
	}
	if err := d.Set("name", flattenSaasRuntimeReleaseName(res["name"], d, config)); err != nil {
		return fmt.Errorf("Error reading Release: %s", err)
	}
	if err := d.Set("output_variables", flattenSaasRuntimeReleaseOutputVariables(res["outputVariables"], d, config)); err != nil {
		return fmt.Errorf("Error reading Release: %s", err)
	}
	if err := d.Set("release_requirements", flattenSaasRuntimeReleaseReleaseRequirements(res["releaseRequirements"], d, config)); err != nil {
		return fmt.Errorf("Error reading Release: %s", err)
	}
	if err := d.Set("uid", flattenSaasRuntimeReleaseUid(res["uid"], d, config)); err != nil {
		return fmt.Errorf("Error reading Release: %s", err)
	}
	if err := d.Set("unit_kind", flattenSaasRuntimeReleaseUnitKind(res["unitKind"], d, config)); err != nil {
		return fmt.Errorf("Error reading Release: %s", err)
	}
	if err := d.Set("update_time", flattenSaasRuntimeReleaseUpdateTime(res["updateTime"], d, config)); err != nil {
		return fmt.Errorf("Error reading Release: %s", err)
	}
	if err := d.Set("effective_annotations", flattenSaasRuntimeReleaseEffectiveAnnotations(res["annotations"], d, config)); err != nil {
		return fmt.Errorf("Error reading Release: %s", err)
	}
	if err := d.Set("terraform_labels", flattenSaasRuntimeReleaseTerraformLabels(res["labels"], d, config)); err != nil {
		return fmt.Errorf("Error reading Release: %s", err)
	}
	if err := d.Set("effective_labels", flattenSaasRuntimeReleaseEffectiveLabels(res["labels"], d, config)); err != nil {
		return fmt.Errorf("Error reading Release: %s", err)
	}

	return nil
}

func resourceSaasRuntimeReleaseUpdate(d *schema.ResourceData, meta interface{}) error {
	config := meta.(*transport_tpg.Config)
	userAgent, err := tpgresource.GenerateUserAgentString(d, config.UserAgent)
	if err != nil {
		return err
	}

	billingProject := ""

	project, err := tpgresource.GetProject(d, config)
	if err != nil {
		return fmt.Errorf("Error fetching project for Release: %s", err)
	}
	billingProject = project

	obj := make(map[string]interface{})
	blueprintProp, err := expandSaasRuntimeReleaseBlueprint(d.Get("blueprint"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("blueprint"); !tpgresource.IsEmptyValue(reflect.ValueOf(v)) && (ok || !reflect.DeepEqual(v, blueprintProp)) {
		obj["blueprint"] = blueprintProp
	}
	inputVariableDefaultsProp, err := expandSaasRuntimeReleaseInputVariableDefaults(d.Get("input_variable_defaults"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("input_variable_defaults"); !tpgresource.IsEmptyValue(reflect.ValueOf(v)) && (ok || !reflect.DeepEqual(v, inputVariableDefaultsProp)) {
		obj["inputVariableDefaults"] = inputVariableDefaultsProp
	}
	releaseRequirementsProp, err := expandSaasRuntimeReleaseReleaseRequirements(d.Get("release_requirements"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("release_requirements"); !tpgresource.IsEmptyValue(reflect.ValueOf(v)) && (ok || !reflect.DeepEqual(v, releaseRequirementsProp)) {
		obj["releaseRequirements"] = releaseRequirementsProp
	}
	effectiveAnnotationsProp, err := expandSaasRuntimeReleaseEffectiveAnnotations(d.Get("effective_annotations"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("effective_annotations"); !tpgresource.IsEmptyValue(reflect.ValueOf(v)) && (ok || !reflect.DeepEqual(v, effectiveAnnotationsProp)) {
		obj["annotations"] = effectiveAnnotationsProp
	}
	effectiveLabelsProp, err := expandSaasRuntimeReleaseEffectiveLabels(d.Get("effective_labels"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("effective_labels"); !tpgresource.IsEmptyValue(reflect.ValueOf(v)) && (ok || !reflect.DeepEqual(v, effectiveLabelsProp)) {
		obj["labels"] = effectiveLabelsProp
	}

	url, err := tpgresource.ReplaceVars(d, config, "{{SaasRuntimeBasePath}}projects/{{project}}/locations/{{location}}/releases/{{release_id}}")
	if err != nil {
		return err
	}

	log.Printf("[DEBUG] Updating Release %q: %#v", d.Id(), obj)
	headers := make(http.Header)
	updateMask := []string{}

	if d.HasChange("blueprint") {
		updateMask = append(updateMask, "blueprint")
	}

	if d.HasChange("input_variable_defaults") {
		updateMask = append(updateMask, "inputVariableDefaults")
	}

	if d.HasChange("release_requirements") {
		updateMask = append(updateMask, "releaseRequirements")
	}

	if d.HasChange("effective_annotations") {
		updateMask = append(updateMask, "annotations")
	}

	if d.HasChange("effective_labels") {
		updateMask = append(updateMask, "labels")
	}
	// updateMask is a URL parameter but not present in the schema, so ReplaceVars
	// won't set it
	url, err = transport_tpg.AddQueryParams(url, map[string]string{"updateMask": strings.Join(updateMask, ",")})
	if err != nil {
		return err
	}

	// err == nil indicates that the billing_project value was found
	if bp, err := tpgresource.GetBillingProject(d, config); err == nil {
		billingProject = bp
	}

	// if updateMask is empty we are not updating anything so skip the post
	if len(updateMask) > 0 {
		res, err := transport_tpg.SendRequest(transport_tpg.SendRequestOptions{
			Config:    config,
			Method:    "PATCH",
			Project:   billingProject,
			RawURL:    url,
			UserAgent: userAgent,
			Body:      obj,
			Timeout:   d.Timeout(schema.TimeoutUpdate),
			Headers:   headers,
		})

		if err != nil {
			return fmt.Errorf("Error updating Release %q: %s", d.Id(), err)
		} else {
			log.Printf("[DEBUG] Finished updating Release %q: %#v", d.Id(), res)
		}

	}

	return resourceSaasRuntimeReleaseRead(d, meta)
}

func resourceSaasRuntimeReleaseDelete(d *schema.ResourceData, meta interface{}) error {
	config := meta.(*transport_tpg.Config)
	userAgent, err := tpgresource.GenerateUserAgentString(d, config.UserAgent)
	if err != nil {
		return err
	}

	billingProject := ""

	project, err := tpgresource.GetProject(d, config)
	if err != nil {
		return fmt.Errorf("Error fetching project for Release: %s", err)
	}
	billingProject = project

	url, err := tpgresource.ReplaceVars(d, config, "{{SaasRuntimeBasePath}}projects/{{project}}/locations/{{location}}/releases/{{release_id}}")
	if err != nil {
		return err
	}

	var obj map[string]interface{}

	// err == nil indicates that the billing_project value was found
	if bp, err := tpgresource.GetBillingProject(d, config); err == nil {
		billingProject = bp
	}

	headers := make(http.Header)

	log.Printf("[DEBUG] Deleting Release %q", d.Id())
	res, err := transport_tpg.SendRequest(transport_tpg.SendRequestOptions{
		Config:    config,
		Method:    "DELETE",
		Project:   billingProject,
		RawURL:    url,
		UserAgent: userAgent,
		Body:      obj,
		Timeout:   d.Timeout(schema.TimeoutDelete),
		Headers:   headers,
	})
	if err != nil {
		return transport_tpg.HandleNotFoundError(err, d, "Release")
	}

	log.Printf("[DEBUG] Finished deleting Release %q: %#v", d.Id(), res)
	return nil
}

func resourceSaasRuntimeReleaseImport(d *schema.ResourceData, meta interface{}) ([]*schema.ResourceData, error) {
	config := meta.(*transport_tpg.Config)
	if err := tpgresource.ParseImportId([]string{
		"^projects/(?P<project>[^/]+)/locations/(?P<location>[^/]+)/releases/(?P<release_id>[^/]+)$",
		"^(?P<project>[^/]+)/(?P<location>[^/]+)/(?P<release_id>[^/]+)$",
		"^(?P<location>[^/]+)/(?P<release_id>[^/]+)$",
	}, d, config); err != nil {
		return nil, err
	}

	// Replace import id for the resource id
	id, err := tpgresource.ReplaceVars(d, config, "projects/{{project}}/locations/{{location}}/releases/{{release_id}}")
	if err != nil {
		return nil, fmt.Errorf("Error constructing id: %s", err)
	}
	d.SetId(id)

	return []*schema.ResourceData{d}, nil
}

func flattenSaasRuntimeReleaseAnnotations(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return v
	}

	transformed := make(map[string]interface{})
	if l, ok := d.GetOkExists("annotations"); ok {
		for k := range l.(map[string]interface{}) {
			transformed[k] = v.(map[string]interface{})[k]
		}
	}

	return transformed
}

func flattenSaasRuntimeReleaseBlueprint(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return nil
	}
	original := v.(map[string]interface{})
	if len(original) == 0 {
		return nil
	}
	transformed := make(map[string]interface{})
	transformed["engine"] =
		flattenSaasRuntimeReleaseBlueprintEngine(original["engine"], d, config)
	transformed["package"] =
		flattenSaasRuntimeReleaseBlueprintPackage(original["package"], d, config)
	transformed["version"] =
		flattenSaasRuntimeReleaseBlueprintVersion(original["version"], d, config)
	return []interface{}{transformed}
}
func flattenSaasRuntimeReleaseBlueprintEngine(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenSaasRuntimeReleaseBlueprintPackage(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenSaasRuntimeReleaseBlueprintVersion(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenSaasRuntimeReleaseCreateTime(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenSaasRuntimeReleaseEtag(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenSaasRuntimeReleaseInputVariableDefaults(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return v
	}
	l := v.([]interface{})
	transformed := make([]interface{}, 0, len(l))
	for _, raw := range l {
		original := raw.(map[string]interface{})
		if len(original) < 1 {
			// Do not include empty json objects coming back from the api
			continue
		}
		transformed = append(transformed, map[string]interface{}{
			"type":     flattenSaasRuntimeReleaseInputVariableDefaultsType(original["type"], d, config),
			"value":    flattenSaasRuntimeReleaseInputVariableDefaultsValue(original["value"], d, config),
			"variable": flattenSaasRuntimeReleaseInputVariableDefaultsVariable(original["variable"], d, config),
		})
	}
	return transformed
}
func flattenSaasRuntimeReleaseInputVariableDefaultsType(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenSaasRuntimeReleaseInputVariableDefaultsValue(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenSaasRuntimeReleaseInputVariableDefaultsVariable(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenSaasRuntimeReleaseInputVariables(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return v
	}
	l := v.([]interface{})
	transformed := make([]interface{}, 0, len(l))
	for _, raw := range l {
		original := raw.(map[string]interface{})
		if len(original) < 1 {
			// Do not include empty json objects coming back from the api
			continue
		}
		transformed = append(transformed, map[string]interface{}{
			"type":     flattenSaasRuntimeReleaseInputVariablesType(original["type"], d, config),
			"value":    flattenSaasRuntimeReleaseInputVariablesValue(original["value"], d, config),
			"variable": flattenSaasRuntimeReleaseInputVariablesVariable(original["variable"], d, config),
		})
	}
	return transformed
}
func flattenSaasRuntimeReleaseInputVariablesType(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenSaasRuntimeReleaseInputVariablesValue(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenSaasRuntimeReleaseInputVariablesVariable(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenSaasRuntimeReleaseLabels(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return v
	}

	transformed := make(map[string]interface{})
	if l, ok := d.GetOkExists("labels"); ok {
		for k := range l.(map[string]interface{}) {
			transformed[k] = v.(map[string]interface{})[k]
		}
	}

	return transformed
}

func flattenSaasRuntimeReleaseName(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenSaasRuntimeReleaseOutputVariables(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return v
	}
	l := v.([]interface{})
	transformed := make([]interface{}, 0, len(l))
	for _, raw := range l {
		original := raw.(map[string]interface{})
		if len(original) < 1 {
			// Do not include empty json objects coming back from the api
			continue
		}
		transformed = append(transformed, map[string]interface{}{
			"type":     flattenSaasRuntimeReleaseOutputVariablesType(original["type"], d, config),
			"value":    flattenSaasRuntimeReleaseOutputVariablesValue(original["value"], d, config),
			"variable": flattenSaasRuntimeReleaseOutputVariablesVariable(original["variable"], d, config),
		})
	}
	return transformed
}
func flattenSaasRuntimeReleaseOutputVariablesType(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenSaasRuntimeReleaseOutputVariablesValue(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenSaasRuntimeReleaseOutputVariablesVariable(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenSaasRuntimeReleaseReleaseRequirements(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return nil
	}
	original := v.(map[string]interface{})
	if len(original) == 0 {
		return nil
	}
	transformed := make(map[string]interface{})
	transformed["upgradeable_from_releases"] =
		flattenSaasRuntimeReleaseReleaseRequirementsUpgradeableFromReleases(original["upgradeableFromReleases"], d, config)
	return []interface{}{transformed}
}
func flattenSaasRuntimeReleaseReleaseRequirementsUpgradeableFromReleases(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenSaasRuntimeReleaseUid(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenSaasRuntimeReleaseUnitKind(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenSaasRuntimeReleaseUpdateTime(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenSaasRuntimeReleaseEffectiveAnnotations(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenSaasRuntimeReleaseTerraformLabels(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return v
	}

	transformed := make(map[string]interface{})
	if l, ok := d.GetOkExists("terraform_labels"); ok {
		for k := range l.(map[string]interface{}) {
			transformed[k] = v.(map[string]interface{})[k]
		}
	}

	return transformed
}

func flattenSaasRuntimeReleaseEffectiveLabels(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func expandSaasRuntimeReleaseBlueprint(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	if v == nil {
		return nil, nil
	}
	l := v.([]interface{})
	if len(l) == 0 || l[0] == nil {
		return nil, nil
	}
	raw := l[0]
	original := raw.(map[string]interface{})
	transformed := make(map[string]interface{})

	transformedEngine, err := expandSaasRuntimeReleaseBlueprintEngine(original["engine"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedEngine); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["engine"] = transformedEngine
	}

	transformedPackage, err := expandSaasRuntimeReleaseBlueprintPackage(original["package"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedPackage); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["package"] = transformedPackage
	}

	transformedVersion, err := expandSaasRuntimeReleaseBlueprintVersion(original["version"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedVersion); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["version"] = transformedVersion
	}

	return transformed, nil
}

func expandSaasRuntimeReleaseBlueprintEngine(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandSaasRuntimeReleaseBlueprintPackage(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandSaasRuntimeReleaseBlueprintVersion(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandSaasRuntimeReleaseInputVariableDefaults(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	if v == nil {
		return nil, nil
	}
	l := v.([]interface{})
	req := make([]interface{}, 0, len(l))
	for _, raw := range l {
		if raw == nil {
			continue
		}
		original := raw.(map[string]interface{})
		transformed := make(map[string]interface{})

		transformedType, err := expandSaasRuntimeReleaseInputVariableDefaultsType(original["type"], d, config)
		if err != nil {
			return nil, err
		} else if val := reflect.ValueOf(transformedType); val.IsValid() && !tpgresource.IsEmptyValue(val) {
			transformed["type"] = transformedType
		}

		transformedValue, err := expandSaasRuntimeReleaseInputVariableDefaultsValue(original["value"], d, config)
		if err != nil {
			return nil, err
		} else if val := reflect.ValueOf(transformedValue); val.IsValid() && !tpgresource.IsEmptyValue(val) {
			transformed["value"] = transformedValue
		}

		transformedVariable, err := expandSaasRuntimeReleaseInputVariableDefaultsVariable(original["variable"], d, config)
		if err != nil {
			return nil, err
		} else if val := reflect.ValueOf(transformedVariable); val.IsValid() && !tpgresource.IsEmptyValue(val) {
			transformed["variable"] = transformedVariable
		}

		req = append(req, transformed)
	}
	return req, nil
}

func expandSaasRuntimeReleaseInputVariableDefaultsType(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandSaasRuntimeReleaseInputVariableDefaultsValue(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandSaasRuntimeReleaseInputVariableDefaultsVariable(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandSaasRuntimeReleaseReleaseRequirements(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	if v == nil {
		return nil, nil
	}
	l := v.([]interface{})
	if len(l) == 0 || l[0] == nil {
		return nil, nil
	}
	raw := l[0]
	original := raw.(map[string]interface{})
	transformed := make(map[string]interface{})

	transformedUpgradeableFromReleases, err := expandSaasRuntimeReleaseReleaseRequirementsUpgradeableFromReleases(original["upgradeable_from_releases"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedUpgradeableFromReleases); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["upgradeableFromReleases"] = transformedUpgradeableFromReleases
	}

	return transformed, nil
}

func expandSaasRuntimeReleaseReleaseRequirementsUpgradeableFromReleases(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandSaasRuntimeReleaseUnitKind(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandSaasRuntimeReleaseEffectiveAnnotations(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (map[string]string, error) {
	if v == nil {
		return map[string]string{}, nil
	}
	m := make(map[string]string)
	for k, val := range v.(map[string]interface{}) {
		m[k] = val.(string)
	}
	return m, nil
}

func expandSaasRuntimeReleaseEffectiveLabels(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (map[string]string, error) {
	if v == nil {
		return map[string]string{}, nil
	}
	m := make(map[string]string)
	for k, val := range v.(map[string]interface{}) {
		m[k] = val.(string)
	}
	return m, nil
}
