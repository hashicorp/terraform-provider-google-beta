// Copyright (c) HashiCorp, Inc.
// SPDX-License-Identifier: MPL-2.0

// ----------------------------------------------------------------------------
//
//     ***     AUTO GENERATED CODE    ***    Type: MMv1     ***
//
// ----------------------------------------------------------------------------
//
//     This code is generated by Magic Modules using the following:
//
//     Configuration: https://github.com/GoogleCloudPlatform/magic-modules/tree/main/mmv1/products/saasservicemgmt/UnitOperation.yaml
//     Template:      https://github.com/GoogleCloudPlatform/magic-modules/tree/main/mmv1/templates/terraform/resource.go.tmpl
//
//     DO NOT EDIT this file directly. Any changes made to this file will be
//     overwritten during the next generation cycle.
//
// ----------------------------------------------------------------------------

package saasruntime

import (
	"bytes"
	"context"
	"encoding/base64"
	"encoding/json"
	"fmt"
	"log"
	"net/http"
	"reflect"
	"regexp"
	"slices"
	"sort"
	"strconv"
	"strings"
	"time"

	"github.com/hashicorp/errwrap"
	"github.com/hashicorp/go-cty/cty"
	"github.com/hashicorp/terraform-plugin-sdk/v2/diag"
	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/customdiff"
	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/id"
	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/logging"
	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/retry"
	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/schema"
	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/structure"
	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/validation"
	"github.com/hashicorp/terraform-plugin-sdk/v2/terraform"

	"github.com/hashicorp/terraform-provider-google-beta/google-beta/registry"
	"github.com/hashicorp/terraform-provider-google-beta/google-beta/tpgresource"
	transport_tpg "github.com/hashicorp/terraform-provider-google-beta/google-beta/transport"
	"github.com/hashicorp/terraform-provider-google-beta/google-beta/verify"

	"google.golang.org/api/googleapi"
)

var (
	_ = bytes.Clone
	_ = context.WithCancel
	_ = base64.NewDecoder
	_ = json.Marshal
	_ = fmt.Sprintf
	_ = log.Print
	_ = http.Get
	_ = reflect.ValueOf
	_ = regexp.Match
	_ = slices.Min([]int{1})
	_ = sort.IntSlice{}
	_ = strconv.Atoi
	_ = strings.Trim
	_ = time.Now
	_ = errwrap.Wrap
	_ = cty.BoolVal
	_ = diag.Diagnostic{}
	_ = customdiff.All
	_ = id.UniqueId
	_ = logging.LogLevel
	_ = retry.Retry
	_ = schema.Noop
	_ = validation.All
	_ = structure.ExpandJsonFromString
	_ = terraform.State{}
	_ = tpgresource.SetLabels
	_ = transport_tpg.Config{}
	_ = verify.ValidateEnum
	_ = googleapi.Error{}
)

func init() {
	registry.Schema{
		Name:        "google_saas_runtime_unit_operation",
		ProductName: "saasruntime",
		Type:        registry.SchemaTypeResource,
		Schema:      ResourceSaasRuntimeUnitOperation(),
	}.Register()
}

func ResourceSaasRuntimeUnitOperation() *schema.Resource {
	return &schema.Resource{
		Create: resourceSaasRuntimeUnitOperationCreate,
		Read:   resourceSaasRuntimeUnitOperationRead,
		Update: resourceSaasRuntimeUnitOperationUpdate,
		Delete: resourceSaasRuntimeUnitOperationDelete,

		Importer: &schema.ResourceImporter{
			State: resourceSaasRuntimeUnitOperationImport,
		},

		Timeouts: &schema.ResourceTimeout{
			Create: schema.DefaultTimeout(20 * time.Minute),
			Update: schema.DefaultTimeout(20 * time.Minute),
			Delete: schema.DefaultTimeout(20 * time.Minute),
		},

		CustomizeDiff: customdiff.All(
			tpgresource.SetAnnotationsDiff,
			tpgresource.SetLabelsDiff,
			tpgresource.DefaultProviderProject,
		),

		Schema: map[string]*schema.Schema{
			"location": {
				Type:        schema.TypeString,
				Required:    true,
				ForceNew:    true,
				Description: `Resource ID segment making up resource 'name'. It identifies the resource within its parent collection as described in https://google.aip.dev/122.`,
			},
			"unit": {
				Type:        schema.TypeString,
				Required:    true,
				ForceNew:    true,
				Description: `The Unit a given UnitOperation will act upon.`,
			},
			"unit_operation_id": {
				Type:        schema.TypeString,
				Required:    true,
				ForceNew:    true,
				Description: `The ID value for the new unit operation.`,
			},
			"annotations": {
				Type:     schema.TypeMap,
				Optional: true,
				ForceNew: true,
				Description: `Annotations is an unstructured key-value map stored with a resource that
may be set by external tools to store and retrieve arbitrary metadata.
They are not queryable and should be preserved when modifying objects.

More info: https://kubernetes.io/docs/user-guide/annotations

**Note**: This field is non-authoritative, and will only manage the annotations present in your configuration.
Please refer to the field 'effective_annotations' for all of the annotations present on the resource.`,
				Elem: &schema.Schema{Type: schema.TypeString},
			},
			"deprovision": {
				Type:     schema.TypeList,
				Optional: true,
				ForceNew: true,
				Description: `Deprovision is the unit operation that deprovision the underlying
resources represented by a Unit. Can only execute if the Unit is currently
provisioned.`,
				MaxItems: 1,
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{},
				},
			},
			"labels": {
				Type:     schema.TypeMap,
				Optional: true,
				Description: `The labels on the resource, which can be used for categorization.
similar to Kubernetes resource labels.

**Note**: This field is non-authoritative, and will only manage the labels present in your configuration.
Please refer to the field 'effective_labels' for all of the labels present on the resource.`,
				Elem: &schema.Schema{Type: schema.TypeString},
			},
			"provision": {
				Type:     schema.TypeList,
				Optional: true,
				ForceNew: true,
				Description: `Provision is the unit operation that provision the underlying resources
represented by a Unit. Can only execute if the Unit is not currently
provisioned.`,
				MaxItems: 1,
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						"input_variables": {
							Type:        schema.TypeList,
							Optional:    true,
							ForceNew:    true,
							Description: `Set of input variables. Maximum 100. (optional)`,
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{
									"variable": {
										Type:        schema.TypeString,
										Required:    true,
										ForceNew:    true,
										Description: `Name of the variable from actuation configs.`,
									},
									"type": {
										Type:     schema.TypeString,
										Optional: true,
										ForceNew: true,
										Description: `Name of a supported variable type. Supported types are string, int, bool.
Possible values:
STRING
INT
BOOL`,
									},
									"value": {
										Type:        schema.TypeString,
										Optional:    true,
										ForceNew:    true,
										Description: `String encoded value for the variable.`,
									},
								},
							},
						},
						"release": {
							Type:        schema.TypeString,
							Optional:    true,
							ForceNew:    true,
							Description: `Reference to the Release object to use for the Unit. (optional).`,
						},
					},
				},
			},
			"upgrade": {
				Type:     schema.TypeList,
				Optional: true,
				ForceNew: true,
				Description: `Upgrade is the unit operation that upgrades a provisioned unit, which may
also include the underlying resources represented by a Unit. Can only execute
if the Unit is currently provisioned.`,
				MaxItems: 1,
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						"input_variables": {
							Type:        schema.TypeList,
							Optional:    true,
							ForceNew:    true,
							Description: `Set of input variables. Maximum 100. (optional)`,
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{
									"variable": {
										Type:        schema.TypeString,
										Required:    true,
										ForceNew:    true,
										Description: `Name of the variable from actuation configs.`,
									},
									"type": {
										Type:     schema.TypeString,
										Optional: true,
										ForceNew: true,
										Description: `Name of a supported variable type. Supported types are string, int, bool.
Possible values:
STRING
INT
BOOL`,
									},
									"value": {
										Type:        schema.TypeString,
										Optional:    true,
										ForceNew:    true,
										Description: `String encoded value for the variable.`,
									},
								},
							},
						},
						"release": {
							Type:        schema.TypeString,
							Optional:    true,
							ForceNew:    true,
							Description: `Reference to the Release object to use for the Unit. (optional).`,
						},
					},
				},
			},
			"conditions": {
				Type:     schema.TypeList,
				Computed: true,
				Description: `A set of conditions which indicate the various conditions this resource can
have.`,
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						"last_transition_time": {
							Type:        schema.TypeString,
							Computed:    true,
							Description: `Last time the condition transited from one status to another.`,
						},
						"message": {
							Type:        schema.TypeString,
							Computed:    true,
							Description: `Human readable message indicating details about the last transition.`,
						},
						"reason": {
							Type:        schema.TypeString,
							Computed:    true,
							Description: `Brief reason for the condition's last transition.`,
						},
						"status": {
							Type:     schema.TypeString,
							Computed: true,
							Description: `Status of the condition.
Possible values:
STATUS_UNKNOWN
STATUS_TRUE
STATUS_FALSE`,
						},
						"type": {
							Type:     schema.TypeString,
							Computed: true,
							Description: `Type of the condition.
Possible values:
TYPE_SCHEDULED
TYPE_RUNNING
TYPE_SUCCEEDED
TYPE_CANCELLED`,
						},
					},
				},
			},
			"create_time": {
				Type:        schema.TypeString,
				Computed:    true,
				Description: `The timestamp when the resource was created.`,
			},
			"effective_annotations": {
				Type:        schema.TypeMap,
				Computed:    true,
				ForceNew:    true,
				Description: `All of annotations (key/value pairs) present on the resource in GCP, including the annotations configured through Terraform, other clients and services.`,
				Elem:        &schema.Schema{Type: schema.TypeString},
			},
			"effective_labels": {
				Type:        schema.TypeMap,
				Computed:    true,
				ForceNew:    true,
				Description: `All of labels (key/value pairs) present on the resource in GCP, including the labels configured through Terraform, other clients and services.`,
				Elem:        &schema.Schema{Type: schema.TypeString},
			},
			"engine_state": {
				Type:     schema.TypeString,
				Computed: true,
				Description: `The engine state for on-going
deployment engine operation(s).
This field is opaque for external usage.`,
			},
			"error_category": {
				Type:     schema.TypeString,
				Computed: true,
				Description: `Possible values:
NOT_APPLICABLE
FATAL
RETRIABLE
IGNORABLE
STANDARD`,
			},
			"etag": {
				Type:     schema.TypeString,
				Computed: true,
				Description: `An opaque value that uniquely identifies a version or
generation of a resource. It can be used to confirm that the client
and server agree on the ordering of a resource being written.`,
			},
			"name": {
				Type:     schema.TypeString,
				Computed: true,
				Description: `Identifier. The resource name (full URI of the resource) following the standard naming
scheme:

"projects/{project}/locations/{location}/unitOperations/{unitOperation}"`,
			},
			"state": {
				Type:     schema.TypeString,
				Computed: true,
				Description: `UnitOperationState describes the current state of the unit operation.
Possible values:
UNIT_OPERATION_STATE_UNKNOWN
UNIT_OPERATION_STATE_PENDING
UNIT_OPERATION_STATE_SCHEDULED
UNIT_OPERATION_STATE_RUNNING
UNIT_OPERATION_STATE_SUCCEEDED
UNIT_OPERATION_STATE_FAILED
UNIT_OPERATION_STATE_CANCELLED`,
			},
			"terraform_labels": {
				Type:     schema.TypeMap,
				Computed: true,
				Description: `The combination of labels configured directly on the resource
 and default labels configured on the provider.`,
				Elem: &schema.Schema{Type: schema.TypeString},
			},
			"uid": {
				Type:     schema.TypeString,
				Computed: true,
				Description: `The unique identifier of the resource. UID is unique in the time
and space for this resource within the scope of the service. It is
typically generated by the server on successful creation of a resource
and must not be changed. UID is used to uniquely identify resources
with resource name reuses. This should be a UUID4.`,
			},
			"update_time": {
				Type:     schema.TypeString,
				Computed: true,
				Description: `The timestamp when the resource was last updated. Any
change to the resource made by users must refresh this value.
Changes to a resource made by the service should refresh this value.`,
			},
			"wait_for_completion": {
				Type:     schema.TypeBool,
				Optional: true,
				Description: `If true, wait for the UnitOperation to reach a terminal state (SUCCEEDED, FAILED, CANCELLED)
before completing the apply.`,
				Default: true,
			},
			"project": {
				Type:     schema.TypeString,
				Optional: true,
				Computed: true,
				ForceNew: true,
			},
		},
		UseJSONNumber: true,
	}
}

func resourceSaasRuntimeUnitOperationCreate(d *schema.ResourceData, meta interface{}) error {
	config := meta.(*transport_tpg.Config)
	userAgent, err := tpgresource.GenerateUserAgentString(d, config.UserAgent)
	if err != nil {
		return err
	}

	obj := make(map[string]interface{})
	deprovisionProp, err := expandSaasRuntimeUnitOperationDeprovision(d.Get("deprovision"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("deprovision"); ok || !reflect.DeepEqual(v, deprovisionProp) {
		obj["deprovision"] = deprovisionProp
	}
	provisionProp, err := expandSaasRuntimeUnitOperationProvision(d.Get("provision"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("provision"); !tpgresource.IsEmptyValue(reflect.ValueOf(provisionProp)) && (ok || !reflect.DeepEqual(v, provisionProp)) {
		obj["provision"] = provisionProp
	}
	unitProp, err := expandSaasRuntimeUnitOperationUnit(d.Get("unit"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("unit"); !tpgresource.IsEmptyValue(reflect.ValueOf(unitProp)) && (ok || !reflect.DeepEqual(v, unitProp)) {
		obj["unit"] = unitProp
	}
	upgradeProp, err := expandSaasRuntimeUnitOperationUpgrade(d.Get("upgrade"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("upgrade"); !tpgresource.IsEmptyValue(reflect.ValueOf(upgradeProp)) && (ok || !reflect.DeepEqual(v, upgradeProp)) {
		obj["upgrade"] = upgradeProp
	}
	effectiveAnnotationsProp, err := expandSaasRuntimeUnitOperationEffectiveAnnotations(d.Get("effective_annotations"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("effective_annotations"); !tpgresource.IsEmptyValue(reflect.ValueOf(effectiveAnnotationsProp)) && (ok || !reflect.DeepEqual(v, effectiveAnnotationsProp)) {
		obj["annotations"] = effectiveAnnotationsProp
	}
	effectiveLabelsProp, err := expandSaasRuntimeUnitOperationEffectiveLabels(d.Get("effective_labels"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("effective_labels"); !tpgresource.IsEmptyValue(reflect.ValueOf(effectiveLabelsProp)) && (ok || !reflect.DeepEqual(v, effectiveLabelsProp)) {
		obj["labels"] = effectiveLabelsProp
	}

	url, err := tpgresource.ReplaceVars(d, config, "{{SaasRuntimeBasePath}}projects/{{project}}/locations/{{location}}/unitOperations?unitOperationId={{unit_operation_id}}")
	if err != nil {
		return err
	}

	log.Printf("[DEBUG] Creating new UnitOperation: %#v", obj)
	billingProject := ""

	project, err := tpgresource.GetProject(d, config)
	if err != nil {
		return fmt.Errorf("Error fetching project for UnitOperation: %s", err)
	}
	billingProject = project

	// err == nil indicates that the billing_project value was found
	if bp, err := tpgresource.GetBillingProject(d, config); err == nil {
		billingProject = bp
	}

	headers := make(http.Header)
	res, err := transport_tpg.SendRequest(transport_tpg.SendRequestOptions{
		Config:    config,
		Method:    "POST",
		Project:   billingProject,
		RawURL:    url,
		UserAgent: userAgent,
		Body:      obj,
		Timeout:   d.Timeout(schema.TimeoutCreate),
		Headers:   headers,
	})
	if err != nil {
		return fmt.Errorf("Error creating UnitOperation: %s", err)
	}

	// Store the ID now
	id, err := tpgresource.ReplaceVars(d, config, "projects/{{project}}/locations/{{location}}/unitOperations/{{unit_operation_id}}")
	if err != nil {
		return fmt.Errorf("Error constructing id: %s", err)
	}
	d.SetId(id)

	if d.Get("wait_for_completion").(bool) {
		log.Printf("[DEBUG] Waiting for UnitOperation %q to reach terminal state", d.Id())
		err := transport_tpg.Retry(transport_tpg.RetryOptions{
			Timeout: d.Timeout(schema.TimeoutCreate),
			RetryFunc: func() error {
				url, err := tpgresource.ReplaceVars(d, config, "{{SaasRuntimeBasePath}}projects/{{project}}/locations/{{location}}/unitOperations/{{unit_operation_id}}")
				if err != nil {
					return err
				}

				res, err := transport_tpg.SendRequest(transport_tpg.SendRequestOptions{
					Config:    config,
					Method:    "GET",
					Project:   billingProject,
					RawURL:    url,
					UserAgent: userAgent,
				})
				if err != nil {
					return fmt.Errorf("transient error retrieving UnitOperation state: %s", err)
				}

				state, ok := res["state"].(string)
				if !ok {
					return fmt.Errorf("UnitOperation %q did not return a state field", d.Id())
				}

				log.Printf("[DEBUG] UnitOperation %q state: %s", d.Id(), state)

				switch state {
				case "UNIT_OPERATION_STATE_SUCCEEDED":
					return nil
				case "UNIT_OPERATION_STATE_FAILED", "UNIT_OPERATION_STATE_CANCELLED":
					return fmt.Errorf("UnitOperation %q reached terminal failure state: %s", d.Id(), state)
				case "UNIT_OPERATION_STATE_UNKNOWN", "UNIT_OPERATION_STATE_PENDING", "UNIT_OPERATION_STATE_SCHEDULED", "UNIT_OPERATION_STATE_RUNNING":
					return fmt.Errorf("UnitOperation %q is still in state %s", d.Id(), state)
				default:
					return fmt.Errorf("UnitOperation %q has unexpected state: %s", d.Id(), state)
				}
			},
			ErrorRetryPredicates: []transport_tpg.RetryErrorPredicateFunc{
				func(err error) (bool, string) {
					if strings.Contains(err.Error(), "is still in state") {
						return true, "retry pending state"
					}
					if strings.Contains(err.Error(), "transient error") {
						return true, "retry transient error"
					}
					if strings.Contains(err.Error(), "did not return a state field") {
						return true, "wait for state to be populated"
					}
					return false, ""
				},
			},
		})

		if err != nil {
			return fmt.Errorf("Error waiting for UnitOperation to reach terminal state: %s", err)
		}
	}

	log.Printf("[DEBUG] Finished creating UnitOperation %q: %#v", d.Id(), res)

	return resourceSaasRuntimeUnitOperationRead(d, meta)
}

func resourceSaasRuntimeUnitOperationRead(d *schema.ResourceData, meta interface{}) error {
	config := meta.(*transport_tpg.Config)
	userAgent, err := tpgresource.GenerateUserAgentString(d, config.UserAgent)
	if err != nil {
		return err
	}

	url, err := tpgresource.ReplaceVars(d, config, "{{SaasRuntimeBasePath}}projects/{{project}}/locations/{{location}}/unitOperations/{{unit_operation_id}}")
	if err != nil {
		return err
	}

	billingProject := ""

	project, err := tpgresource.GetProject(d, config)
	if err != nil {
		return fmt.Errorf("Error fetching project for UnitOperation: %s", err)
	}
	billingProject = project

	// err == nil indicates that the billing_project value was found
	if bp, err := tpgresource.GetBillingProject(d, config); err == nil {
		billingProject = bp
	}

	headers := make(http.Header)
	res, err := transport_tpg.SendRequest(transport_tpg.SendRequestOptions{
		Config:    config,
		Method:    "GET",
		Project:   billingProject,
		RawURL:    url,
		UserAgent: userAgent,
		Headers:   headers,
	})
	if err != nil {
		return transport_tpg.HandleNotFoundError(err, d, fmt.Sprintf("SaasRuntimeUnitOperation %q", d.Id()))
	}

	// Explicitly set virtual fields to default values if unset
	if _, ok := d.GetOkExists("wait_for_completion"); !ok {
		if err := d.Set("wait_for_completion", true); err != nil {
			return fmt.Errorf("Error setting wait_for_completion: %s", err)
		}
	}
	if err := d.Set("project", project); err != nil {
		return fmt.Errorf("Error reading UnitOperation: %s", err)
	}

	if err := d.Set("annotations", flattenSaasRuntimeUnitOperationAnnotations(res["annotations"], d, config)); err != nil {
		return fmt.Errorf("Error reading UnitOperation: %s", err)
	}
	if err := d.Set("conditions", flattenSaasRuntimeUnitOperationConditions(res["conditions"], d, config)); err != nil {
		return fmt.Errorf("Error reading UnitOperation: %s", err)
	}
	if err := d.Set("create_time", flattenSaasRuntimeUnitOperationCreateTime(res["createTime"], d, config)); err != nil {
		return fmt.Errorf("Error reading UnitOperation: %s", err)
	}
	if err := d.Set("deprovision", flattenSaasRuntimeUnitOperationDeprovision(res["deprovision"], d, config)); err != nil {
		return fmt.Errorf("Error reading UnitOperation: %s", err)
	}
	if err := d.Set("engine_state", flattenSaasRuntimeUnitOperationEngineState(res["engineState"], d, config)); err != nil {
		return fmt.Errorf("Error reading UnitOperation: %s", err)
	}
	if err := d.Set("error_category", flattenSaasRuntimeUnitOperationErrorCategory(res["errorCategory"], d, config)); err != nil {
		return fmt.Errorf("Error reading UnitOperation: %s", err)
	}
	if err := d.Set("etag", flattenSaasRuntimeUnitOperationEtag(res["etag"], d, config)); err != nil {
		return fmt.Errorf("Error reading UnitOperation: %s", err)
	}
	if err := d.Set("labels", flattenSaasRuntimeUnitOperationLabels(res["labels"], d, config)); err != nil {
		return fmt.Errorf("Error reading UnitOperation: %s", err)
	}
	if err := d.Set("name", flattenSaasRuntimeUnitOperationName(res["name"], d, config)); err != nil {
		return fmt.Errorf("Error reading UnitOperation: %s", err)
	}
	if err := d.Set("provision", flattenSaasRuntimeUnitOperationProvision(res["provision"], d, config)); err != nil {
		return fmt.Errorf("Error reading UnitOperation: %s", err)
	}
	if err := d.Set("state", flattenSaasRuntimeUnitOperationState(res["state"], d, config)); err != nil {
		return fmt.Errorf("Error reading UnitOperation: %s", err)
	}
	if err := d.Set("uid", flattenSaasRuntimeUnitOperationUid(res["uid"], d, config)); err != nil {
		return fmt.Errorf("Error reading UnitOperation: %s", err)
	}
	if err := d.Set("unit", flattenSaasRuntimeUnitOperationUnit(res["unit"], d, config)); err != nil {
		return fmt.Errorf("Error reading UnitOperation: %s", err)
	}
	if err := d.Set("update_time", flattenSaasRuntimeUnitOperationUpdateTime(res["updateTime"], d, config)); err != nil {
		return fmt.Errorf("Error reading UnitOperation: %s", err)
	}
	if err := d.Set("upgrade", flattenSaasRuntimeUnitOperationUpgrade(res["upgrade"], d, config)); err != nil {
		return fmt.Errorf("Error reading UnitOperation: %s", err)
	}
	if err := d.Set("effective_annotations", flattenSaasRuntimeUnitOperationEffectiveAnnotations(res["annotations"], d, config)); err != nil {
		return fmt.Errorf("Error reading UnitOperation: %s", err)
	}
	if err := d.Set("terraform_labels", flattenSaasRuntimeUnitOperationTerraformLabels(res["labels"], d, config)); err != nil {
		return fmt.Errorf("Error reading UnitOperation: %s", err)
	}
	if err := d.Set("effective_labels", flattenSaasRuntimeUnitOperationEffectiveLabels(res["labels"], d, config)); err != nil {
		return fmt.Errorf("Error reading UnitOperation: %s", err)
	}

	return nil
}

func resourceSaasRuntimeUnitOperationUpdate(d *schema.ResourceData, meta interface{}) error {
	// Only the root field "labels", "terraform_labels", and virtual fields are mutable
	return resourceSaasRuntimeUnitOperationRead(d, meta)
}

func resourceSaasRuntimeUnitOperationDelete(d *schema.ResourceData, meta interface{}) error {
	config := meta.(*transport_tpg.Config)
	userAgent, err := tpgresource.GenerateUserAgentString(d, config.UserAgent)
	if err != nil {
		return err
	}

	billingProject := ""

	project, err := tpgresource.GetProject(d, config)
	if err != nil {
		return fmt.Errorf("Error fetching project for UnitOperation: %s", err)
	}
	billingProject = project

	url, err := tpgresource.ReplaceVars(d, config, "{{SaasRuntimeBasePath}}projects/{{project}}/locations/{{location}}/unitOperations/{{unit_operation_id}}")
	if err != nil {
		return err
	}

	var obj map[string]interface{}

	// err == nil indicates that the billing_project value was found
	if bp, err := tpgresource.GetBillingProject(d, config); err == nil {
		billingProject = bp
	}

	headers := make(http.Header)

	log.Printf("[DEBUG] Deleting UnitOperation %q", d.Id())
	res, err := transport_tpg.SendRequest(transport_tpg.SendRequestOptions{
		Config:    config,
		Method:    "DELETE",
		Project:   billingProject,
		RawURL:    url,
		UserAgent: userAgent,
		Body:      obj,
		Timeout:   d.Timeout(schema.TimeoutDelete),
		Headers:   headers,
	})
	if err != nil {
		return transport_tpg.HandleNotFoundError(err, d, "UnitOperation")
	}

	log.Printf("[DEBUG] Finished deleting UnitOperation %q: %#v", d.Id(), res)
	return nil
}

func resourceSaasRuntimeUnitOperationImport(d *schema.ResourceData, meta interface{}) ([]*schema.ResourceData, error) {
	config := meta.(*transport_tpg.Config)
	if err := tpgresource.ParseImportId([]string{
		"^projects/(?P<project>[^/]+)/locations/(?P<location>[^/]+)/unitOperations/(?P<unit_operation_id>[^/]+)$",
		"^(?P<project>[^/]+)/(?P<location>[^/]+)/(?P<unit_operation_id>[^/]+)$",
		"^(?P<location>[^/]+)/(?P<unit_operation_id>[^/]+)$",
	}, d, config); err != nil {
		return nil, err
	}

	// Replace import id for the resource id
	id, err := tpgresource.ReplaceVars(d, config, "projects/{{project}}/locations/{{location}}/unitOperations/{{unit_operation_id}}")
	if err != nil {
		return nil, fmt.Errorf("Error constructing id: %s", err)
	}
	d.SetId(id)

	// Explicitly set virtual fields to default values on import
	if err := d.Set("wait_for_completion", true); err != nil {
		return nil, fmt.Errorf("Error setting wait_for_completion: %s", err)
	}

	return []*schema.ResourceData{d}, nil
}

func flattenSaasRuntimeUnitOperationAnnotations(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return v
	}

	transformed := make(map[string]interface{})
	if l, ok := d.GetOkExists("annotations"); ok {
		for k := range l.(map[string]interface{}) {
			transformed[k] = v.(map[string]interface{})[k]
		}
	}

	return transformed
}

func flattenSaasRuntimeUnitOperationConditions(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return v
	}
	l := v.([]interface{})
	transformed := make([]interface{}, 0, len(l))
	for _, raw := range l {
		original := raw.(map[string]interface{})
		if len(original) < 1 {
			// Do not include empty json objects coming back from the api
			continue
		}
		transformed = append(transformed, map[string]interface{}{
			"last_transition_time": flattenSaasRuntimeUnitOperationConditionsLastTransitionTime(original["lastTransitionTime"], d, config),
			"message":              flattenSaasRuntimeUnitOperationConditionsMessage(original["message"], d, config),
			"reason":               flattenSaasRuntimeUnitOperationConditionsReason(original["reason"], d, config),
			"status":               flattenSaasRuntimeUnitOperationConditionsStatus(original["status"], d, config),
			"type":                 flattenSaasRuntimeUnitOperationConditionsType(original["type"], d, config),
		})
	}
	return transformed
}
func flattenSaasRuntimeUnitOperationConditionsLastTransitionTime(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenSaasRuntimeUnitOperationConditionsMessage(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenSaasRuntimeUnitOperationConditionsReason(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenSaasRuntimeUnitOperationConditionsStatus(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenSaasRuntimeUnitOperationConditionsType(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenSaasRuntimeUnitOperationCreateTime(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenSaasRuntimeUnitOperationDeprovision(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return nil
	}
	transformed := make(map[string]interface{})
	return []interface{}{transformed}
}

func flattenSaasRuntimeUnitOperationEngineState(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenSaasRuntimeUnitOperationErrorCategory(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenSaasRuntimeUnitOperationEtag(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenSaasRuntimeUnitOperationLabels(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return v
	}

	transformed := make(map[string]interface{})
	if l, ok := d.GetOkExists("labels"); ok {
		for k := range l.(map[string]interface{}) {
			transformed[k] = v.(map[string]interface{})[k]
		}
	}

	return transformed
}

func flattenSaasRuntimeUnitOperationName(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenSaasRuntimeUnitOperationProvision(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return nil
	}
	original := v.(map[string]interface{})
	if len(original) == 0 {
		return nil
	}
	transformed := make(map[string]interface{})
	transformed["input_variables"] =
		flattenSaasRuntimeUnitOperationProvisionInputVariables(original["inputVariables"], d, config)
	transformed["release"] =
		flattenSaasRuntimeUnitOperationProvisionRelease(original["release"], d, config)
	return []interface{}{transformed}
}
func flattenSaasRuntimeUnitOperationProvisionInputVariables(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return v
	}
	l := v.([]interface{})
	transformed := make([]interface{}, 0, len(l))
	for _, raw := range l {
		original := raw.(map[string]interface{})
		if len(original) < 1 {
			// Do not include empty json objects coming back from the api
			continue
		}
		transformed = append(transformed, map[string]interface{}{
			"type":     flattenSaasRuntimeUnitOperationProvisionInputVariablesType(original["type"], d, config),
			"value":    flattenSaasRuntimeUnitOperationProvisionInputVariablesValue(original["value"], d, config),
			"variable": flattenSaasRuntimeUnitOperationProvisionInputVariablesVariable(original["variable"], d, config),
		})
	}
	return transformed
}
func flattenSaasRuntimeUnitOperationProvisionInputVariablesType(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenSaasRuntimeUnitOperationProvisionInputVariablesValue(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenSaasRuntimeUnitOperationProvisionInputVariablesVariable(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenSaasRuntimeUnitOperationProvisionRelease(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenSaasRuntimeUnitOperationState(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenSaasRuntimeUnitOperationUid(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenSaasRuntimeUnitOperationUnit(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenSaasRuntimeUnitOperationUpdateTime(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenSaasRuntimeUnitOperationUpgrade(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return nil
	}
	original := v.(map[string]interface{})
	if len(original) == 0 {
		return nil
	}
	transformed := make(map[string]interface{})
	transformed["input_variables"] =
		flattenSaasRuntimeUnitOperationUpgradeInputVariables(original["inputVariables"], d, config)
	transformed["release"] =
		flattenSaasRuntimeUnitOperationUpgradeRelease(original["release"], d, config)
	return []interface{}{transformed}
}
func flattenSaasRuntimeUnitOperationUpgradeInputVariables(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return v
	}
	l := v.([]interface{})
	transformed := make([]interface{}, 0, len(l))
	for _, raw := range l {
		original := raw.(map[string]interface{})
		if len(original) < 1 {
			// Do not include empty json objects coming back from the api
			continue
		}
		transformed = append(transformed, map[string]interface{}{
			"type":     flattenSaasRuntimeUnitOperationUpgradeInputVariablesType(original["type"], d, config),
			"value":    flattenSaasRuntimeUnitOperationUpgradeInputVariablesValue(original["value"], d, config),
			"variable": flattenSaasRuntimeUnitOperationUpgradeInputVariablesVariable(original["variable"], d, config),
		})
	}
	return transformed
}
func flattenSaasRuntimeUnitOperationUpgradeInputVariablesType(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenSaasRuntimeUnitOperationUpgradeInputVariablesValue(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenSaasRuntimeUnitOperationUpgradeInputVariablesVariable(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenSaasRuntimeUnitOperationUpgradeRelease(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenSaasRuntimeUnitOperationEffectiveAnnotations(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenSaasRuntimeUnitOperationTerraformLabels(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return v
	}

	transformed := make(map[string]interface{})
	if l, ok := d.GetOkExists("terraform_labels"); ok {
		for k := range l.(map[string]interface{}) {
			transformed[k] = v.(map[string]interface{})[k]
		}
	}

	return transformed
}

func flattenSaasRuntimeUnitOperationEffectiveLabels(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func expandSaasRuntimeUnitOperationDeprovision(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	if v == nil {
		return nil, nil
	}
	l := v.([]interface{})
	if len(l) == 0 {
		return nil, nil
	}

	if l[0] == nil {
		transformed := make(map[string]interface{})
		return transformed, nil
	}
	transformed := make(map[string]interface{})

	return transformed, nil
}

func expandSaasRuntimeUnitOperationProvision(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	if v == nil {
		return nil, nil
	}
	l := v.([]interface{})
	if len(l) == 0 || l[0] == nil {
		return nil, nil
	}
	raw := l[0]
	original := raw.(map[string]interface{})
	transformed := make(map[string]interface{})

	transformedInputVariables, err := expandSaasRuntimeUnitOperationProvisionInputVariables(original["input_variables"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedInputVariables); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["inputVariables"] = transformedInputVariables
	}

	transformedRelease, err := expandSaasRuntimeUnitOperationProvisionRelease(original["release"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedRelease); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["release"] = transformedRelease
	}

	return transformed, nil
}

func expandSaasRuntimeUnitOperationProvisionInputVariables(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	if v == nil {
		return nil, nil
	}
	l := v.([]interface{})
	req := make([]interface{}, 0, len(l))
	for _, raw := range l {
		if raw == nil {
			continue
		}
		original := raw.(map[string]interface{})
		transformed := make(map[string]interface{})

		transformedType, err := expandSaasRuntimeUnitOperationProvisionInputVariablesType(original["type"], d, config)
		if err != nil {
			return nil, err
		} else if val := reflect.ValueOf(transformedType); val.IsValid() && !tpgresource.IsEmptyValue(val) {
			transformed["type"] = transformedType
		}

		transformedValue, err := expandSaasRuntimeUnitOperationProvisionInputVariablesValue(original["value"], d, config)
		if err != nil {
			return nil, err
		} else if val := reflect.ValueOf(transformedValue); val.IsValid() && !tpgresource.IsEmptyValue(val) {
			transformed["value"] = transformedValue
		}

		transformedVariable, err := expandSaasRuntimeUnitOperationProvisionInputVariablesVariable(original["variable"], d, config)
		if err != nil {
			return nil, err
		} else if val := reflect.ValueOf(transformedVariable); val.IsValid() && !tpgresource.IsEmptyValue(val) {
			transformed["variable"] = transformedVariable
		}

		req = append(req, transformed)
	}
	return req, nil
}

func expandSaasRuntimeUnitOperationProvisionInputVariablesType(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandSaasRuntimeUnitOperationProvisionInputVariablesValue(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandSaasRuntimeUnitOperationProvisionInputVariablesVariable(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandSaasRuntimeUnitOperationProvisionRelease(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandSaasRuntimeUnitOperationUnit(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandSaasRuntimeUnitOperationUpgrade(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	if v == nil {
		return nil, nil
	}
	l := v.([]interface{})
	if len(l) == 0 || l[0] == nil {
		return nil, nil
	}
	raw := l[0]
	original := raw.(map[string]interface{})
	transformed := make(map[string]interface{})

	transformedInputVariables, err := expandSaasRuntimeUnitOperationUpgradeInputVariables(original["input_variables"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedInputVariables); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["inputVariables"] = transformedInputVariables
	}

	transformedRelease, err := expandSaasRuntimeUnitOperationUpgradeRelease(original["release"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedRelease); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["release"] = transformedRelease
	}

	return transformed, nil
}

func expandSaasRuntimeUnitOperationUpgradeInputVariables(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	if v == nil {
		return nil, nil
	}
	l := v.([]interface{})
	req := make([]interface{}, 0, len(l))
	for _, raw := range l {
		if raw == nil {
			continue
		}
		original := raw.(map[string]interface{})
		transformed := make(map[string]interface{})

		transformedType, err := expandSaasRuntimeUnitOperationUpgradeInputVariablesType(original["type"], d, config)
		if err != nil {
			return nil, err
		} else if val := reflect.ValueOf(transformedType); val.IsValid() && !tpgresource.IsEmptyValue(val) {
			transformed["type"] = transformedType
		}

		transformedValue, err := expandSaasRuntimeUnitOperationUpgradeInputVariablesValue(original["value"], d, config)
		if err != nil {
			return nil, err
		} else if val := reflect.ValueOf(transformedValue); val.IsValid() && !tpgresource.IsEmptyValue(val) {
			transformed["value"] = transformedValue
		}

		transformedVariable, err := expandSaasRuntimeUnitOperationUpgradeInputVariablesVariable(original["variable"], d, config)
		if err != nil {
			return nil, err
		} else if val := reflect.ValueOf(transformedVariable); val.IsValid() && !tpgresource.IsEmptyValue(val) {
			transformed["variable"] = transformedVariable
		}

		req = append(req, transformed)
	}
	return req, nil
}

func expandSaasRuntimeUnitOperationUpgradeInputVariablesType(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandSaasRuntimeUnitOperationUpgradeInputVariablesValue(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandSaasRuntimeUnitOperationUpgradeInputVariablesVariable(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandSaasRuntimeUnitOperationUpgradeRelease(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandSaasRuntimeUnitOperationEffectiveAnnotations(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (map[string]string, error) {
	if v == nil {
		return map[string]string{}, nil
	}
	m := make(map[string]string)
	for k, val := range v.(map[string]interface{}) {
		m[k] = val.(string)
	}
	return m, nil
}

func expandSaasRuntimeUnitOperationEffectiveLabels(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (map[string]string, error) {
	if v == nil {
		return map[string]string{}, nil
	}
	m := make(map[string]string)
	for k, val := range v.(map[string]interface{}) {
		m[k] = val.(string)
	}
	return m, nil
}
