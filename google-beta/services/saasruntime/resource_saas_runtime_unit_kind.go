// Copyright (c) HashiCorp, Inc.
// SPDX-License-Identifier: MPL-2.0

// ----------------------------------------------------------------------------
//
//     ***     AUTO GENERATED CODE    ***    Type: MMv1     ***
//
// ----------------------------------------------------------------------------
//
//     This code is generated by Magic Modules using the following:
//
//     Configuration: https://github.com/GoogleCloudPlatform/magic-modules/tree/main/mmv1/products/saasservicemgmt/UnitKind.yaml
//     Template:      https://github.com/GoogleCloudPlatform/magic-modules/tree/main/mmv1/templates/terraform/resource.go.tmpl
//
//     DO NOT EDIT this file directly. Any changes made to this file will be
//     overwritten during the next generation cycle.
//
// ----------------------------------------------------------------------------

package saasruntime

import (
	"bytes"
	"context"
	"encoding/base64"
	"encoding/json"
	"fmt"
	"log"
	"net/http"
	"reflect"
	"regexp"
	"slices"
	"sort"
	"strconv"
	"strings"
	"time"

	"github.com/hashicorp/errwrap"
	"github.com/hashicorp/go-cty/cty"
	"github.com/hashicorp/terraform-plugin-sdk/v2/diag"
	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/customdiff"
	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/id"
	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/logging"
	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/retry"
	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/schema"
	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/structure"
	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/validation"
	"github.com/hashicorp/terraform-plugin-sdk/v2/terraform"

	"github.com/hashicorp/terraform-provider-google-beta/google-beta/registry"
	"github.com/hashicorp/terraform-provider-google-beta/google-beta/tpgresource"
	transport_tpg "github.com/hashicorp/terraform-provider-google-beta/google-beta/transport"
	"github.com/hashicorp/terraform-provider-google-beta/google-beta/verify"

	"google.golang.org/api/googleapi"
)

var (
	_ = bytes.Clone
	_ = context.WithCancel
	_ = base64.NewDecoder
	_ = json.Marshal
	_ = fmt.Sprintf
	_ = log.Print
	_ = http.Get
	_ = reflect.ValueOf
	_ = regexp.Match
	_ = slices.Min([]int{1})
	_ = sort.IntSlice{}
	_ = strconv.Atoi
	_ = strings.Trim
	_ = time.Now
	_ = errwrap.Wrap
	_ = cty.BoolVal
	_ = diag.Diagnostic{}
	_ = customdiff.All
	_ = id.UniqueId
	_ = logging.LogLevel
	_ = retry.Retry
	_ = schema.Noop
	_ = validation.All
	_ = structure.ExpandJsonFromString
	_ = terraform.State{}
	_ = tpgresource.SetLabels
	_ = transport_tpg.Config{}
	_ = verify.ValidateEnum
	_ = googleapi.Error{}
)

func init() {
	registry.Schema{
		Name:        "google_saas_runtime_unit_kind",
		ProductName: "saasruntime",
		Type:        registry.SchemaTypeResource,
		Schema:      ResourceSaasRuntimeUnitKind(),
	}.Register()
}

func ResourceSaasRuntimeUnitKind() *schema.Resource {
	return &schema.Resource{
		Create: resourceSaasRuntimeUnitKindCreate,
		Read:   resourceSaasRuntimeUnitKindRead,
		Update: resourceSaasRuntimeUnitKindUpdate,
		Delete: resourceSaasRuntimeUnitKindDelete,

		Importer: &schema.ResourceImporter{
			State: resourceSaasRuntimeUnitKindImport,
		},

		Timeouts: &schema.ResourceTimeout{
			Create: schema.DefaultTimeout(20 * time.Minute),
			Update: schema.DefaultTimeout(20 * time.Minute),
			Delete: schema.DefaultTimeout(20 * time.Minute),
		},

		CustomizeDiff: customdiff.All(
			tpgresource.SetAnnotationsDiff,
			tpgresource.SetLabelsDiff,
			tpgresource.DefaultProviderProject,
		),

		Schema: map[string]*schema.Schema{
			"location": {
				Type:        schema.TypeString,
				Required:    true,
				ForceNew:    true,
				Description: `Resource ID segment making up resource 'name'. It identifies the resource within its parent collection as described in https://google.aip.dev/122.`,
			},
			"saas": {
				Type:     schema.TypeString,
				Required: true,
				ForceNew: true,
				Description: `A reference to the Saas that defines the product (managed service) that
the producer wants to manage with SaaS Runtime. Part of the SaaS Runtime
common data model. Immutable once set.`,
			},
			"unit_kind_id": {
				Type:        schema.TypeString,
				Required:    true,
				ForceNew:    true,
				Description: `The ID value for the new unit kind.`,
			},
			"annotations": {
				Type:     schema.TypeMap,
				Optional: true,
				Description: `Annotations is an unstructured key-value map stored with a resource that
may be set by external tools to store and retrieve arbitrary metadata.
They are not queryable and should be preserved when modifying objects.

More info: https://kubernetes.io/docs/user-guide/annotations

**Note**: This field is non-authoritative, and will only manage the annotations present in your configuration.
Please refer to the field 'effective_annotations' for all of the annotations present on the resource.`,
				Elem: &schema.Schema{Type: schema.TypeString},
			},
			"default_release": {
				Type:     schema.TypeString,
				Optional: true,
				Description: `A reference to the Release object to use as default for creating new units
of this UnitKind.
If not specified, a new unit must explicitly reference which release to use
for its creation.`,
			},
			"dependencies": {
				Type:     schema.TypeList,
				Optional: true,
				ForceNew: true,
				Description: `List of other unit kinds that this release will depend on. Dependencies
will be automatically provisioned if not found. Maximum 10.`,
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						"alias": {
							Type:        schema.TypeString,
							Required:    true,
							Description: `An alias for the dependency. Used for input variable mapping.`,
						},
						"unit_kind": {
							Type:        schema.TypeString,
							Required:    true,
							ForceNew:    true,
							Description: `The unit kind of the dependency.`,
						},
					},
				},
			},
			"input_variable_mappings": {
				Type:     schema.TypeList,
				Optional: true,
				Description: `List of inputVariables for this release that will either be retrieved from
a dependency’s outputVariables, or will be passed on to a dependency’s
inputVariables. Maximum 100.`,
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						"variable": {
							Type:        schema.TypeString,
							Required:    true,
							Description: `name of the variable`,
						},
						"from": {
							Type:        schema.TypeList,
							Optional:    true,
							Description: `Output variables whose values will be passed on to dependencies`,
							MaxItems:    1,
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{
									"dependency": {
										Type:        schema.TypeString,
										Required:    true,
										Description: `Alias of the dependency that the outputVariable will pass its value to`,
									},
									"output_variable": {
										Type:        schema.TypeString,
										Required:    true,
										Description: `Name of the outputVariable on the dependency`,
									},
								},
							},
						},
						"to": {
							Type:        schema.TypeList,
							Optional:    true,
							Description: `Input variables whose values will be passed on to dependencies`,
							MaxItems:    1,
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{
									"dependency": {
										Type:        schema.TypeString,
										Required:    true,
										Description: `Alias of the dependency that the inputVariable will pass its value to`,
									},
									"input_variable": {
										Type:        schema.TypeString,
										Required:    true,
										Description: `Name of the inputVariable on the dependency`,
									},
									"ignore_for_lookup": {
										Type:        schema.TypeBool,
										Optional:    true,
										Description: `Tells SaaS Runtime if this mapping should be used during lookup or not`,
									},
								},
							},
						},
					},
				},
			},
			"labels": {
				Type:     schema.TypeMap,
				Optional: true,
				Description: `The labels on the resource, which can be used for categorization.
similar to Kubernetes resource labels.

**Note**: This field is non-authoritative, and will only manage the labels present in your configuration.
Please refer to the field 'effective_labels' for all of the labels present on the resource.`,
				Elem: &schema.Schema{Type: schema.TypeString},
			},
			"output_variable_mappings": {
				Type:     schema.TypeList,
				Optional: true,
				Description: `List of outputVariables for this unit kind will be passed to this unit's
outputVariables. Maximum 100.`,
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						"variable": {
							Type:        schema.TypeString,
							Required:    true,
							Description: `name of the variable`,
						},
						"from": {
							Type:        schema.TypeList,
							Optional:    true,
							Description: `Output variables whose values will be passed on to dependencies`,
							MaxItems:    1,
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{
									"dependency": {
										Type:        schema.TypeString,
										Required:    true,
										Description: `Alias of the dependency that the outputVariable will pass its value to`,
									},
									"output_variable": {
										Type:        schema.TypeString,
										Required:    true,
										Description: `Name of the outputVariable on the dependency`,
									},
								},
							},
						},
						"to": {
							Type:        schema.TypeList,
							Optional:    true,
							Description: `Input variables whose values will be passed on to dependencies`,
							MaxItems:    1,
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{
									"dependency": {
										Type:        schema.TypeString,
										Required:    true,
										Description: `Alias of the dependency that the inputVariable will pass its value to`,
									},
									"input_variable": {
										Type:        schema.TypeString,
										Required:    true,
										Description: `Name of the inputVariable on the dependency`,
									},
									"ignore_for_lookup": {
										Type:        schema.TypeBool,
										Optional:    true,
										Description: `Tells SaaS Runtime if this mapping should be used during lookup or not`,
									},
								},
							},
						},
					},
				},
			},
			"create_time": {
				Type:        schema.TypeString,
				Computed:    true,
				Description: `The timestamp when the resource was created.`,
			},
			"effective_annotations": {
				Type:        schema.TypeMap,
				Computed:    true,
				Description: `All of annotations (key/value pairs) present on the resource in GCP, including the annotations configured through Terraform, other clients and services.`,
				Elem:        &schema.Schema{Type: schema.TypeString},
			},
			"effective_labels": {
				Type:        schema.TypeMap,
				Computed:    true,
				Description: `All of labels (key/value pairs) present on the resource in GCP, including the labels configured through Terraform, other clients and services.`,
				Elem:        &schema.Schema{Type: schema.TypeString},
			},
			"etag": {
				Type:     schema.TypeString,
				Computed: true,
				Description: `An opaque value that uniquely identifies a version or
generation of a resource. It can be used to confirm that the client
and server agree on the ordering of a resource being written.`,
			},
			"name": {
				Type:     schema.TypeString,
				Computed: true,
				Description: `Identifier. The resource name (full URI of the resource) following the standard naming
scheme:

"projects/{project}/locations/{location}/unitKinds/{unitKind}"`,
			},
			"terraform_labels": {
				Type:     schema.TypeMap,
				Computed: true,
				Description: `The combination of labels configured directly on the resource
 and default labels configured on the provider.`,
				Elem: &schema.Schema{Type: schema.TypeString},
			},
			"uid": {
				Type:     schema.TypeString,
				Computed: true,
				Description: `The unique identifier of the resource. UID is unique in the time
and space for this resource within the scope of the service. It is
typically generated by the server on successful creation of a resource
and must not be changed. UID is used to uniquely identify resources
with resource name reuses. This should be a UUID4.`,
			},
			"update_time": {
				Type:     schema.TypeString,
				Computed: true,
				Description: `The timestamp when the resource was last updated. Any
change to the resource made by users must refresh this value.
Changes to a resource made by the service should refresh this value.`,
			},
			"project": {
				Type:     schema.TypeString,
				Optional: true,
				Computed: true,
				ForceNew: true,
			},
		},
		UseJSONNumber: true,
	}
}

func resourceSaasRuntimeUnitKindCreate(d *schema.ResourceData, meta interface{}) error {
	config := meta.(*transport_tpg.Config)
	userAgent, err := tpgresource.GenerateUserAgentString(d, config.UserAgent)
	if err != nil {
		return err
	}

	obj := make(map[string]interface{})
	defaultReleaseProp, err := expandSaasRuntimeUnitKindDefaultRelease(d.Get("default_release"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("default_release"); !tpgresource.IsEmptyValue(reflect.ValueOf(defaultReleaseProp)) && (ok || !reflect.DeepEqual(v, defaultReleaseProp)) {
		obj["defaultRelease"] = defaultReleaseProp
	}
	dependenciesProp, err := expandSaasRuntimeUnitKindDependencies(d.Get("dependencies"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("dependencies"); !tpgresource.IsEmptyValue(reflect.ValueOf(dependenciesProp)) && (ok || !reflect.DeepEqual(v, dependenciesProp)) {
		obj["dependencies"] = dependenciesProp
	}
	inputVariableMappingsProp, err := expandSaasRuntimeUnitKindInputVariableMappings(d.Get("input_variable_mappings"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("input_variable_mappings"); !tpgresource.IsEmptyValue(reflect.ValueOf(inputVariableMappingsProp)) && (ok || !reflect.DeepEqual(v, inputVariableMappingsProp)) {
		obj["inputVariableMappings"] = inputVariableMappingsProp
	}
	outputVariableMappingsProp, err := expandSaasRuntimeUnitKindOutputVariableMappings(d.Get("output_variable_mappings"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("output_variable_mappings"); !tpgresource.IsEmptyValue(reflect.ValueOf(outputVariableMappingsProp)) && (ok || !reflect.DeepEqual(v, outputVariableMappingsProp)) {
		obj["outputVariableMappings"] = outputVariableMappingsProp
	}
	saasProp, err := expandSaasRuntimeUnitKindSaas(d.Get("saas"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("saas"); !tpgresource.IsEmptyValue(reflect.ValueOf(saasProp)) && (ok || !reflect.DeepEqual(v, saasProp)) {
		obj["saas"] = saasProp
	}
	effectiveAnnotationsProp, err := expandSaasRuntimeUnitKindEffectiveAnnotations(d.Get("effective_annotations"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("effective_annotations"); !tpgresource.IsEmptyValue(reflect.ValueOf(effectiveAnnotationsProp)) && (ok || !reflect.DeepEqual(v, effectiveAnnotationsProp)) {
		obj["annotations"] = effectiveAnnotationsProp
	}
	effectiveLabelsProp, err := expandSaasRuntimeUnitKindEffectiveLabels(d.Get("effective_labels"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("effective_labels"); !tpgresource.IsEmptyValue(reflect.ValueOf(effectiveLabelsProp)) && (ok || !reflect.DeepEqual(v, effectiveLabelsProp)) {
		obj["labels"] = effectiveLabelsProp
	}

	url, err := tpgresource.ReplaceVars(d, config, "{{SaasRuntimeBasePath}}projects/{{project}}/locations/{{location}}/unitKinds?unitKindId={{unit_kind_id}}")
	if err != nil {
		return err
	}

	log.Printf("[DEBUG] Creating new UnitKind: %#v", obj)
	billingProject := ""

	project, err := tpgresource.GetProject(d, config)
	if err != nil {
		return fmt.Errorf("Error fetching project for UnitKind: %s", err)
	}
	billingProject = project

	// err == nil indicates that the billing_project value was found
	if bp, err := tpgresource.GetBillingProject(d, config); err == nil {
		billingProject = bp
	}

	headers := make(http.Header)
	res, err := transport_tpg.SendRequest(transport_tpg.SendRequestOptions{
		Config:    config,
		Method:    "POST",
		Project:   billingProject,
		RawURL:    url,
		UserAgent: userAgent,
		Body:      obj,
		Timeout:   d.Timeout(schema.TimeoutCreate),
		Headers:   headers,
	})
	if err != nil {
		return fmt.Errorf("Error creating UnitKind: %s", err)
	}

	// Store the ID now
	id, err := tpgresource.ReplaceVars(d, config, "projects/{{project}}/locations/{{location}}/unitKinds/{{unit_kind_id}}")
	if err != nil {
		return fmt.Errorf("Error constructing id: %s", err)
	}
	d.SetId(id)

	log.Printf("[DEBUG] Finished creating UnitKind %q: %#v", d.Id(), res)

	return resourceSaasRuntimeUnitKindRead(d, meta)
}

func resourceSaasRuntimeUnitKindRead(d *schema.ResourceData, meta interface{}) error {
	config := meta.(*transport_tpg.Config)
	userAgent, err := tpgresource.GenerateUserAgentString(d, config.UserAgent)
	if err != nil {
		return err
	}

	url, err := tpgresource.ReplaceVars(d, config, "{{SaasRuntimeBasePath}}projects/{{project}}/locations/{{location}}/unitKinds/{{unit_kind_id}}")
	if err != nil {
		return err
	}

	billingProject := ""

	project, err := tpgresource.GetProject(d, config)
	if err != nil {
		return fmt.Errorf("Error fetching project for UnitKind: %s", err)
	}
	billingProject = project

	// err == nil indicates that the billing_project value was found
	if bp, err := tpgresource.GetBillingProject(d, config); err == nil {
		billingProject = bp
	}

	headers := make(http.Header)
	res, err := transport_tpg.SendRequest(transport_tpg.SendRequestOptions{
		Config:    config,
		Method:    "GET",
		Project:   billingProject,
		RawURL:    url,
		UserAgent: userAgent,
		Headers:   headers,
	})
	if err != nil {
		return transport_tpg.HandleNotFoundError(err, d, fmt.Sprintf("SaasRuntimeUnitKind %q", d.Id()))
	}

	if err := d.Set("project", project); err != nil {
		return fmt.Errorf("Error reading UnitKind: %s", err)
	}

	if err := d.Set("annotations", flattenSaasRuntimeUnitKindAnnotations(res["annotations"], d, config)); err != nil {
		return fmt.Errorf("Error reading UnitKind: %s", err)
	}
	if err := d.Set("create_time", flattenSaasRuntimeUnitKindCreateTime(res["createTime"], d, config)); err != nil {
		return fmt.Errorf("Error reading UnitKind: %s", err)
	}
	if err := d.Set("default_release", flattenSaasRuntimeUnitKindDefaultRelease(res["defaultRelease"], d, config)); err != nil {
		return fmt.Errorf("Error reading UnitKind: %s", err)
	}
	if err := d.Set("dependencies", flattenSaasRuntimeUnitKindDependencies(res["dependencies"], d, config)); err != nil {
		return fmt.Errorf("Error reading UnitKind: %s", err)
	}
	if err := d.Set("etag", flattenSaasRuntimeUnitKindEtag(res["etag"], d, config)); err != nil {
		return fmt.Errorf("Error reading UnitKind: %s", err)
	}
	if err := d.Set("input_variable_mappings", flattenSaasRuntimeUnitKindInputVariableMappings(res["inputVariableMappings"], d, config)); err != nil {
		return fmt.Errorf("Error reading UnitKind: %s", err)
	}
	if err := d.Set("labels", flattenSaasRuntimeUnitKindLabels(res["labels"], d, config)); err != nil {
		return fmt.Errorf("Error reading UnitKind: %s", err)
	}
	if err := d.Set("name", flattenSaasRuntimeUnitKindName(res["name"], d, config)); err != nil {
		return fmt.Errorf("Error reading UnitKind: %s", err)
	}
	if err := d.Set("output_variable_mappings", flattenSaasRuntimeUnitKindOutputVariableMappings(res["outputVariableMappings"], d, config)); err != nil {
		return fmt.Errorf("Error reading UnitKind: %s", err)
	}
	if err := d.Set("saas", flattenSaasRuntimeUnitKindSaas(res["saas"], d, config)); err != nil {
		return fmt.Errorf("Error reading UnitKind: %s", err)
	}
	if err := d.Set("uid", flattenSaasRuntimeUnitKindUid(res["uid"], d, config)); err != nil {
		return fmt.Errorf("Error reading UnitKind: %s", err)
	}
	if err := d.Set("update_time", flattenSaasRuntimeUnitKindUpdateTime(res["updateTime"], d, config)); err != nil {
		return fmt.Errorf("Error reading UnitKind: %s", err)
	}
	if err := d.Set("effective_annotations", flattenSaasRuntimeUnitKindEffectiveAnnotations(res["annotations"], d, config)); err != nil {
		return fmt.Errorf("Error reading UnitKind: %s", err)
	}
	if err := d.Set("terraform_labels", flattenSaasRuntimeUnitKindTerraformLabels(res["labels"], d, config)); err != nil {
		return fmt.Errorf("Error reading UnitKind: %s", err)
	}
	if err := d.Set("effective_labels", flattenSaasRuntimeUnitKindEffectiveLabels(res["labels"], d, config)); err != nil {
		return fmt.Errorf("Error reading UnitKind: %s", err)
	}

	return nil
}

func resourceSaasRuntimeUnitKindUpdate(d *schema.ResourceData, meta interface{}) error {

	config := meta.(*transport_tpg.Config)
	userAgent, err := tpgresource.GenerateUserAgentString(d, config.UserAgent)
	if err != nil {
		return err
	}

	billingProject := ""

	project, err := tpgresource.GetProject(d, config)
	if err != nil {
		return fmt.Errorf("Error fetching project for UnitKind: %s", err)
	}
	billingProject = project

	obj := make(map[string]interface{})
	defaultReleaseProp, err := expandSaasRuntimeUnitKindDefaultRelease(d.Get("default_release"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("default_release"); !tpgresource.IsEmptyValue(reflect.ValueOf(v)) && (ok || !reflect.DeepEqual(v, defaultReleaseProp)) {
		obj["defaultRelease"] = defaultReleaseProp
	}
	inputVariableMappingsProp, err := expandSaasRuntimeUnitKindInputVariableMappings(d.Get("input_variable_mappings"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("input_variable_mappings"); !tpgresource.IsEmptyValue(reflect.ValueOf(v)) && (ok || !reflect.DeepEqual(v, inputVariableMappingsProp)) {
		obj["inputVariableMappings"] = inputVariableMappingsProp
	}
	outputVariableMappingsProp, err := expandSaasRuntimeUnitKindOutputVariableMappings(d.Get("output_variable_mappings"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("output_variable_mappings"); !tpgresource.IsEmptyValue(reflect.ValueOf(v)) && (ok || !reflect.DeepEqual(v, outputVariableMappingsProp)) {
		obj["outputVariableMappings"] = outputVariableMappingsProp
	}
	effectiveAnnotationsProp, err := expandSaasRuntimeUnitKindEffectiveAnnotations(d.Get("effective_annotations"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("effective_annotations"); !tpgresource.IsEmptyValue(reflect.ValueOf(v)) && (ok || !reflect.DeepEqual(v, effectiveAnnotationsProp)) {
		obj["annotations"] = effectiveAnnotationsProp
	}
	effectiveLabelsProp, err := expandSaasRuntimeUnitKindEffectiveLabels(d.Get("effective_labels"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("effective_labels"); !tpgresource.IsEmptyValue(reflect.ValueOf(v)) && (ok || !reflect.DeepEqual(v, effectiveLabelsProp)) {
		obj["labels"] = effectiveLabelsProp
	}

	url, err := tpgresource.ReplaceVars(d, config, "{{SaasRuntimeBasePath}}projects/{{project}}/locations/{{location}}/unitKinds/{{unit_kind_id}}")
	if err != nil {
		return err
	}

	log.Printf("[DEBUG] Updating UnitKind %q: %#v", d.Id(), obj)
	headers := make(http.Header)
	updateMask := []string{}

	if d.HasChange("default_release") {
		updateMask = append(updateMask, "defaultRelease")
	}

	if d.HasChange("input_variable_mappings") {
		updateMask = append(updateMask, "inputVariableMappings")
	}

	if d.HasChange("output_variable_mappings") {
		updateMask = append(updateMask, "outputVariableMappings")
	}

	if d.HasChange("effective_annotations") {
		updateMask = append(updateMask, "annotations")
	}

	if d.HasChange("effective_labels") {
		updateMask = append(updateMask, "labels")
	}
	// updateMask is a URL parameter but not present in the schema, so ReplaceVars
	// won't set it
	url, err = transport_tpg.AddQueryParams(url, map[string]string{"updateMask": strings.Join(updateMask, ",")})
	if err != nil {
		return err
	}

	// err == nil indicates that the billing_project value was found
	if bp, err := tpgresource.GetBillingProject(d, config); err == nil {
		billingProject = bp
	}

	// if updateMask is empty we are not updating anything so skip the post
	if len(updateMask) > 0 {
		res, err := transport_tpg.SendRequest(transport_tpg.SendRequestOptions{
			Config:    config,
			Method:    "PATCH",
			Project:   billingProject,
			RawURL:    url,
			UserAgent: userAgent,
			Body:      obj,
			Timeout:   d.Timeout(schema.TimeoutUpdate),
			Headers:   headers,
		})

		if err != nil {
			return fmt.Errorf("Error updating UnitKind %q: %s", d.Id(), err)
		} else {
			log.Printf("[DEBUG] Finished updating UnitKind %q: %#v", d.Id(), res)
		}

	}

	return resourceSaasRuntimeUnitKindRead(d, meta)
}

func resourceSaasRuntimeUnitKindDelete(d *schema.ResourceData, meta interface{}) error {
	config := meta.(*transport_tpg.Config)
	userAgent, err := tpgresource.GenerateUserAgentString(d, config.UserAgent)
	if err != nil {
		return err
	}

	billingProject := ""

	project, err := tpgresource.GetProject(d, config)
	if err != nil {
		return fmt.Errorf("Error fetching project for UnitKind: %s", err)
	}
	billingProject = project

	url, err := tpgresource.ReplaceVars(d, config, "{{SaasRuntimeBasePath}}projects/{{project}}/locations/{{location}}/unitKinds/{{unit_kind_id}}")
	if err != nil {
		return err
	}

	var obj map[string]interface{}

	// err == nil indicates that the billing_project value was found
	if bp, err := tpgresource.GetBillingProject(d, config); err == nil {
		billingProject = bp
	}

	headers := make(http.Header)

	log.Printf("[DEBUG] Deleting UnitKind %q", d.Id())
	res, err := transport_tpg.SendRequest(transport_tpg.SendRequestOptions{
		Config:    config,
		Method:    "DELETE",
		Project:   billingProject,
		RawURL:    url,
		UserAgent: userAgent,
		Body:      obj,
		Timeout:   d.Timeout(schema.TimeoutDelete),
		Headers:   headers,
	})
	if err != nil {
		return transport_tpg.HandleNotFoundError(err, d, "UnitKind")
	}

	log.Printf("[DEBUG] Finished deleting UnitKind %q: %#v", d.Id(), res)
	return nil
}

func resourceSaasRuntimeUnitKindImport(d *schema.ResourceData, meta interface{}) ([]*schema.ResourceData, error) {
	config := meta.(*transport_tpg.Config)
	if err := tpgresource.ParseImportId([]string{
		"^projects/(?P<project>[^/]+)/locations/(?P<location>[^/]+)/unitKinds/(?P<unit_kind_id>[^/]+)$",
		"^(?P<project>[^/]+)/(?P<location>[^/]+)/(?P<unit_kind_id>[^/]+)$",
		"^(?P<location>[^/]+)/(?P<unit_kind_id>[^/]+)$",
	}, d, config); err != nil {
		return nil, err
	}

	// Replace import id for the resource id
	id, err := tpgresource.ReplaceVars(d, config, "projects/{{project}}/locations/{{location}}/unitKinds/{{unit_kind_id}}")
	if err != nil {
		return nil, fmt.Errorf("Error constructing id: %s", err)
	}
	d.SetId(id)

	return []*schema.ResourceData{d}, nil
}

func flattenSaasRuntimeUnitKindAnnotations(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return v
	}

	transformed := make(map[string]interface{})
	if l, ok := d.GetOkExists("annotations"); ok {
		for k := range l.(map[string]interface{}) {
			transformed[k] = v.(map[string]interface{})[k]
		}
	}

	return transformed
}

func flattenSaasRuntimeUnitKindCreateTime(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenSaasRuntimeUnitKindDefaultRelease(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenSaasRuntimeUnitKindDependencies(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return v
	}
	l := v.([]interface{})
	transformed := make([]interface{}, 0, len(l))
	for _, raw := range l {
		original := raw.(map[string]interface{})
		if len(original) < 1 {
			// Do not include empty json objects coming back from the api
			continue
		}
		transformed = append(transformed, map[string]interface{}{
			"alias":     flattenSaasRuntimeUnitKindDependenciesAlias(original["alias"], d, config),
			"unit_kind": flattenSaasRuntimeUnitKindDependenciesUnitKind(original["unitKind"], d, config),
		})
	}
	return transformed
}
func flattenSaasRuntimeUnitKindDependenciesAlias(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenSaasRuntimeUnitKindDependenciesUnitKind(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenSaasRuntimeUnitKindEtag(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenSaasRuntimeUnitKindInputVariableMappings(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return v
	}
	l := v.([]interface{})
	transformed := make([]interface{}, 0, len(l))
	for _, raw := range l {
		original := raw.(map[string]interface{})
		if len(original) < 1 {
			// Do not include empty json objects coming back from the api
			continue
		}
		transformed = append(transformed, map[string]interface{}{
			"from":     flattenSaasRuntimeUnitKindInputVariableMappingsFrom(original["from"], d, config),
			"to":       flattenSaasRuntimeUnitKindInputVariableMappingsTo(original["to"], d, config),
			"variable": flattenSaasRuntimeUnitKindInputVariableMappingsVariable(original["variable"], d, config),
		})
	}
	return transformed
}
func flattenSaasRuntimeUnitKindInputVariableMappingsFrom(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return nil
	}
	original := v.(map[string]interface{})
	if len(original) == 0 {
		return nil
	}
	transformed := make(map[string]interface{})
	transformed["dependency"] =
		flattenSaasRuntimeUnitKindInputVariableMappingsFromDependency(original["dependency"], d, config)
	transformed["output_variable"] =
		flattenSaasRuntimeUnitKindInputVariableMappingsFromOutputVariable(original["outputVariable"], d, config)
	return []interface{}{transformed}
}
func flattenSaasRuntimeUnitKindInputVariableMappingsFromDependency(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenSaasRuntimeUnitKindInputVariableMappingsFromOutputVariable(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenSaasRuntimeUnitKindInputVariableMappingsTo(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return nil
	}
	original := v.(map[string]interface{})
	if len(original) == 0 {
		return nil
	}
	transformed := make(map[string]interface{})
	transformed["dependency"] =
		flattenSaasRuntimeUnitKindInputVariableMappingsToDependency(original["dependency"], d, config)
	transformed["ignore_for_lookup"] =
		flattenSaasRuntimeUnitKindInputVariableMappingsToIgnoreForLookup(original["ignoreForLookup"], d, config)
	transformed["input_variable"] =
		flattenSaasRuntimeUnitKindInputVariableMappingsToInputVariable(original["inputVariable"], d, config)
	return []interface{}{transformed}
}
func flattenSaasRuntimeUnitKindInputVariableMappingsToDependency(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenSaasRuntimeUnitKindInputVariableMappingsToIgnoreForLookup(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenSaasRuntimeUnitKindInputVariableMappingsToInputVariable(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenSaasRuntimeUnitKindInputVariableMappingsVariable(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenSaasRuntimeUnitKindLabels(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return v
	}

	transformed := make(map[string]interface{})
	if l, ok := d.GetOkExists("labels"); ok {
		for k := range l.(map[string]interface{}) {
			transformed[k] = v.(map[string]interface{})[k]
		}
	}

	return transformed
}

func flattenSaasRuntimeUnitKindName(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenSaasRuntimeUnitKindOutputVariableMappings(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return v
	}
	l := v.([]interface{})
	transformed := make([]interface{}, 0, len(l))
	for _, raw := range l {
		original := raw.(map[string]interface{})
		if len(original) < 1 {
			// Do not include empty json objects coming back from the api
			continue
		}
		transformed = append(transformed, map[string]interface{}{
			"from":     flattenSaasRuntimeUnitKindOutputVariableMappingsFrom(original["from"], d, config),
			"to":       flattenSaasRuntimeUnitKindOutputVariableMappingsTo(original["to"], d, config),
			"variable": flattenSaasRuntimeUnitKindOutputVariableMappingsVariable(original["variable"], d, config),
		})
	}
	return transformed
}
func flattenSaasRuntimeUnitKindOutputVariableMappingsFrom(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return nil
	}
	original := v.(map[string]interface{})
	if len(original) == 0 {
		return nil
	}
	transformed := make(map[string]interface{})
	transformed["dependency"] =
		flattenSaasRuntimeUnitKindOutputVariableMappingsFromDependency(original["dependency"], d, config)
	transformed["output_variable"] =
		flattenSaasRuntimeUnitKindOutputVariableMappingsFromOutputVariable(original["outputVariable"], d, config)
	return []interface{}{transformed}
}
func flattenSaasRuntimeUnitKindOutputVariableMappingsFromDependency(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenSaasRuntimeUnitKindOutputVariableMappingsFromOutputVariable(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenSaasRuntimeUnitKindOutputVariableMappingsTo(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return nil
	}
	original := v.(map[string]interface{})
	if len(original) == 0 {
		return nil
	}
	transformed := make(map[string]interface{})
	transformed["dependency"] =
		flattenSaasRuntimeUnitKindOutputVariableMappingsToDependency(original["dependency"], d, config)
	transformed["ignore_for_lookup"] =
		flattenSaasRuntimeUnitKindOutputVariableMappingsToIgnoreForLookup(original["ignoreForLookup"], d, config)
	transformed["input_variable"] =
		flattenSaasRuntimeUnitKindOutputVariableMappingsToInputVariable(original["inputVariable"], d, config)
	return []interface{}{transformed}
}
func flattenSaasRuntimeUnitKindOutputVariableMappingsToDependency(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenSaasRuntimeUnitKindOutputVariableMappingsToIgnoreForLookup(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenSaasRuntimeUnitKindOutputVariableMappingsToInputVariable(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenSaasRuntimeUnitKindOutputVariableMappingsVariable(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenSaasRuntimeUnitKindSaas(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenSaasRuntimeUnitKindUid(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenSaasRuntimeUnitKindUpdateTime(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenSaasRuntimeUnitKindEffectiveAnnotations(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenSaasRuntimeUnitKindTerraformLabels(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return v
	}

	transformed := make(map[string]interface{})
	if l, ok := d.GetOkExists("terraform_labels"); ok {
		for k := range l.(map[string]interface{}) {
			transformed[k] = v.(map[string]interface{})[k]
		}
	}

	return transformed
}

func flattenSaasRuntimeUnitKindEffectiveLabels(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func expandSaasRuntimeUnitKindDefaultRelease(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandSaasRuntimeUnitKindDependencies(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	if v == nil {
		return nil, nil
	}
	l := v.([]interface{})
	req := make([]interface{}, 0, len(l))
	for _, raw := range l {
		if raw == nil {
			continue
		}
		original := raw.(map[string]interface{})
		transformed := make(map[string]interface{})

		transformedAlias, err := expandSaasRuntimeUnitKindDependenciesAlias(original["alias"], d, config)
		if err != nil {
			return nil, err
		} else if val := reflect.ValueOf(transformedAlias); val.IsValid() && !tpgresource.IsEmptyValue(val) {
			transformed["alias"] = transformedAlias
		}

		transformedUnitKind, err := expandSaasRuntimeUnitKindDependenciesUnitKind(original["unit_kind"], d, config)
		if err != nil {
			return nil, err
		} else if val := reflect.ValueOf(transformedUnitKind); val.IsValid() && !tpgresource.IsEmptyValue(val) {
			transformed["unitKind"] = transformedUnitKind
		}

		req = append(req, transformed)
	}
	return req, nil
}

func expandSaasRuntimeUnitKindDependenciesAlias(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandSaasRuntimeUnitKindDependenciesUnitKind(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandSaasRuntimeUnitKindInputVariableMappings(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	if v == nil {
		return nil, nil
	}
	l := v.([]interface{})
	req := make([]interface{}, 0, len(l))
	for _, raw := range l {
		if raw == nil {
			continue
		}
		original := raw.(map[string]interface{})
		transformed := make(map[string]interface{})

		transformedFrom, err := expandSaasRuntimeUnitKindInputVariableMappingsFrom(original["from"], d, config)
		if err != nil {
			return nil, err
		} else if val := reflect.ValueOf(transformedFrom); val.IsValid() && !tpgresource.IsEmptyValue(val) {
			transformed["from"] = transformedFrom
		}

		transformedTo, err := expandSaasRuntimeUnitKindInputVariableMappingsTo(original["to"], d, config)
		if err != nil {
			return nil, err
		} else if val := reflect.ValueOf(transformedTo); val.IsValid() && !tpgresource.IsEmptyValue(val) {
			transformed["to"] = transformedTo
		}

		transformedVariable, err := expandSaasRuntimeUnitKindInputVariableMappingsVariable(original["variable"], d, config)
		if err != nil {
			return nil, err
		} else if val := reflect.ValueOf(transformedVariable); val.IsValid() && !tpgresource.IsEmptyValue(val) {
			transformed["variable"] = transformedVariable
		}

		req = append(req, transformed)
	}
	return req, nil
}

func expandSaasRuntimeUnitKindInputVariableMappingsFrom(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	if v == nil {
		return nil, nil
	}
	l := v.([]interface{})
	if len(l) == 0 || l[0] == nil {
		return nil, nil
	}
	raw := l[0]
	original := raw.(map[string]interface{})
	transformed := make(map[string]interface{})

	transformedDependency, err := expandSaasRuntimeUnitKindInputVariableMappingsFromDependency(original["dependency"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedDependency); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["dependency"] = transformedDependency
	}

	transformedOutputVariable, err := expandSaasRuntimeUnitKindInputVariableMappingsFromOutputVariable(original["output_variable"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedOutputVariable); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["outputVariable"] = transformedOutputVariable
	}

	return transformed, nil
}

func expandSaasRuntimeUnitKindInputVariableMappingsFromDependency(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandSaasRuntimeUnitKindInputVariableMappingsFromOutputVariable(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandSaasRuntimeUnitKindInputVariableMappingsTo(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	if v == nil {
		return nil, nil
	}
	l := v.([]interface{})
	if len(l) == 0 || l[0] == nil {
		return nil, nil
	}
	raw := l[0]
	original := raw.(map[string]interface{})
	transformed := make(map[string]interface{})

	transformedDependency, err := expandSaasRuntimeUnitKindInputVariableMappingsToDependency(original["dependency"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedDependency); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["dependency"] = transformedDependency
	}

	transformedIgnoreForLookup, err := expandSaasRuntimeUnitKindInputVariableMappingsToIgnoreForLookup(original["ignore_for_lookup"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedIgnoreForLookup); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["ignoreForLookup"] = transformedIgnoreForLookup
	}

	transformedInputVariable, err := expandSaasRuntimeUnitKindInputVariableMappingsToInputVariable(original["input_variable"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedInputVariable); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["inputVariable"] = transformedInputVariable
	}

	return transformed, nil
}

func expandSaasRuntimeUnitKindInputVariableMappingsToDependency(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandSaasRuntimeUnitKindInputVariableMappingsToIgnoreForLookup(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandSaasRuntimeUnitKindInputVariableMappingsToInputVariable(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandSaasRuntimeUnitKindInputVariableMappingsVariable(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandSaasRuntimeUnitKindOutputVariableMappings(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	if v == nil {
		return nil, nil
	}
	l := v.([]interface{})
	req := make([]interface{}, 0, len(l))
	for _, raw := range l {
		if raw == nil {
			continue
		}
		original := raw.(map[string]interface{})
		transformed := make(map[string]interface{})

		transformedFrom, err := expandSaasRuntimeUnitKindOutputVariableMappingsFrom(original["from"], d, config)
		if err != nil {
			return nil, err
		} else if val := reflect.ValueOf(transformedFrom); val.IsValid() && !tpgresource.IsEmptyValue(val) {
			transformed["from"] = transformedFrom
		}

		transformedTo, err := expandSaasRuntimeUnitKindOutputVariableMappingsTo(original["to"], d, config)
		if err != nil {
			return nil, err
		} else if val := reflect.ValueOf(transformedTo); val.IsValid() && !tpgresource.IsEmptyValue(val) {
			transformed["to"] = transformedTo
		}

		transformedVariable, err := expandSaasRuntimeUnitKindOutputVariableMappingsVariable(original["variable"], d, config)
		if err != nil {
			return nil, err
		} else if val := reflect.ValueOf(transformedVariable); val.IsValid() && !tpgresource.IsEmptyValue(val) {
			transformed["variable"] = transformedVariable
		}

		req = append(req, transformed)
	}
	return req, nil
}

func expandSaasRuntimeUnitKindOutputVariableMappingsFrom(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	if v == nil {
		return nil, nil
	}
	l := v.([]interface{})
	if len(l) == 0 || l[0] == nil {
		return nil, nil
	}
	raw := l[0]
	original := raw.(map[string]interface{})
	transformed := make(map[string]interface{})

	transformedDependency, err := expandSaasRuntimeUnitKindOutputVariableMappingsFromDependency(original["dependency"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedDependency); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["dependency"] = transformedDependency
	}

	transformedOutputVariable, err := expandSaasRuntimeUnitKindOutputVariableMappingsFromOutputVariable(original["output_variable"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedOutputVariable); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["outputVariable"] = transformedOutputVariable
	}

	return transformed, nil
}

func expandSaasRuntimeUnitKindOutputVariableMappingsFromDependency(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandSaasRuntimeUnitKindOutputVariableMappingsFromOutputVariable(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandSaasRuntimeUnitKindOutputVariableMappingsTo(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	if v == nil {
		return nil, nil
	}
	l := v.([]interface{})
	if len(l) == 0 || l[0] == nil {
		return nil, nil
	}
	raw := l[0]
	original := raw.(map[string]interface{})
	transformed := make(map[string]interface{})

	transformedDependency, err := expandSaasRuntimeUnitKindOutputVariableMappingsToDependency(original["dependency"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedDependency); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["dependency"] = transformedDependency
	}

	transformedIgnoreForLookup, err := expandSaasRuntimeUnitKindOutputVariableMappingsToIgnoreForLookup(original["ignore_for_lookup"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedIgnoreForLookup); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["ignoreForLookup"] = transformedIgnoreForLookup
	}

	transformedInputVariable, err := expandSaasRuntimeUnitKindOutputVariableMappingsToInputVariable(original["input_variable"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedInputVariable); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["inputVariable"] = transformedInputVariable
	}

	return transformed, nil
}

func expandSaasRuntimeUnitKindOutputVariableMappingsToDependency(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandSaasRuntimeUnitKindOutputVariableMappingsToIgnoreForLookup(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandSaasRuntimeUnitKindOutputVariableMappingsToInputVariable(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandSaasRuntimeUnitKindOutputVariableMappingsVariable(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandSaasRuntimeUnitKindSaas(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandSaasRuntimeUnitKindEffectiveAnnotations(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (map[string]string, error) {
	if v == nil {
		return map[string]string{}, nil
	}
	m := make(map[string]string)
	for k, val := range v.(map[string]interface{}) {
		m[k] = val.(string)
	}
	return m, nil
}

func expandSaasRuntimeUnitKindEffectiveLabels(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (map[string]string, error) {
	if v == nil {
		return map[string]string{}, nil
	}
	m := make(map[string]string)
	for k, val := range v.(map[string]interface{}) {
		m[k] = val.(string)
	}
	return m, nil
}
