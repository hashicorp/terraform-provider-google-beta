// Copyright (c) HashiCorp, Inc.
// SPDX-License-Identifier: MPL-2.0

// ----------------------------------------------------------------------------
//
//     ***     AUTO GENERATED CODE    ***    Type: MMv1     ***
//
// ----------------------------------------------------------------------------
//
//     This code is generated by Magic Modules using the following:
//
//     Configuration: https://github.com/GoogleCloudPlatform/magic-modules/tree/main/mmv1/products/saasservicemgmt/Unit.yaml
//     Template:      https://github.com/GoogleCloudPlatform/magic-modules/tree/main/mmv1/templates/terraform/resource.go.tmpl
//
//     DO NOT EDIT this file directly. Any changes made to this file will be
//     overwritten during the next generation cycle.
//
// ----------------------------------------------------------------------------

package saasruntime

import (
	"fmt"
	"log"
	"net/http"
	"reflect"
	"strings"
	"time"

	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/customdiff"
	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/schema"

	"github.com/hashicorp/terraform-provider-google-beta/google-beta/tpgresource"
	transport_tpg "github.com/hashicorp/terraform-provider-google-beta/google-beta/transport"
)

func ResourceSaasRuntimeUnit() *schema.Resource {
	return &schema.Resource{
		Create: resourceSaasRuntimeUnitCreate,
		Read:   resourceSaasRuntimeUnitRead,
		Update: resourceSaasRuntimeUnitUpdate,
		Delete: resourceSaasRuntimeUnitDelete,

		Importer: &schema.ResourceImporter{
			State: resourceSaasRuntimeUnitImport,
		},

		Timeouts: &schema.ResourceTimeout{
			Create: schema.DefaultTimeout(20 * time.Minute),
			Update: schema.DefaultTimeout(20 * time.Minute),
			Delete: schema.DefaultTimeout(20 * time.Minute),
		},

		CustomizeDiff: customdiff.All(
			tpgresource.SetAnnotationsDiff,
			tpgresource.SetLabelsDiff,
			tpgresource.DefaultProviderProject,
		),

		Schema: map[string]*schema.Schema{
			"location": {
				Type:        schema.TypeString,
				Required:    true,
				ForceNew:    true,
				Description: `Resource ID segment making up resource 'name'. It identifies the resource within its parent collection as described in https://google.aip.dev/122.`,
			},
			"unit_id": {
				Type:        schema.TypeString,
				Required:    true,
				ForceNew:    true,
				Description: `The ID value for the new unit.`,
			},
			"annotations": {
				Type:     schema.TypeMap,
				Optional: true,
				Description: `Annotations is an unstructured key-value map stored with a resource that
may be set by external tools to store and retrieve arbitrary metadata.
They are not queryable and should be preserved when modifying objects.

More info: https://kubernetes.io/docs/user-guide/annotations

**Note**: This field is non-authoritative, and will only manage the annotations present in your configuration.
Please refer to the field 'effective_annotations' for all of the annotations present on the resource.`,
				Elem: &schema.Schema{Type: schema.TypeString},
			},
			"labels": {
				Type:     schema.TypeMap,
				Optional: true,
				Description: `The labels on the resource, which can be used for categorization.
similar to Kubernetes resource labels.

**Note**: This field is non-authoritative, and will only manage the labels present in your configuration.
Please refer to the field 'effective_labels' for all of the labels present on the resource.`,
				Elem: &schema.Schema{Type: schema.TypeString},
			},
			"maintenance": {
				Type:     schema.TypeList,
				Optional: true,
				Description: `Captures requested directives for performing future maintenance on the
unit. This includes a request for the unit to skip maintenance for a period
of time and remain pinned to its current release as well as controls for
postponing maintenance scheduled in future.`,
				MaxItems: 1,
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						"pinned_until_time": {
							Type:     schema.TypeString,
							Optional: true,
							Description: `If present, it fixes the release on the unit until the given time; i.e.
changes to the release field will be rejected. Rollouts should and will
also respect this by not requesting an upgrade in the first place.`,
						},
					},
				},
			},
			"management_mode": {
				Type:     schema.TypeString,
				Optional: true,
				ForceNew: true,
				Description: `Indicates whether the Unit life cycle is controlled
by the user or by the system.
Immutable once created.
Possible values:
MANAGEMENT_MODE_USER
MANAGEMENT_MODE_SYSTEM`,
			},
			"tenant": {
				Type:     schema.TypeString,
				Optional: true,
				Description: `Reference to the Saas Tenant resource this unit belongs to. This for
example informs the maintenance policies to use for scheduling future
updates on a unit. (optional and immutable once created)`,
			},
			"unit_kind": {
				Type:        schema.TypeString,
				Optional:    true,
				Description: `Reference to the UnitKind this Unit belongs to. Immutable once set.`,
			},
			"conditions": {
				Type:     schema.TypeList,
				Computed: true,
				Description: `A set of conditions which indicate the various conditions this resource can
have.`,
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						"last_transition_time": {
							Type:        schema.TypeString,
							Required:    true,
							Description: `Last time the condition transited from one status to another.`,
						},
						"message": {
							Type:        schema.TypeString,
							Required:    true,
							Description: `Human readable message indicating details about the last transition.`,
						},
						"reason": {
							Type:        schema.TypeString,
							Required:    true,
							Description: `Brief reason for the condition's last transition.`,
						},
						"status": {
							Type:     schema.TypeString,
							Required: true,
							Description: `Status of the condition.
Possible values:
STATUS_UNKNOWN
STATUS_TRUE
STATUS_FALSE`,
						},
						"type": {
							Type:     schema.TypeString,
							Required: true,
							Description: `Type of the condition.
Possible values:
TYPE_READY
TYPE_UPDATING
TYPE_PROVISIONED
TYPE_OPERATION_ERROR`,
						},
					},
				},
			},
			"create_time": {
				Type:        schema.TypeString,
				Computed:    true,
				Description: `The timestamp when the resource was created.`,
			},
			"dependencies": {
				Type:        schema.TypeList,
				Computed:    true,
				Description: `Set of dependencies for this unit. Maximum 10.`,
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						"alias": {
							Type:        schema.TypeString,
							Computed:    true,
							Description: `Alias for the name of the dependency.`,
						},
						"unit": {
							Type:        schema.TypeString,
							Computed:    true,
							Description: `A reference to the Unit object.`,
						},
					},
				},
			},
			"dependents": {
				Type:     schema.TypeList,
				Computed: true,
				Description: `List of Units that depend on this unit. Unit can only be deprovisioned if
this list is empty. Maximum 1000.`,
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						"alias": {
							Type:        schema.TypeString,
							Computed:    true,
							Description: `Alias for the name of the dependency.`,
						},
						"unit": {
							Type:        schema.TypeString,
							Computed:    true,
							Description: `A reference to the Unit object.`,
						},
					},
				},
			},
			"effective_annotations": {
				Type:        schema.TypeMap,
				Computed:    true,
				Description: `All of annotations (key/value pairs) present on the resource in GCP, including the annotations configured through Terraform, other clients and services.`,
				Elem:        &schema.Schema{Type: schema.TypeString},
			},
			"effective_labels": {
				Type:        schema.TypeMap,
				Computed:    true,
				Description: `All of labels (key/value pairs) present on the resource in GCP, including the labels configured through Terraform, other clients and services.`,
				Elem:        &schema.Schema{Type: schema.TypeString},
			},
			"input_variables": {
				Type:        schema.TypeList,
				Computed:    true,
				Description: `Indicates the current input variables deployed by the unit`,
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						"variable": {
							Type:        schema.TypeString,
							Required:    true,
							ForceNew:    true,
							Description: `Name of the variable from actuation configs.`,
						},
						"type": {
							Type:     schema.TypeString,
							Optional: true,
							ForceNew: true,
							Description: `Name of a supported variable type. Supported types are string, int, bool.
Possible values:
STRING
INT
BOOL`,
						},
						"value": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: `String encoded value for the variable.`,
						},
					},
				},
			},
			"name": {
				Type:     schema.TypeString,
				Computed: true,
				Description: `Identifier. The resource name (full URI of the resource) following the standard naming
scheme:

"projects/{project}/locations/{location}/units/{unit}"`,
			},
			"ongoing_operations": {
				Type:        schema.TypeList,
				Computed:    true,
				Description: `List of concurrent UnitOperations that are operating on this Unit.`,
				Elem: &schema.Schema{
					Type: schema.TypeString,
				},
			},
			"output_variables": {
				Type:     schema.TypeList,
				Computed: true,
				Description: `Set of key/value pairs corresponding to output variables from execution of
actuation templates. The variables are declared in actuation configs (e.g
in helm chart or terraform) and the values are fetched and returned by the
actuation engine upon completion of execution.`,
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						"variable": {
							Type:        schema.TypeString,
							Required:    true,
							ForceNew:    true,
							Description: `Name of the variable from actuation configs.`,
						},
						"type": {
							Type:     schema.TypeString,
							Optional: true,
							ForceNew: true,
							Description: `Name of a supported variable type. Supported types are string, int, bool.
Possible values:
STRING
INT
BOOL`,
						},
						"value": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: `String encoded value for the variable.`,
						},
					},
				},
			},
			"pending_operations": {
				Type:        schema.TypeList,
				Computed:    true,
				Description: `List of pending (wait to be executed) UnitOperations for this unit.`,
				Elem: &schema.Schema{
					Type: schema.TypeString,
				},
			},
			"release": {
				Type:        schema.TypeString,
				Computed:    true,
				Description: `The current Release object for this Unit.`,
			},
			"scheduled_operations": {
				Type:        schema.TypeList,
				Computed:    true,
				Description: `List of scheduled UnitOperations for this unit.`,
				Elem: &schema.Schema{
					Type: schema.TypeString,
				},
			},
			"state": {
				Type:     schema.TypeString,
				Computed: true,
				Description: `Current lifecycle state of the resource (e.g. if it's being
created or ready to use).
Possible values:
UNIT_STATE_NOT_PROVISIONED
UNIT_STATE_PROVISIONING
UNIT_STATE_UPDATING
UNIT_STATE_DEPROVISIONING
UNIT_STATE_READY
UNIT_STATE_ERROR`,
			},
			"system_cleanup_at": {
				Type:        schema.TypeString,
				Computed:    true,
				Description: `If set, indicates the time when the system will start removing the unit.`,
			},
			"system_managed_state": {
				Type:     schema.TypeString,
				Computed: true,
				Description: `Indicates the system managed state of the unit.
Possible values:
SYSTEM_MANAGED_STATE_ACTIVE
SYSTEM_MANAGED_STATE_INACTIVE
SYSTEM_MANAGED_STATE_DECOMMISSIONED`,
			},
			"terraform_labels": {
				Type:     schema.TypeMap,
				Computed: true,
				Description: `The combination of labels configured directly on the resource
 and default labels configured on the provider.`,
				Elem: &schema.Schema{Type: schema.TypeString},
			},
			"uid": {
				Type:     schema.TypeString,
				Computed: true,
				Description: `The unique identifier of the resource. UID is unique in the time
and space for this resource within the scope of the service. It is
typically generated by the server on successful creation of a resource
and must not be changed. UID is used to uniquely identify resources
with resource name reuses. This should be a UUID4.`,
			},
			"update_time": {
				Type:     schema.TypeString,
				Computed: true,
				Description: `The timestamp when the resource was last updated. Any
change to the resource made by users must refresh this value.
Changes to a resource made by the service should refresh this value.`,
			},
			"project": {
				Type:     schema.TypeString,
				Optional: true,
				Computed: true,
				ForceNew: true,
			},
		},
		UseJSONNumber: true,
	}
}

func resourceSaasRuntimeUnitCreate(d *schema.ResourceData, meta interface{}) error {
	config := meta.(*transport_tpg.Config)
	userAgent, err := tpgresource.GenerateUserAgentString(d, config.UserAgent)
	if err != nil {
		return err
	}

	obj := make(map[string]interface{})
	maintenanceProp, err := expandSaasRuntimeUnitMaintenance(d.Get("maintenance"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("maintenance"); !tpgresource.IsEmptyValue(reflect.ValueOf(maintenanceProp)) && (ok || !reflect.DeepEqual(v, maintenanceProp)) {
		obj["maintenance"] = maintenanceProp
	}
	managementModeProp, err := expandSaasRuntimeUnitManagementMode(d.Get("management_mode"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("management_mode"); !tpgresource.IsEmptyValue(reflect.ValueOf(managementModeProp)) && (ok || !reflect.DeepEqual(v, managementModeProp)) {
		obj["managementMode"] = managementModeProp
	}
	tenantProp, err := expandSaasRuntimeUnitTenant(d.Get("tenant"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("tenant"); !tpgresource.IsEmptyValue(reflect.ValueOf(tenantProp)) && (ok || !reflect.DeepEqual(v, tenantProp)) {
		obj["tenant"] = tenantProp
	}
	unitKindProp, err := expandSaasRuntimeUnitUnitKind(d.Get("unit_kind"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("unit_kind"); !tpgresource.IsEmptyValue(reflect.ValueOf(unitKindProp)) && (ok || !reflect.DeepEqual(v, unitKindProp)) {
		obj["unitKind"] = unitKindProp
	}
	effectiveAnnotationsProp, err := expandSaasRuntimeUnitEffectiveAnnotations(d.Get("effective_annotations"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("effective_annotations"); !tpgresource.IsEmptyValue(reflect.ValueOf(effectiveAnnotationsProp)) && (ok || !reflect.DeepEqual(v, effectiveAnnotationsProp)) {
		obj["annotations"] = effectiveAnnotationsProp
	}
	effectiveLabelsProp, err := expandSaasRuntimeUnitEffectiveLabels(d.Get("effective_labels"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("effective_labels"); !tpgresource.IsEmptyValue(reflect.ValueOf(effectiveLabelsProp)) && (ok || !reflect.DeepEqual(v, effectiveLabelsProp)) {
		obj["labels"] = effectiveLabelsProp
	}

	url, err := tpgresource.ReplaceVars(d, config, "{{SaasRuntimeBasePath}}projects/{{project}}/locations/{{location}}/units?unitId={{unit_id}}")
	if err != nil {
		return err
	}

	log.Printf("[DEBUG] Creating new Unit: %#v", obj)
	billingProject := ""

	project, err := tpgresource.GetProject(d, config)
	if err != nil {
		return fmt.Errorf("Error fetching project for Unit: %s", err)
	}
	billingProject = project

	// err == nil indicates that the billing_project value was found
	if bp, err := tpgresource.GetBillingProject(d, config); err == nil {
		billingProject = bp
	}

	headers := make(http.Header)
	res, err := transport_tpg.SendRequest(transport_tpg.SendRequestOptions{
		Config:    config,
		Method:    "POST",
		Project:   billingProject,
		RawURL:    url,
		UserAgent: userAgent,
		Body:      obj,
		Timeout:   d.Timeout(schema.TimeoutCreate),
		Headers:   headers,
	})
	if err != nil {
		return fmt.Errorf("Error creating Unit: %s", err)
	}

	// Store the ID now
	id, err := tpgresource.ReplaceVars(d, config, "projects/{{project}}/locations/{{location}}/units/{{unit_id}}")
	if err != nil {
		return fmt.Errorf("Error constructing id: %s", err)
	}
	d.SetId(id)

	log.Printf("[DEBUG] Finished creating Unit %q: %#v", d.Id(), res)

	return resourceSaasRuntimeUnitRead(d, meta)
}

func resourceSaasRuntimeUnitRead(d *schema.ResourceData, meta interface{}) error {
	config := meta.(*transport_tpg.Config)
	userAgent, err := tpgresource.GenerateUserAgentString(d, config.UserAgent)
	if err != nil {
		return err
	}

	url, err := tpgresource.ReplaceVars(d, config, "{{SaasRuntimeBasePath}}projects/{{project}}/locations/{{location}}/units/{{unit_id}}")
	if err != nil {
		return err
	}

	billingProject := ""

	project, err := tpgresource.GetProject(d, config)
	if err != nil {
		return fmt.Errorf("Error fetching project for Unit: %s", err)
	}
	billingProject = project

	// err == nil indicates that the billing_project value was found
	if bp, err := tpgresource.GetBillingProject(d, config); err == nil {
		billingProject = bp
	}

	headers := make(http.Header)
	res, err := transport_tpg.SendRequest(transport_tpg.SendRequestOptions{
		Config:    config,
		Method:    "GET",
		Project:   billingProject,
		RawURL:    url,
		UserAgent: userAgent,
		Headers:   headers,
	})
	if err != nil {
		return transport_tpg.HandleNotFoundError(err, d, fmt.Sprintf("SaasRuntimeUnit %q", d.Id()))
	}

	if err := d.Set("project", project); err != nil {
		return fmt.Errorf("Error reading Unit: %s", err)
	}

	if err := d.Set("annotations", flattenSaasRuntimeUnitAnnotations(res["annotations"], d, config)); err != nil {
		return fmt.Errorf("Error reading Unit: %s", err)
	}
	if err := d.Set("conditions", flattenSaasRuntimeUnitConditions(res["conditions"], d, config)); err != nil {
		return fmt.Errorf("Error reading Unit: %s", err)
	}
	if err := d.Set("create_time", flattenSaasRuntimeUnitCreateTime(res["createTime"], d, config)); err != nil {
		return fmt.Errorf("Error reading Unit: %s", err)
	}
	if err := d.Set("dependencies", flattenSaasRuntimeUnitDependencies(res["dependencies"], d, config)); err != nil {
		return fmt.Errorf("Error reading Unit: %s", err)
	}
	if err := d.Set("dependents", flattenSaasRuntimeUnitDependents(res["dependents"], d, config)); err != nil {
		return fmt.Errorf("Error reading Unit: %s", err)
	}
	if err := d.Set("input_variables", flattenSaasRuntimeUnitInputVariables(res["inputVariables"], d, config)); err != nil {
		return fmt.Errorf("Error reading Unit: %s", err)
	}
	if err := d.Set("labels", flattenSaasRuntimeUnitLabels(res["labels"], d, config)); err != nil {
		return fmt.Errorf("Error reading Unit: %s", err)
	}
	if err := d.Set("maintenance", flattenSaasRuntimeUnitMaintenance(res["maintenance"], d, config)); err != nil {
		return fmt.Errorf("Error reading Unit: %s", err)
	}
	if err := d.Set("management_mode", flattenSaasRuntimeUnitManagementMode(res["managementMode"], d, config)); err != nil {
		return fmt.Errorf("Error reading Unit: %s", err)
	}
	if err := d.Set("name", flattenSaasRuntimeUnitName(res["name"], d, config)); err != nil {
		return fmt.Errorf("Error reading Unit: %s", err)
	}
	if err := d.Set("ongoing_operations", flattenSaasRuntimeUnitOngoingOperations(res["ongoingOperations"], d, config)); err != nil {
		return fmt.Errorf("Error reading Unit: %s", err)
	}
	if err := d.Set("output_variables", flattenSaasRuntimeUnitOutputVariables(res["outputVariables"], d, config)); err != nil {
		return fmt.Errorf("Error reading Unit: %s", err)
	}
	if err := d.Set("pending_operations", flattenSaasRuntimeUnitPendingOperations(res["pendingOperations"], d, config)); err != nil {
		return fmt.Errorf("Error reading Unit: %s", err)
	}
	if err := d.Set("release", flattenSaasRuntimeUnitRelease(res["release"], d, config)); err != nil {
		return fmt.Errorf("Error reading Unit: %s", err)
	}
	if err := d.Set("scheduled_operations", flattenSaasRuntimeUnitScheduledOperations(res["scheduledOperations"], d, config)); err != nil {
		return fmt.Errorf("Error reading Unit: %s", err)
	}
	if err := d.Set("state", flattenSaasRuntimeUnitState(res["state"], d, config)); err != nil {
		return fmt.Errorf("Error reading Unit: %s", err)
	}
	if err := d.Set("system_cleanup_at", flattenSaasRuntimeUnitSystemCleanupAt(res["systemCleanupAt"], d, config)); err != nil {
		return fmt.Errorf("Error reading Unit: %s", err)
	}
	if err := d.Set("system_managed_state", flattenSaasRuntimeUnitSystemManagedState(res["systemManagedState"], d, config)); err != nil {
		return fmt.Errorf("Error reading Unit: %s", err)
	}
	if err := d.Set("tenant", flattenSaasRuntimeUnitTenant(res["tenant"], d, config)); err != nil {
		return fmt.Errorf("Error reading Unit: %s", err)
	}
	if err := d.Set("uid", flattenSaasRuntimeUnitUid(res["uid"], d, config)); err != nil {
		return fmt.Errorf("Error reading Unit: %s", err)
	}
	if err := d.Set("unit_kind", flattenSaasRuntimeUnitUnitKind(res["unitKind"], d, config)); err != nil {
		return fmt.Errorf("Error reading Unit: %s", err)
	}
	if err := d.Set("update_time", flattenSaasRuntimeUnitUpdateTime(res["updateTime"], d, config)); err != nil {
		return fmt.Errorf("Error reading Unit: %s", err)
	}
	if err := d.Set("effective_annotations", flattenSaasRuntimeUnitEffectiveAnnotations(res["annotations"], d, config)); err != nil {
		return fmt.Errorf("Error reading Unit: %s", err)
	}
	if err := d.Set("terraform_labels", flattenSaasRuntimeUnitTerraformLabels(res["labels"], d, config)); err != nil {
		return fmt.Errorf("Error reading Unit: %s", err)
	}
	if err := d.Set("effective_labels", flattenSaasRuntimeUnitEffectiveLabels(res["labels"], d, config)); err != nil {
		return fmt.Errorf("Error reading Unit: %s", err)
	}

	return nil
}

func resourceSaasRuntimeUnitUpdate(d *schema.ResourceData, meta interface{}) error {
	config := meta.(*transport_tpg.Config)
	userAgent, err := tpgresource.GenerateUserAgentString(d, config.UserAgent)
	if err != nil {
		return err
	}

	billingProject := ""

	project, err := tpgresource.GetProject(d, config)
	if err != nil {
		return fmt.Errorf("Error fetching project for Unit: %s", err)
	}
	billingProject = project

	obj := make(map[string]interface{})
	maintenanceProp, err := expandSaasRuntimeUnitMaintenance(d.Get("maintenance"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("maintenance"); !tpgresource.IsEmptyValue(reflect.ValueOf(v)) && (ok || !reflect.DeepEqual(v, maintenanceProp)) {
		obj["maintenance"] = maintenanceProp
	}
	tenantProp, err := expandSaasRuntimeUnitTenant(d.Get("tenant"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("tenant"); !tpgresource.IsEmptyValue(reflect.ValueOf(v)) && (ok || !reflect.DeepEqual(v, tenantProp)) {
		obj["tenant"] = tenantProp
	}
	unitKindProp, err := expandSaasRuntimeUnitUnitKind(d.Get("unit_kind"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("unit_kind"); !tpgresource.IsEmptyValue(reflect.ValueOf(v)) && (ok || !reflect.DeepEqual(v, unitKindProp)) {
		obj["unitKind"] = unitKindProp
	}
	effectiveAnnotationsProp, err := expandSaasRuntimeUnitEffectiveAnnotations(d.Get("effective_annotations"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("effective_annotations"); !tpgresource.IsEmptyValue(reflect.ValueOf(v)) && (ok || !reflect.DeepEqual(v, effectiveAnnotationsProp)) {
		obj["annotations"] = effectiveAnnotationsProp
	}
	effectiveLabelsProp, err := expandSaasRuntimeUnitEffectiveLabels(d.Get("effective_labels"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("effective_labels"); !tpgresource.IsEmptyValue(reflect.ValueOf(v)) && (ok || !reflect.DeepEqual(v, effectiveLabelsProp)) {
		obj["labels"] = effectiveLabelsProp
	}

	url, err := tpgresource.ReplaceVars(d, config, "{{SaasRuntimeBasePath}}projects/{{project}}/locations/{{location}}/units/{{unit_id}}")
	if err != nil {
		return err
	}

	log.Printf("[DEBUG] Updating Unit %q: %#v", d.Id(), obj)
	headers := make(http.Header)
	updateMask := []string{}

	if d.HasChange("maintenance") {
		updateMask = append(updateMask, "maintenance")
	}

	if d.HasChange("tenant") {
		updateMask = append(updateMask, "tenant")
	}

	if d.HasChange("unit_kind") {
		updateMask = append(updateMask, "unitKind")
	}

	if d.HasChange("effective_annotations") {
		updateMask = append(updateMask, "annotations")
	}

	if d.HasChange("effective_labels") {
		updateMask = append(updateMask, "labels")
	}
	// updateMask is a URL parameter but not present in the schema, so ReplaceVars
	// won't set it
	url, err = transport_tpg.AddQueryParams(url, map[string]string{"updateMask": strings.Join(updateMask, ",")})
	if err != nil {
		return err
	}

	// err == nil indicates that the billing_project value was found
	if bp, err := tpgresource.GetBillingProject(d, config); err == nil {
		billingProject = bp
	}

	// if updateMask is empty we are not updating anything so skip the post
	if len(updateMask) > 0 {
		res, err := transport_tpg.SendRequest(transport_tpg.SendRequestOptions{
			Config:    config,
			Method:    "PATCH",
			Project:   billingProject,
			RawURL:    url,
			UserAgent: userAgent,
			Body:      obj,
			Timeout:   d.Timeout(schema.TimeoutUpdate),
			Headers:   headers,
		})

		if err != nil {
			return fmt.Errorf("Error updating Unit %q: %s", d.Id(), err)
		} else {
			log.Printf("[DEBUG] Finished updating Unit %q: %#v", d.Id(), res)
		}

	}

	return resourceSaasRuntimeUnitRead(d, meta)
}

func resourceSaasRuntimeUnitDelete(d *schema.ResourceData, meta interface{}) error {
	config := meta.(*transport_tpg.Config)
	userAgent, err := tpgresource.GenerateUserAgentString(d, config.UserAgent)
	if err != nil {
		return err
	}

	billingProject := ""

	project, err := tpgresource.GetProject(d, config)
	if err != nil {
		return fmt.Errorf("Error fetching project for Unit: %s", err)
	}
	billingProject = project

	url, err := tpgresource.ReplaceVars(d, config, "{{SaasRuntimeBasePath}}projects/{{project}}/locations/{{location}}/units/{{unit_id}}")
	if err != nil {
		return err
	}

	var obj map[string]interface{}

	// err == nil indicates that the billing_project value was found
	if bp, err := tpgresource.GetBillingProject(d, config); err == nil {
		billingProject = bp
	}

	headers := make(http.Header)

	log.Printf("[DEBUG] Deleting Unit %q", d.Id())
	res, err := transport_tpg.SendRequest(transport_tpg.SendRequestOptions{
		Config:    config,
		Method:    "DELETE",
		Project:   billingProject,
		RawURL:    url,
		UserAgent: userAgent,
		Body:      obj,
		Timeout:   d.Timeout(schema.TimeoutDelete),
		Headers:   headers,
	})
	if err != nil {
		return transport_tpg.HandleNotFoundError(err, d, "Unit")
	}

	log.Printf("[DEBUG] Finished deleting Unit %q: %#v", d.Id(), res)
	return nil
}

func resourceSaasRuntimeUnitImport(d *schema.ResourceData, meta interface{}) ([]*schema.ResourceData, error) {
	config := meta.(*transport_tpg.Config)
	if err := tpgresource.ParseImportId([]string{
		"^projects/(?P<project>[^/]+)/locations/(?P<location>[^/]+)/units/(?P<unit_id>[^/]+)$",
		"^(?P<project>[^/]+)/(?P<location>[^/]+)/(?P<unit_id>[^/]+)$",
		"^(?P<location>[^/]+)/(?P<unit_id>[^/]+)$",
	}, d, config); err != nil {
		return nil, err
	}

	// Replace import id for the resource id
	id, err := tpgresource.ReplaceVars(d, config, "projects/{{project}}/locations/{{location}}/units/{{unit_id}}")
	if err != nil {
		return nil, fmt.Errorf("Error constructing id: %s", err)
	}
	d.SetId(id)

	return []*schema.ResourceData{d}, nil
}

func flattenSaasRuntimeUnitAnnotations(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return v
	}

	transformed := make(map[string]interface{})
	if l, ok := d.GetOkExists("annotations"); ok {
		for k := range l.(map[string]interface{}) {
			transformed[k] = v.(map[string]interface{})[k]
		}
	}

	return transformed
}

func flattenSaasRuntimeUnitConditions(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return v
	}
	l := v.([]interface{})
	transformed := make([]interface{}, 0, len(l))
	for _, raw := range l {
		original := raw.(map[string]interface{})
		if len(original) < 1 {
			// Do not include empty json objects coming back from the api
			continue
		}
		transformed = append(transformed, map[string]interface{}{
			"last_transition_time": flattenSaasRuntimeUnitConditionsLastTransitionTime(original["lastTransitionTime"], d, config),
			"message":              flattenSaasRuntimeUnitConditionsMessage(original["message"], d, config),
			"reason":               flattenSaasRuntimeUnitConditionsReason(original["reason"], d, config),
			"status":               flattenSaasRuntimeUnitConditionsStatus(original["status"], d, config),
			"type":                 flattenSaasRuntimeUnitConditionsType(original["type"], d, config),
		})
	}
	return transformed
}
func flattenSaasRuntimeUnitConditionsLastTransitionTime(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenSaasRuntimeUnitConditionsMessage(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenSaasRuntimeUnitConditionsReason(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenSaasRuntimeUnitConditionsStatus(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenSaasRuntimeUnitConditionsType(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenSaasRuntimeUnitCreateTime(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenSaasRuntimeUnitDependencies(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return v
	}
	l := v.([]interface{})
	transformed := make([]interface{}, 0, len(l))
	for _, raw := range l {
		original := raw.(map[string]interface{})
		if len(original) < 1 {
			// Do not include empty json objects coming back from the api
			continue
		}
		transformed = append(transformed, map[string]interface{}{
			"alias": flattenSaasRuntimeUnitDependenciesAlias(original["alias"], d, config),
			"unit":  flattenSaasRuntimeUnitDependenciesUnit(original["unit"], d, config),
		})
	}
	return transformed
}
func flattenSaasRuntimeUnitDependenciesAlias(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenSaasRuntimeUnitDependenciesUnit(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenSaasRuntimeUnitDependents(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return v
	}
	l := v.([]interface{})
	transformed := make([]interface{}, 0, len(l))
	for _, raw := range l {
		original := raw.(map[string]interface{})
		if len(original) < 1 {
			// Do not include empty json objects coming back from the api
			continue
		}
		transformed = append(transformed, map[string]interface{}{
			"alias": flattenSaasRuntimeUnitDependentsAlias(original["alias"], d, config),
			"unit":  flattenSaasRuntimeUnitDependentsUnit(original["unit"], d, config),
		})
	}
	return transformed
}
func flattenSaasRuntimeUnitDependentsAlias(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenSaasRuntimeUnitDependentsUnit(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenSaasRuntimeUnitInputVariables(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return v
	}
	l := v.([]interface{})
	transformed := make([]interface{}, 0, len(l))
	for _, raw := range l {
		original := raw.(map[string]interface{})
		if len(original) < 1 {
			// Do not include empty json objects coming back from the api
			continue
		}
		transformed = append(transformed, map[string]interface{}{
			"type":     flattenSaasRuntimeUnitInputVariablesType(original["type"], d, config),
			"value":    flattenSaasRuntimeUnitInputVariablesValue(original["value"], d, config),
			"variable": flattenSaasRuntimeUnitInputVariablesVariable(original["variable"], d, config),
		})
	}
	return transformed
}
func flattenSaasRuntimeUnitInputVariablesType(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenSaasRuntimeUnitInputVariablesValue(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenSaasRuntimeUnitInputVariablesVariable(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenSaasRuntimeUnitLabels(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return v
	}

	transformed := make(map[string]interface{})
	if l, ok := d.GetOkExists("labels"); ok {
		for k := range l.(map[string]interface{}) {
			transformed[k] = v.(map[string]interface{})[k]
		}
	}

	return transformed
}

func flattenSaasRuntimeUnitMaintenance(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return nil
	}
	original := v.(map[string]interface{})
	if len(original) == 0 {
		return nil
	}
	transformed := make(map[string]interface{})
	transformed["pinned_until_time"] =
		flattenSaasRuntimeUnitMaintenancePinnedUntilTime(original["pinnedUntilTime"], d, config)
	return []interface{}{transformed}
}
func flattenSaasRuntimeUnitMaintenancePinnedUntilTime(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenSaasRuntimeUnitManagementMode(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenSaasRuntimeUnitName(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenSaasRuntimeUnitOngoingOperations(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenSaasRuntimeUnitOutputVariables(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return v
	}
	l := v.([]interface{})
	transformed := make([]interface{}, 0, len(l))
	for _, raw := range l {
		original := raw.(map[string]interface{})
		if len(original) < 1 {
			// Do not include empty json objects coming back from the api
			continue
		}
		transformed = append(transformed, map[string]interface{}{
			"type":     flattenSaasRuntimeUnitOutputVariablesType(original["type"], d, config),
			"value":    flattenSaasRuntimeUnitOutputVariablesValue(original["value"], d, config),
			"variable": flattenSaasRuntimeUnitOutputVariablesVariable(original["variable"], d, config),
		})
	}
	return transformed
}
func flattenSaasRuntimeUnitOutputVariablesType(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenSaasRuntimeUnitOutputVariablesValue(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenSaasRuntimeUnitOutputVariablesVariable(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenSaasRuntimeUnitPendingOperations(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenSaasRuntimeUnitRelease(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenSaasRuntimeUnitScheduledOperations(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenSaasRuntimeUnitState(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenSaasRuntimeUnitSystemCleanupAt(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenSaasRuntimeUnitSystemManagedState(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenSaasRuntimeUnitTenant(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenSaasRuntimeUnitUid(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenSaasRuntimeUnitUnitKind(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenSaasRuntimeUnitUpdateTime(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenSaasRuntimeUnitEffectiveAnnotations(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenSaasRuntimeUnitTerraformLabels(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return v
	}

	transformed := make(map[string]interface{})
	if l, ok := d.GetOkExists("terraform_labels"); ok {
		for k := range l.(map[string]interface{}) {
			transformed[k] = v.(map[string]interface{})[k]
		}
	}

	return transformed
}

func flattenSaasRuntimeUnitEffectiveLabels(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func expandSaasRuntimeUnitMaintenance(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	if v == nil {
		return nil, nil
	}
	l := v.([]interface{})
	if len(l) == 0 || l[0] == nil {
		return nil, nil
	}
	raw := l[0]
	original := raw.(map[string]interface{})
	transformed := make(map[string]interface{})

	transformedPinnedUntilTime, err := expandSaasRuntimeUnitMaintenancePinnedUntilTime(original["pinned_until_time"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedPinnedUntilTime); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["pinnedUntilTime"] = transformedPinnedUntilTime
	}

	return transformed, nil
}

func expandSaasRuntimeUnitMaintenancePinnedUntilTime(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandSaasRuntimeUnitManagementMode(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandSaasRuntimeUnitTenant(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandSaasRuntimeUnitUnitKind(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandSaasRuntimeUnitEffectiveAnnotations(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (map[string]string, error) {
	if v == nil {
		return map[string]string{}, nil
	}
	m := make(map[string]string)
	for k, val := range v.(map[string]interface{}) {
		m[k] = val.(string)
	}
	return m, nil
}

func expandSaasRuntimeUnitEffectiveLabels(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (map[string]string, error) {
	if v == nil {
		return map[string]string{}, nil
	}
	m := make(map[string]string)
	for k, val := range v.(map[string]interface{}) {
		m[k] = val.(string)
	}
	return m, nil
}
