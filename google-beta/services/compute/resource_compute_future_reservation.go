// Copyright (c) HashiCorp, Inc.
// SPDX-License-Identifier: MPL-2.0

// ----------------------------------------------------------------------------
//
//     ***     AUTO GENERATED CODE    ***    Type: MMv1     ***
//
// ----------------------------------------------------------------------------
//
//     This code is generated by Magic Modules using the following:
//
//     Configuration: https://github.com/GoogleCloudPlatform/magic-modules/tree/main/mmv1/products/compute/FutureReservation.yaml
//     Template:      https://github.com/GoogleCloudPlatform/magic-modules/tree/main/mmv1/templates/terraform/resource.go.tmpl
//
//     DO NOT EDIT this file directly. Any changes made to this file will be
//     overwritten during the next generation cycle.
//
// ----------------------------------------------------------------------------

package compute

import (
	"fmt"
	"log"
	"net/http"
	"reflect"
	"strings"
	"time"

	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/customdiff"
	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/schema"

	"github.com/hashicorp/terraform-provider-google-beta/google-beta/tpgresource"
	transport_tpg "github.com/hashicorp/terraform-provider-google-beta/google-beta/transport"
	"github.com/hashicorp/terraform-provider-google-beta/google-beta/verify"
)

func ResourceComputeFutureReservation() *schema.Resource {
	return &schema.Resource{
		Create: resourceComputeFutureReservationCreate,
		Read:   resourceComputeFutureReservationRead,
		Update: resourceComputeFutureReservationUpdate,
		Delete: resourceComputeFutureReservationDelete,

		Importer: &schema.ResourceImporter{
			State: resourceComputeFutureReservationImport,
		},

		Timeouts: &schema.ResourceTimeout{
			Create: schema.DefaultTimeout(20 * time.Minute),
			Update: schema.DefaultTimeout(20 * time.Minute),
			Delete: schema.DefaultTimeout(20 * time.Minute),
		},

		CustomizeDiff: customdiff.All(
			tpgresource.DefaultProviderProject,
		),

		Schema: map[string]*schema.Schema{
			"name": {
				Type:     schema.TypeString,
				Required: true,
				ForceNew: true,
				Description: `Name of the resource. Provided by the client when the resource is
created. The name must be 1-63 characters long, and comply with
RFC1035. Specifically, the name must be 1-63 characters long and match
the regular expression '[a-z]([-a-z0-9]*[a-z0-9])?' which means the
first character must be a lowercase letter, and all following
characters must be a dash, lowercase letter, or digit, except the las
character, which cannot be a dash.`,
			},
			"time_window": {
				Type:        schema.TypeList,
				Required:    true,
				Description: `Time window for this Future Reservation.`,
				MaxItems:    1,
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						"start_time": {
							Type:        schema.TypeString,
							Required:    true,
							Description: `Start time of the future reservation in RFC3339 format.`,
						},
						"duration": {
							Type:        schema.TypeList,
							Optional:    true,
							Description: `Duration of the future reservation`,
							MaxItems:    1,
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{
									"nanos": {
										Type:        schema.TypeInt,
										Optional:    true,
										Description: `Span of time that's a fraction of a second at nanosecond resolution.`,
									},
									"seconds": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: `Span of time at a resolution of a second. Must be from 0 to 315,576,000,000 inclusive.`,
									},
								},
							},
						},
						"end_time": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: `End time of the future reservation in RFC3339 format.`,
						},
					},
				},
			},
			"auto_created_reservations_delete_time": {
				Type:        schema.TypeString,
				Optional:    true,
				Description: `Future timestamp when the FR auto-created reservations will be deleted by Compute Engine.`,
			},
			"auto_created_reservations_duration": {
				Type:        schema.TypeList,
				Optional:    true,
				Description: `Specifies the duration of auto-created reservations. It represents relative time to future reservation startTime when auto-created reservations will be automatically deleted by Compute Engine. Duration time unit is represented as a count of seconds and fractions of seconds at nanosecond resolution.`,
				MaxItems:    1,
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						"nanos": {
							Type:        schema.TypeInt,
							Optional:    true,
							Description: `Span of time that's a fraction of a second at nanosecond resolution. Durations less than one second are represented with a 0 seconds field and a positive nanos field. Must be from 0 to 999,999,999 inclusive.`,
						},
						"seconds": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: `Span of time at a resolution of a second. Must be from 0 to 315,576,000,000 inclusive.`,
						},
					},
				},
			},
			"auto_delete_auto_created_reservations": {
				Type:        schema.TypeBool,
				Optional:    true,
				Description: `Setting for enabling or disabling automatic deletion for auto-created reservation. If set to true, auto-created reservations will be deleted at Future Reservation's end time (default) or at user's defined timestamp if any of the [autoCreatedReservationsDeleteTime, autoCreatedReservationsDuration] values is specified. For keeping auto-created reservation indefinitely, this value should be set to false.`,
			},
			"commitment_info": {
				Type:        schema.TypeList,
				Optional:    true,
				Description: `If not present, then FR will not deliver a new commitment or update an existing commitment.`,
				MaxItems:    1,
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						"commitment_name": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: `name of the commitment where capacity is being delivered to.`,
						},
						"commitment_plan": {
							Type:         schema.TypeString,
							Optional:     true,
							ValidateFunc: verify.ValidateEnum([]string{"INVALID", "THIRTY_SIX_MONTH", "TWELVE_MONTH", ""}),
							Description:  `Indicates if a Commitment needs to be created as part of FR delivery. If this field is not present, then no commitment needs to be created. Possible values: ["INVALID", "THIRTY_SIX_MONTH", "TWELVE_MONTH"]`,
						},
						"previous_commitment_terms": {
							Type:         schema.TypeString,
							Optional:     true,
							ValidateFunc: verify.ValidateEnum([]string{"EXTEND", ""}),
							Description:  `Only applicable if FR is delivering to the same reservation. If set, all parent commitments will be extended to match the end date of the plan for this commitment. Possible values: ["EXTEND"]`,
						},
					},
				},
			},
			"deployment_type": {
				Type:         schema.TypeString,
				Optional:     true,
				ValidateFunc: verify.ValidateEnum([]string{"DENSE", "FLEXIBLE", ""}),
				Description:  `Type of the deployment requested as part of future reservation. Possible values: ["DENSE", "FLEXIBLE"]`,
			},
			"description": {
				Type:        schema.TypeString,
				Optional:    true,
				Description: `An optional description of this resource.`,
			},
			"name_prefix": {
				Type:        schema.TypeString,
				Optional:    true,
				Description: `Name prefix for the reservations to be created at the time of delivery. The name prefix must comply with RFC1035. Maximum allowed length for name prefix is 20. Automatically created reservations name format will be -date-####.`,
			},
			"planning_status": {
				Type:         schema.TypeString,
				Computed:     true,
				Optional:     true,
				ValidateFunc: verify.ValidateEnum([]string{"DRAFT", "SUBMITTED", ""}),
				Description:  `Planning state before being submitted for evaluation Possible values: ["DRAFT", "SUBMITTED"]`,
			},
			"reservation_mode": {
				Type:         schema.TypeString,
				Optional:     true,
				ValidateFunc: verify.ValidateEnum([]string{"CALENDAR", "DEFAULT", ""}),
				Description:  `The reservation mode which determines reservation-termination behavior and expected pricing. Possible values: ["CALENDAR", "DEFAULT"]`,
			},
			"reservation_name": {
				Type:        schema.TypeString,
				Optional:    true,
				Description: `Name of reservations where the capacity is provisioned at the time of delivery of future reservations. If the reservation with the given name does not exist already, it is created automatically at the time of Approval with INACTIVE state till specified start-time. Either provide the reservationName or a namePrefix.`,
			},
			"scheduling_type": {
				Type:         schema.TypeString,
				Optional:     true,
				ValidateFunc: verify.ValidateEnum([]string{"GROUPED", "INDEPENDENT", ""}),
				Description:  `Maintenance information for this reservation Possible values: ["GROUPED", "INDEPENDENT"]`,
			},
			"share_settings": {
				Type:        schema.TypeList,
				Optional:    true,
				Description: `Settings for sharing the future reservation`,
				MaxItems:    1,
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						"project_map": {
							Type:        schema.TypeSet,
							Optional:    true,
							Description: `A map of project id and project config. This is only valid when shareType's value is SPECIFIC_PROJECTS.`,
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{
									"id": {
										Type:     schema.TypeString,
										Required: true,
									},
									"project_id": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: `The project ID, should be same as the key of this project config in the parent map.`,
									},
								},
							},
						},
						"projects": {
							Type:        schema.TypeList,
							Optional:    true,
							Description: `list of Project names to specify consumer projects for this shared-reservation. This is only valid when shareType's value is SPECIFIC_PROJECTS.`,
							Elem: &schema.Schema{
								Type: schema.TypeString,
							},
						},
						"share_type": {
							Type:         schema.TypeString,
							Computed:     true,
							Optional:     true,
							ForceNew:     true,
							ValidateFunc: verify.ValidateEnum([]string{"LOCAL", "SPECIFIC_PROJECTS", ""}),
							Description:  `Type of sharing for this future reservation. Possible values: ["LOCAL", "SPECIFIC_PROJECTS"]`,
						},
					},
				},
			},
			"specific_reservation_required": {
				Type:        schema.TypeBool,
				Optional:    true,
				Description: `Indicates whether the auto-created reservation can be consumed by VMs with affinity for "any" reservation. If the field is set, then only VMs that target the reservation by name can consume from the delivered reservation.`,
			},
			"specific_sku_properties": {
				Type:        schema.TypeList,
				Optional:    true,
				Description: `Future Reservation configuration to indicate instance properties and total count.`,
				MaxItems:    1,
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						"instance_properties": {
							Type:        schema.TypeList,
							Optional:    true,
							Description: `Properties of the SKU instances being reserved.`,
							MaxItems:    1,
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{
									"guest_accelerators": {
										Type:        schema.TypeList,
										Optional:    true,
										Description: `Specifies accelerator type and count.`,
										Elem: &schema.Resource{
											Schema: map[string]*schema.Schema{
												"accelerator_count": {
													Type:        schema.TypeInt,
													Optional:    true,
													Description: `The number of the guest accelerator cards exposed to this instance.`,
												},
												"accelerator_type": {
													Type:        schema.TypeString,
													Optional:    true,
													Description: `Full or partial URL of the accelerator type resource to attach to this instance.`,
												},
											},
										},
									},
									"local_ssds": {
										Type:        schema.TypeList,
										Optional:    true,
										Description: `Specifies amount of local ssd to reserve with each instance. The type of disk is local-ssd.`,
										Elem: &schema.Resource{
											Schema: map[string]*schema.Schema{
												"disk_size_gb": {
													Type:        schema.TypeString,
													Optional:    true,
													Description: `Specifies the size of the disk in base-2 GB.`,
												},
												"interface": {
													Type:         schema.TypeString,
													Optional:     true,
													ValidateFunc: verify.ValidateEnum([]string{"SCSI", "NVME", ""}),
													Description:  `Specifies the disk interface to use for attaching this disk, which is either SCSI or NVME. The default is SCSI. Possible values: ["SCSI", "NVME"]`,
												},
											},
										},
									},
									"location_hint": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: `An opaque location hint used to place the allocation close to other resources. This field is for use by internal tools that use the public API.`,
									},
									"machine_type": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: `Specifies type of machine (name only) which has fixed number of vCPUs and fixed amount of memory. This also includes specifying custom machine type following custom-NUMBER_OF_CPUS-AMOUNT_OF_MEMORY pattern.`,
									},
									"maintenance_freeze_duration_hours": {
										Type:        schema.TypeInt,
										Optional:    true,
										Description: `Specifies the number of hours after reservation creation where instances using the reservation won't be scheduled for maintenance.`,
									},
									"maintenance_interval": {
										Type:         schema.TypeString,
										Optional:     true,
										ValidateFunc: verify.ValidateEnum([]string{"PERIODIC", ""}),
										Description:  `Specifies the frequency of planned maintenance events. The accepted values are: PERIODIC Possible values: ["PERIODIC"]`,
									},
									"min_cpu_platform": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: `Minimum cpu platform the reservation.`,
									},
								},
							},
						},
						"source_instance_template": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: `The instance template that will be used to populate the ReservedInstanceProperties of the future reservation`,
						},
						"total_count": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: `Total number of instances for which capacity assurance is requested at a future time period.`,
						},
					},
				},
			},
			"creation_timestamp": {
				Type:        schema.TypeString,
				Computed:    true,
				Description: `The creation timestamp for this future reservation in RFC3339 text format.`,
			},
			"self_link_with_id": {
				Type:        schema.TypeString,
				Computed:    true,
				Description: `Server-defined URL for this resource with the resource id.`,
			},
			"status": {
				Type:        schema.TypeList,
				Computed:    true,
				Description: `[Output only] Status of the Future Reservation`,
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						"amendment_status": {
							Type:         schema.TypeString,
							Optional:     true,
							ValidateFunc: verify.ValidateEnum([]string{""}),
							Description:  `The current status of the requested amendment. Possible values: []`,
						},
						"auto_created_reservations": {
							Type:        schema.TypeList,
							Optional:    true,
							Description: `Fully qualified urls of the automatically created reservations at startTime.`,
							Elem: &schema.Schema{
								Type: schema.TypeString,
							},
						},
						"fulfilled_count": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: `This count indicates the fulfilled capacity so far. This is set during "PROVISIONING" state. This count also includes capacity delivered as part of existing matching reservations.`,
						},
						"last_known_good_state": {
							Type:        schema.TypeList,
							Optional:    true,
							Description: `This field represents the future reservation before an amendment was requested. If the amendment is declined, the Future Reservation will be reverted to the last known good state. The last known good state is not set when updating a future reservation whose Procurement Status is DRAFTING.`,
							MaxItems:    1,
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{
									"description": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: `The description of the FutureReservation before an amendment was requested.`,
									},
									"existing_matching_usage_info": {
										Type:        schema.TypeList,
										Optional:    true,
										Description: `Represents the matching usage for the future reservation before an amendment was requested.`,
										MaxItems:    1,
										Elem: &schema.Resource{
											Schema: map[string]*schema.Schema{
												"count": {
													Type:        schema.TypeString,
													Optional:    true,
													Description: `Count representing minimum(FR totalCount, matching_reserved_capacity+matching_unreserved_instances).`,
												},
												"time_stamp": {
													Type:        schema.TypeString,
													Optional:    true,
													Description: `Timestamp when the matching usage was calculated.`,
												},
											},
										},
									},
									"future_reservation_specs": {
										Type:        schema.TypeList,
										Optional:    true,
										Description: `The previous instance-related properties of the Future Reservation.`,
										MaxItems:    1,
										Elem: &schema.Resource{
											Schema: map[string]*schema.Schema{
												"share_settings": {
													Type:        schema.TypeList,
													Optional:    true,
													Description: `The previous share settings of the Future Reservation.`,
													MaxItems:    1,
													Elem: &schema.Resource{
														Schema: map[string]*schema.Schema{
															"project_map": {
																Type:        schema.TypeSet,
																Optional:    true,
																Description: `A map of project id and project config. This is only valid when shareType's value is SPECIFIC_PROJECTS.`,
																Elem: &schema.Resource{
																	Schema: map[string]*schema.Schema{
																		"project": {
																			Type:     schema.TypeString,
																			Required: true,
																		},
																		"project_id": {
																			Type:        schema.TypeString,
																			Optional:    true,
																			Description: `The project ID, should be same as the key of this project config in the parent map.`,
																		},
																	},
																},
															},
															"projects": {
																Type:        schema.TypeList,
																Optional:    true,
																Description: `A futureReservations.list of Project names to specify consumer projects for this shared-reservation. This is only valid when shareType's value is SPECIFIC_PROJECTS.`,
																Elem: &schema.Schema{
																	Type: schema.TypeString,
																},
															},
															"share_type": {
																Type:         schema.TypeString,
																Optional:     true,
																ValidateFunc: verify.ValidateEnum([]string{"LOCAL", "ORGANIZATION", "SPECIFIC_PROJECTS", ""}),
																Description:  `Type of sharing for this shared-reservation Possible values: ["LOCAL", "ORGANIZATION", "SPECIFIC_PROJECTS"]`,
															},
														},
													},
												},
												"specific_sku_properties": {
													Type:        schema.TypeList,
													Optional:    true,
													Description: `The previous instance related properties of the Future Reservation.`,
													MaxItems:    1,
													Elem: &schema.Resource{
														Schema: map[string]*schema.Schema{
															"instance_properties": {
																Type:        schema.TypeList,
																Optional:    true,
																Description: `Properties of the SKU instances being reserved.`,
																MaxItems:    1,
																Elem: &schema.Resource{
																	Schema: map[string]*schema.Schema{
																		"guest_accelerators": {
																			Type:        schema.TypeList,
																			Optional:    true,
																			Description: `Specifies accelerator type and count.`,
																			Elem: &schema.Resource{
																				Schema: map[string]*schema.Schema{
																					"accelerator_count": {
																						Type:        schema.TypeInt,
																						Optional:    true,
																						Description: `The number of the guest accelerator cards exposed to this instance.`,
																					},
																					"accelerator_type": {
																						Type:        schema.TypeString,
																						Optional:    true,
																						Description: `Full or partial URL of the accelerator type resource to attach to this instance.`,
																					},
																				},
																			},
																		},
																		"local_ssds": {
																			Type:        schema.TypeList,
																			Optional:    true,
																			Description: `Specifies amount of local ssd to reserve with each instance. The type of disk is local-ssd.`,
																			Elem: &schema.Resource{
																				Schema: map[string]*schema.Schema{
																					"disk_size_gb": {
																						Type:        schema.TypeString,
																						Optional:    true,
																						Description: `Specifies the size of the disk in base-2 GB.`,
																					},
																					"interface": {
																						Type:         schema.TypeString,
																						Optional:     true,
																						ValidateFunc: verify.ValidateEnum([]string{"SCSI", "NVME", ""}),
																						Description:  `Specifies the disk interface to use for attaching this disk, which is either SCSI or NVME. The default is SCSI. Possible values: ["SCSI", "NVME"]`,
																					},
																				},
																			},
																		},
																		"location_hint": {
																			Type:        schema.TypeString,
																			Optional:    true,
																			Description: `An opaque location hint used to place the allocation close to other resources. This field is for use by internal tools that use the public API.`,
																		},
																		"machine_type": {
																			Type:        schema.TypeString,
																			Optional:    true,
																			Description: `Specifies type of machine (name only) which has fixed number of vCPUs and fixed amount of memory. This also includes specifying custom machine type following custom-NUMBER_OF_CPUS-AMOUNT_OF_MEMORY pattern.`,
																		},
																		"maintenance_freeze_duration_hours": {
																			Type:        schema.TypeInt,
																			Optional:    true,
																			Description: `Specifies the number of hours after reservation creation where instances using the reservation won't be scheduled for maintenance.`,
																		},
																		"maintenance_interval": {
																			Type:         schema.TypeString,
																			Optional:     true,
																			ValidateFunc: verify.ValidateEnum([]string{"PERIODIC", ""}),
																			Description:  `Specifies the frequency of planned maintenance events. The accepted values are: PERIODIC. Possible values: ["PERIODIC"]`,
																		},
																		"min_cpu_platform": {
																			Type:        schema.TypeString,
																			Optional:    true,
																			Description: `Minimum CPU platform for the reservation.`,
																		},
																	},
																},
															},
															"source_instance_template": {
																Type:        schema.TypeString,
																Optional:    true,
																Description: `The instance template that will be used to populate the ReservedInstanceProperties of the future reservation`,
															},
															"total_count": {
																Type:        schema.TypeString,
																Optional:    true,
																Description: `Total number of instances for which capacity assurance is requested at a future time period.`,
															},
														},
													},
												},
												"time_window": {
													Type:        schema.TypeList,
													Optional:    true,
													Description: `[Output Only] The previous time window of the Future Reservation.`,
													MaxItems:    1,
													Elem: &schema.Resource{
														Schema: map[string]*schema.Schema{
															"duration": {
																Type:        schema.TypeList,
																Optional:    true,
																Description: `Specifies the duration of the reservation.`,
																MaxItems:    1,
																Elem: &schema.Resource{
																	Schema: map[string]*schema.Schema{
																		"nanos": {
																			Type:        schema.TypeInt,
																			Optional:    true,
																			Description: `Span of time that's a fraction of a second at nanosecond resolution. Durations less than one second are represented with a 0 seconds field and a positive nanos field. Must be from 0 to 999,999,999 inclusive.`,
																		},
																		"seconds": {
																			Type:        schema.TypeString,
																			Optional:    true,
																			Description: `Span of time at a resolution of a second. Must be from 0 to 315,576,000,000 inclusive.`,
																		},
																	},
																},
															},
															"end_time": {
																Type:        schema.TypeString,
																Optional:    true,
																Description: `End time of the Future Reservation in RFC3339 format.`,
															},
															"start_time": {
																Type:        schema.TypeString,
																Optional:    true,
																Description: `Start time of the Future Reservation. The startTime is an RFC3339 string.`,
															},
														},
													},
												},
											},
										},
									},
									"lock_time": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: `The lock time of the FutureReservation before an amendment was requested.`,
									},
									"name_prefix": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: `The name prefix of the Future Reservation before an amendment was requested.`,
									},
									"procurement_status": {
										Type:         schema.TypeString,
										Optional:     true,
										ValidateFunc: verify.ValidateEnum([]string{""}),
										Description:  `The status of the last known good state for the Future Reservation Possible values: []`,
									},
								},
							},
						},
						"lock_time": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: `Time when Future Reservation would become LOCKED, after which no modifications to Future Reservation will be allowed. Applicable only after the Future Reservation is in the APPROVED state. The lockTime is an RFC3339 string. The procurementStatus will transition to PROCURING state at this time.`,
						},
						"procurement_status": {
							Type:         schema.TypeString,
							Optional:     true,
							ValidateFunc: verify.ValidateEnum([]string{"APPROVED", "CANCELLED", "COMMITTED", "DECLINED", "DRAFTING", "FAILED", "FAILED_PARTIALLY_FULFILLED", "FULFILLED", "PENDING_AMENDMENT_APPROVAL", "PENDING_APPROVAL", "PROCURING", "PROVISIONING", ""}),
							Description:  `Current state of this Future Reservation Possible values: ["APPROVED", "CANCELLED", "COMMITTED", "DECLINED", "DRAFTING", "FAILED", "FAILED_PARTIALLY_FULFILLED", "FULFILLED", "PENDING_AMENDMENT_APPROVAL", "PENDING_APPROVAL", "PROCURING", "PROVISIONING"]`,
						},
						"specific_sku_properties": {
							Type:        schema.TypeList,
							Optional:    true,
							Description: `Instance properties related to the Future Reservation.`,
							MaxItems:    1,
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{
									"source_instance_template_id": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: `ID of the instance template used to populate the Future Reservation properties.`,
									},
								},
							},
						},
					},
				},
			},
			"zone": {
				Type:        schema.TypeString,
				Computed:    true,
				Description: `URL of the Zone where this future reservation resides.`,
			},
			"project": {
				Type:     schema.TypeString,
				Optional: true,
				Computed: true,
				ForceNew: true,
			},
			"self_link": {
				Type:     schema.TypeString,
				Computed: true,
			},
		},
		UseJSONNumber: true,
	}
}

func resourceComputeFutureReservationCreate(d *schema.ResourceData, meta interface{}) error {
	config := meta.(*transport_tpg.Config)
	userAgent, err := tpgresource.GenerateUserAgentString(d, config.UserAgent)
	if err != nil {
		return err
	}

	obj := make(map[string]interface{})
	descriptionProp, err := expandComputeFutureReservationDescription(d.Get("description"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("description"); !tpgresource.IsEmptyValue(reflect.ValueOf(descriptionProp)) && (ok || !reflect.DeepEqual(v, descriptionProp)) {
		obj["description"] = descriptionProp
	}
	timeWindowProp, err := expandComputeFutureReservationTimeWindow(d.Get("time_window"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("time_window"); !tpgresource.IsEmptyValue(reflect.ValueOf(timeWindowProp)) && (ok || !reflect.DeepEqual(v, timeWindowProp)) {
		obj["timeWindow"] = timeWindowProp
	}
	shareSettingsProp, err := expandComputeFutureReservationShareSettings(d.Get("share_settings"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("share_settings"); !tpgresource.IsEmptyValue(reflect.ValueOf(shareSettingsProp)) && (ok || !reflect.DeepEqual(v, shareSettingsProp)) {
		obj["shareSettings"] = shareSettingsProp
	}
	namePrefixProp, err := expandComputeFutureReservationNamePrefix(d.Get("name_prefix"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("name_prefix"); !tpgresource.IsEmptyValue(reflect.ValueOf(namePrefixProp)) && (ok || !reflect.DeepEqual(v, namePrefixProp)) {
		obj["namePrefix"] = namePrefixProp
	}
	planningStatusProp, err := expandComputeFutureReservationPlanningStatus(d.Get("planning_status"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("planning_status"); !tpgresource.IsEmptyValue(reflect.ValueOf(planningStatusProp)) && (ok || !reflect.DeepEqual(v, planningStatusProp)) {
		obj["planningStatus"] = planningStatusProp
	}
	autoDeleteAutoCreatedReservationsProp, err := expandComputeFutureReservationAutoDeleteAutoCreatedReservations(d.Get("auto_delete_auto_created_reservations"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("auto_delete_auto_created_reservations"); !tpgresource.IsEmptyValue(reflect.ValueOf(autoDeleteAutoCreatedReservationsProp)) && (ok || !reflect.DeepEqual(v, autoDeleteAutoCreatedReservationsProp)) {
		obj["autoDeleteAutoCreatedReservations"] = autoDeleteAutoCreatedReservationsProp
	}
	specificReservationRequiredProp, err := expandComputeFutureReservationSpecificReservationRequired(d.Get("specific_reservation_required"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("specific_reservation_required"); !tpgresource.IsEmptyValue(reflect.ValueOf(specificReservationRequiredProp)) && (ok || !reflect.DeepEqual(v, specificReservationRequiredProp)) {
		obj["specificReservationRequired"] = specificReservationRequiredProp
	}
	reservationNameProp, err := expandComputeFutureReservationReservationName(d.Get("reservation_name"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("reservation_name"); !tpgresource.IsEmptyValue(reflect.ValueOf(reservationNameProp)) && (ok || !reflect.DeepEqual(v, reservationNameProp)) {
		obj["reservationName"] = reservationNameProp
	}
	deploymentTypeProp, err := expandComputeFutureReservationDeploymentType(d.Get("deployment_type"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("deployment_type"); !tpgresource.IsEmptyValue(reflect.ValueOf(deploymentTypeProp)) && (ok || !reflect.DeepEqual(v, deploymentTypeProp)) {
		obj["deploymentType"] = deploymentTypeProp
	}
	reservationModeProp, err := expandComputeFutureReservationReservationMode(d.Get("reservation_mode"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("reservation_mode"); !tpgresource.IsEmptyValue(reflect.ValueOf(reservationModeProp)) && (ok || !reflect.DeepEqual(v, reservationModeProp)) {
		obj["reservationMode"] = reservationModeProp
	}
	commitmentInfoProp, err := expandComputeFutureReservationCommitmentInfo(d.Get("commitment_info"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("commitment_info"); !tpgresource.IsEmptyValue(reflect.ValueOf(commitmentInfoProp)) && (ok || !reflect.DeepEqual(v, commitmentInfoProp)) {
		obj["commitmentInfo"] = commitmentInfoProp
	}
	schedulingTypeProp, err := expandComputeFutureReservationSchedulingType(d.Get("scheduling_type"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("scheduling_type"); !tpgresource.IsEmptyValue(reflect.ValueOf(schedulingTypeProp)) && (ok || !reflect.DeepEqual(v, schedulingTypeProp)) {
		obj["schedulingType"] = schedulingTypeProp
	}
	specificSkuPropertiesProp, err := expandComputeFutureReservationSpecificSkuProperties(d.Get("specific_sku_properties"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("specific_sku_properties"); !tpgresource.IsEmptyValue(reflect.ValueOf(specificSkuPropertiesProp)) && (ok || !reflect.DeepEqual(v, specificSkuPropertiesProp)) {
		obj["specificSkuProperties"] = specificSkuPropertiesProp
	}
	autoCreatedReservationsDeleteTimeProp, err := expandComputeFutureReservationAutoCreatedReservationsDeleteTime(d.Get("auto_created_reservations_delete_time"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("auto_created_reservations_delete_time"); !tpgresource.IsEmptyValue(reflect.ValueOf(autoCreatedReservationsDeleteTimeProp)) && (ok || !reflect.DeepEqual(v, autoCreatedReservationsDeleteTimeProp)) {
		obj["autoCreatedReservationsDeleteTime"] = autoCreatedReservationsDeleteTimeProp
	}
	autoCreatedReservationsDurationProp, err := expandComputeFutureReservationAutoCreatedReservationsDuration(d.Get("auto_created_reservations_duration"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("auto_created_reservations_duration"); !tpgresource.IsEmptyValue(reflect.ValueOf(autoCreatedReservationsDurationProp)) && (ok || !reflect.DeepEqual(v, autoCreatedReservationsDurationProp)) {
		obj["autoCreatedReservationsDuration"] = autoCreatedReservationsDurationProp
	}
	nameProp, err := expandComputeFutureReservationName(d.Get("name"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("name"); !tpgresource.IsEmptyValue(reflect.ValueOf(nameProp)) && (ok || !reflect.DeepEqual(v, nameProp)) {
		obj["name"] = nameProp
	}

	url, err := tpgresource.ReplaceVars(d, config, "{{ComputeBasePath}}projects/{{project}}/zones/{{zone}}/futureReservations")
	if err != nil {
		return err
	}

	log.Printf("[DEBUG] Creating new FutureReservation: %#v", obj)
	billingProject := ""

	project, err := tpgresource.GetProject(d, config)
	if err != nil {
		return fmt.Errorf("Error fetching project for FutureReservation: %s", err)
	}
	billingProject = project

	// err == nil indicates that the billing_project value was found
	if bp, err := tpgresource.GetBillingProject(d, config); err == nil {
		billingProject = bp
	}

	headers := make(http.Header)
	res, err := transport_tpg.SendRequest(transport_tpg.SendRequestOptions{
		Config:    config,
		Method:    "POST",
		Project:   billingProject,
		RawURL:    url,
		UserAgent: userAgent,
		Body:      obj,
		Timeout:   d.Timeout(schema.TimeoutCreate),
		Headers:   headers,
	})
	if err != nil {
		return fmt.Errorf("Error creating FutureReservation: %s", err)
	}

	// Store the ID now
	id, err := tpgresource.ReplaceVars(d, config, "projects/{{project}}/zones/{{zone}}/futureReservations/{{name}}")
	if err != nil {
		return fmt.Errorf("Error constructing id: %s", err)
	}
	d.SetId(id)

	err = ComputeOperationWaitTime(
		config, res, project, "Creating FutureReservation", userAgent,
		d.Timeout(schema.TimeoutCreate))

	if err != nil {
		// The resource didn't actually create
		d.SetId("")
		return fmt.Errorf("Error waiting to create FutureReservation: %s", err)
	}

	log.Printf("[DEBUG] Finished creating FutureReservation %q: %#v", d.Id(), res)

	return resourceComputeFutureReservationRead(d, meta)
}

func resourceComputeFutureReservationRead(d *schema.ResourceData, meta interface{}) error {
	config := meta.(*transport_tpg.Config)
	userAgent, err := tpgresource.GenerateUserAgentString(d, config.UserAgent)
	if err != nil {
		return err
	}

	url, err := tpgresource.ReplaceVars(d, config, "{{ComputeBasePath}}projects/{{project}}/zones/{{zone}}/futureReservations/{{name}}")
	if err != nil {
		return err
	}

	billingProject := ""

	project, err := tpgresource.GetProject(d, config)
	if err != nil {
		return fmt.Errorf("Error fetching project for FutureReservation: %s", err)
	}
	billingProject = project

	// err == nil indicates that the billing_project value was found
	if bp, err := tpgresource.GetBillingProject(d, config); err == nil {
		billingProject = bp
	}

	headers := make(http.Header)
	res, err := transport_tpg.SendRequest(transport_tpg.SendRequestOptions{
		Config:    config,
		Method:    "GET",
		Project:   billingProject,
		RawURL:    url,
		UserAgent: userAgent,
		Headers:   headers,
	})
	if err != nil {
		return transport_tpg.HandleNotFoundError(err, d, fmt.Sprintf("ComputeFutureReservation %q", d.Id()))
	}

	if err := d.Set("project", project); err != nil {
		return fmt.Errorf("Error reading FutureReservation: %s", err)
	}

	if err := d.Set("zone", flattenComputeFutureReservationZone(res["zone"], d, config)); err != nil {
		return fmt.Errorf("Error reading FutureReservation: %s", err)
	}
	if err := d.Set("creation_timestamp", flattenComputeFutureReservationCreationTimestamp(res["creationTimestamp"], d, config)); err != nil {
		return fmt.Errorf("Error reading FutureReservation: %s", err)
	}
	if err := d.Set("self_link_with_id", flattenComputeFutureReservationSelfLinkWithId(res["selfLinkWithId"], d, config)); err != nil {
		return fmt.Errorf("Error reading FutureReservation: %s", err)
	}
	if err := d.Set("description", flattenComputeFutureReservationDescription(res["description"], d, config)); err != nil {
		return fmt.Errorf("Error reading FutureReservation: %s", err)
	}
	if err := d.Set("time_window", flattenComputeFutureReservationTimeWindow(res["timeWindow"], d, config)); err != nil {
		return fmt.Errorf("Error reading FutureReservation: %s", err)
	}
	if err := d.Set("share_settings", flattenComputeFutureReservationShareSettings(res["shareSettings"], d, config)); err != nil {
		return fmt.Errorf("Error reading FutureReservation: %s", err)
	}
	if err := d.Set("name_prefix", flattenComputeFutureReservationNamePrefix(res["namePrefix"], d, config)); err != nil {
		return fmt.Errorf("Error reading FutureReservation: %s", err)
	}
	if err := d.Set("status", flattenComputeFutureReservationStatus(res["status"], d, config)); err != nil {
		return fmt.Errorf("Error reading FutureReservation: %s", err)
	}
	if err := d.Set("planning_status", flattenComputeFutureReservationPlanningStatus(res["planningStatus"], d, config)); err != nil {
		return fmt.Errorf("Error reading FutureReservation: %s", err)
	}
	if err := d.Set("specific_reservation_required", flattenComputeFutureReservationSpecificReservationRequired(res["specificReservationRequired"], d, config)); err != nil {
		return fmt.Errorf("Error reading FutureReservation: %s", err)
	}
	if err := d.Set("reservation_name", flattenComputeFutureReservationReservationName(res["reservationName"], d, config)); err != nil {
		return fmt.Errorf("Error reading FutureReservation: %s", err)
	}
	if err := d.Set("deployment_type", flattenComputeFutureReservationDeploymentType(res["deploymentType"], d, config)); err != nil {
		return fmt.Errorf("Error reading FutureReservation: %s", err)
	}
	if err := d.Set("reservation_mode", flattenComputeFutureReservationReservationMode(res["reservationMode"], d, config)); err != nil {
		return fmt.Errorf("Error reading FutureReservation: %s", err)
	}
	if err := d.Set("commitment_info", flattenComputeFutureReservationCommitmentInfo(res["commitmentInfo"], d, config)); err != nil {
		return fmt.Errorf("Error reading FutureReservation: %s", err)
	}
	if err := d.Set("scheduling_type", flattenComputeFutureReservationSchedulingType(res["schedulingType"], d, config)); err != nil {
		return fmt.Errorf("Error reading FutureReservation: %s", err)
	}
	if err := d.Set("specific_sku_properties", flattenComputeFutureReservationSpecificSkuProperties(res["specificSkuProperties"], d, config)); err != nil {
		return fmt.Errorf("Error reading FutureReservation: %s", err)
	}
	if err := d.Set("auto_created_reservations_duration", flattenComputeFutureReservationAutoCreatedReservationsDuration(res["autoCreatedReservationsDuration"], d, config)); err != nil {
		return fmt.Errorf("Error reading FutureReservation: %s", err)
	}
	if err := d.Set("name", flattenComputeFutureReservationName(res["name"], d, config)); err != nil {
		return fmt.Errorf("Error reading FutureReservation: %s", err)
	}
	if err := d.Set("self_link", tpgresource.ConvertSelfLinkToV1(res["selfLink"].(string))); err != nil {
		return fmt.Errorf("Error reading FutureReservation: %s", err)
	}

	return nil
}

func resourceComputeFutureReservationUpdate(d *schema.ResourceData, meta interface{}) error {
	config := meta.(*transport_tpg.Config)
	userAgent, err := tpgresource.GenerateUserAgentString(d, config.UserAgent)
	if err != nil {
		return err
	}

	billingProject := ""

	project, err := tpgresource.GetProject(d, config)
	if err != nil {
		return fmt.Errorf("Error fetching project for FutureReservation: %s", err)
	}
	billingProject = project

	obj := make(map[string]interface{})
	descriptionProp, err := expandComputeFutureReservationDescription(d.Get("description"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("description"); !tpgresource.IsEmptyValue(reflect.ValueOf(v)) && (ok || !reflect.DeepEqual(v, descriptionProp)) {
		obj["description"] = descriptionProp
	}
	timeWindowProp, err := expandComputeFutureReservationTimeWindow(d.Get("time_window"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("time_window"); !tpgresource.IsEmptyValue(reflect.ValueOf(v)) && (ok || !reflect.DeepEqual(v, timeWindowProp)) {
		obj["timeWindow"] = timeWindowProp
	}
	shareSettingsProp, err := expandComputeFutureReservationShareSettings(d.Get("share_settings"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("share_settings"); !tpgresource.IsEmptyValue(reflect.ValueOf(v)) && (ok || !reflect.DeepEqual(v, shareSettingsProp)) {
		obj["shareSettings"] = shareSettingsProp
	}
	namePrefixProp, err := expandComputeFutureReservationNamePrefix(d.Get("name_prefix"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("name_prefix"); !tpgresource.IsEmptyValue(reflect.ValueOf(v)) && (ok || !reflect.DeepEqual(v, namePrefixProp)) {
		obj["namePrefix"] = namePrefixProp
	}
	planningStatusProp, err := expandComputeFutureReservationPlanningStatus(d.Get("planning_status"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("planning_status"); !tpgresource.IsEmptyValue(reflect.ValueOf(v)) && (ok || !reflect.DeepEqual(v, planningStatusProp)) {
		obj["planningStatus"] = planningStatusProp
	}
	autoDeleteAutoCreatedReservationsProp, err := expandComputeFutureReservationAutoDeleteAutoCreatedReservations(d.Get("auto_delete_auto_created_reservations"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("auto_delete_auto_created_reservations"); !tpgresource.IsEmptyValue(reflect.ValueOf(v)) && (ok || !reflect.DeepEqual(v, autoDeleteAutoCreatedReservationsProp)) {
		obj["autoDeleteAutoCreatedReservations"] = autoDeleteAutoCreatedReservationsProp
	}
	specificReservationRequiredProp, err := expandComputeFutureReservationSpecificReservationRequired(d.Get("specific_reservation_required"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("specific_reservation_required"); !tpgresource.IsEmptyValue(reflect.ValueOf(v)) && (ok || !reflect.DeepEqual(v, specificReservationRequiredProp)) {
		obj["specificReservationRequired"] = specificReservationRequiredProp
	}
	reservationNameProp, err := expandComputeFutureReservationReservationName(d.Get("reservation_name"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("reservation_name"); !tpgresource.IsEmptyValue(reflect.ValueOf(v)) && (ok || !reflect.DeepEqual(v, reservationNameProp)) {
		obj["reservationName"] = reservationNameProp
	}
	deploymentTypeProp, err := expandComputeFutureReservationDeploymentType(d.Get("deployment_type"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("deployment_type"); !tpgresource.IsEmptyValue(reflect.ValueOf(v)) && (ok || !reflect.DeepEqual(v, deploymentTypeProp)) {
		obj["deploymentType"] = deploymentTypeProp
	}
	reservationModeProp, err := expandComputeFutureReservationReservationMode(d.Get("reservation_mode"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("reservation_mode"); !tpgresource.IsEmptyValue(reflect.ValueOf(v)) && (ok || !reflect.DeepEqual(v, reservationModeProp)) {
		obj["reservationMode"] = reservationModeProp
	}
	commitmentInfoProp, err := expandComputeFutureReservationCommitmentInfo(d.Get("commitment_info"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("commitment_info"); !tpgresource.IsEmptyValue(reflect.ValueOf(v)) && (ok || !reflect.DeepEqual(v, commitmentInfoProp)) {
		obj["commitmentInfo"] = commitmentInfoProp
	}
	schedulingTypeProp, err := expandComputeFutureReservationSchedulingType(d.Get("scheduling_type"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("scheduling_type"); !tpgresource.IsEmptyValue(reflect.ValueOf(v)) && (ok || !reflect.DeepEqual(v, schedulingTypeProp)) {
		obj["schedulingType"] = schedulingTypeProp
	}
	specificSkuPropertiesProp, err := expandComputeFutureReservationSpecificSkuProperties(d.Get("specific_sku_properties"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("specific_sku_properties"); !tpgresource.IsEmptyValue(reflect.ValueOf(v)) && (ok || !reflect.DeepEqual(v, specificSkuPropertiesProp)) {
		obj["specificSkuProperties"] = specificSkuPropertiesProp
	}
	autoCreatedReservationsDeleteTimeProp, err := expandComputeFutureReservationAutoCreatedReservationsDeleteTime(d.Get("auto_created_reservations_delete_time"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("auto_created_reservations_delete_time"); !tpgresource.IsEmptyValue(reflect.ValueOf(v)) && (ok || !reflect.DeepEqual(v, autoCreatedReservationsDeleteTimeProp)) {
		obj["autoCreatedReservationsDeleteTime"] = autoCreatedReservationsDeleteTimeProp
	}
	autoCreatedReservationsDurationProp, err := expandComputeFutureReservationAutoCreatedReservationsDuration(d.Get("auto_created_reservations_duration"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("auto_created_reservations_duration"); !tpgresource.IsEmptyValue(reflect.ValueOf(v)) && (ok || !reflect.DeepEqual(v, autoCreatedReservationsDurationProp)) {
		obj["autoCreatedReservationsDuration"] = autoCreatedReservationsDurationProp
	}

	obj, err = resourceComputeFutureReservationUpdateEncoder(d, meta, obj)
	if err != nil {
		return err
	}

	url, err := tpgresource.ReplaceVars(d, config, "{{ComputeBasePath}}projects/{{project}}/zones/{{zone}}/futureReservations/{{name}}")
	if err != nil {
		return err
	}

	log.Printf("[DEBUG] Updating FutureReservation %q: %#v", d.Id(), obj)
	headers := make(http.Header)
	updateMask := []string{}

	if d.HasChange("description") {
		updateMask = append(updateMask, "description")
	}

	if d.HasChange("time_window") {
		updateMask = append(updateMask, "timeWindow")
	}

	if d.HasChange("share_settings") {
		updateMask = append(updateMask, "shareSettings")
	}

	if d.HasChange("name_prefix") {
		updateMask = append(updateMask, "namePrefix")
	}

	if d.HasChange("planning_status") {
		updateMask = append(updateMask, "planningStatus")
	}

	if d.HasChange("auto_delete_auto_created_reservations") {
		updateMask = append(updateMask, "autoDeleteAutoCreatedReservations")
	}

	if d.HasChange("specific_reservation_required") {
		updateMask = append(updateMask, "specificReservationRequired")
	}

	if d.HasChange("reservation_name") {
		updateMask = append(updateMask, "reservationName")
	}

	if d.HasChange("deployment_type") {
		updateMask = append(updateMask, "deploymentType")
	}

	if d.HasChange("reservation_mode") {
		updateMask = append(updateMask, "reservationMode")
	}

	if d.HasChange("commitment_info") {
		updateMask = append(updateMask, "commitmentInfo")
	}

	if d.HasChange("scheduling_type") {
		updateMask = append(updateMask, "schedulingType")
	}

	if d.HasChange("specific_sku_properties") {
		updateMask = append(updateMask, "specificSkuProperties")
	}

	if d.HasChange("auto_created_reservations_delete_time") {
		updateMask = append(updateMask, "autoCreatedReservationsDeleteTime")
	}

	if d.HasChange("auto_created_reservations_duration") {
		updateMask = append(updateMask, "autoCreatedReservationsDuration")
	}
	// updateMask is a URL parameter but not present in the schema, so ReplaceVars
	// won't set it
	url, err = transport_tpg.AddQueryParams(url, map[string]string{"updateMask": strings.Join(updateMask, ",")})
	if err != nil {
		return err
	}

	// err == nil indicates that the billing_project value was found
	if bp, err := tpgresource.GetBillingProject(d, config); err == nil {
		billingProject = bp
	}

	// if updateMask is empty we are not updating anything so skip the post
	if len(updateMask) > 0 {
		res, err := transport_tpg.SendRequest(transport_tpg.SendRequestOptions{
			Config:    config,
			Method:    "PATCH",
			Project:   billingProject,
			RawURL:    url,
			UserAgent: userAgent,
			Body:      obj,
			Timeout:   d.Timeout(schema.TimeoutUpdate),
			Headers:   headers,
		})

		if err != nil {
			return fmt.Errorf("Error updating FutureReservation %q: %s", d.Id(), err)
		} else {
			log.Printf("[DEBUG] Finished updating FutureReservation %q: %#v", d.Id(), res)
		}

		err = ComputeOperationWaitTime(
			config, res, project, "Updating FutureReservation", userAgent,
			d.Timeout(schema.TimeoutUpdate))

		if err != nil {
			return err
		}
	}

	return resourceComputeFutureReservationRead(d, meta)
}

func resourceComputeFutureReservationDelete(d *schema.ResourceData, meta interface{}) error {
	config := meta.(*transport_tpg.Config)
	userAgent, err := tpgresource.GenerateUserAgentString(d, config.UserAgent)
	if err != nil {
		return err
	}

	billingProject := ""

	project, err := tpgresource.GetProject(d, config)
	if err != nil {
		return fmt.Errorf("Error fetching project for FutureReservation: %s", err)
	}
	billingProject = project

	url, err := tpgresource.ReplaceVars(d, config, "{{ComputeBasePath}}projects/{{project}}/zones/{{zone}}/futureReservations/{{name}}")
	if err != nil {
		return err
	}

	var obj map[string]interface{}

	// err == nil indicates that the billing_project value was found
	if bp, err := tpgresource.GetBillingProject(d, config); err == nil {
		billingProject = bp
	}

	headers := make(http.Header)

	log.Printf("[DEBUG] Deleting FutureReservation %q", d.Id())
	res, err := transport_tpg.SendRequest(transport_tpg.SendRequestOptions{
		Config:    config,
		Method:    "DELETE",
		Project:   billingProject,
		RawURL:    url,
		UserAgent: userAgent,
		Body:      obj,
		Timeout:   d.Timeout(schema.TimeoutDelete),
		Headers:   headers,
	})
	if err != nil {
		return transport_tpg.HandleNotFoundError(err, d, "FutureReservation")
	}

	err = ComputeOperationWaitTime(
		config, res, project, "Deleting FutureReservation", userAgent,
		d.Timeout(schema.TimeoutDelete))

	if err != nil {
		return err
	}

	log.Printf("[DEBUG] Finished deleting FutureReservation %q: %#v", d.Id(), res)
	return nil
}

func resourceComputeFutureReservationImport(d *schema.ResourceData, meta interface{}) ([]*schema.ResourceData, error) {
	config := meta.(*transport_tpg.Config)
	if err := tpgresource.ParseImportId([]string{
		"^projects/(?P<project>[^/]+)/zones/(?P<zone>[^/]+)/futureReservations/(?P<name>[^/]+)$",
		"^(?P<project>[^/]+)/(?P<zone>[^/]+)/(?P<name>[^/]+)$",
		"^(?P<zone>[^/]+)/(?P<name>[^/]+)$",
		"^(?P<name>[^/]+)$",
	}, d, config); err != nil {
		return nil, err
	}

	// Replace import id for the resource id
	id, err := tpgresource.ReplaceVars(d, config, "projects/{{project}}/zones/{{zone}}/futureReservations/{{name}}")
	if err != nil {
		return nil, fmt.Errorf("Error constructing id: %s", err)
	}
	d.SetId(id)

	return []*schema.ResourceData{d}, nil
}

func flattenComputeFutureReservationZone(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenComputeFutureReservationCreationTimestamp(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenComputeFutureReservationSelfLinkWithId(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenComputeFutureReservationDescription(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenComputeFutureReservationTimeWindow(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return nil
	}
	original := v.(map[string]interface{})
	if len(original) == 0 {
		return nil
	}
	transformed := make(map[string]interface{})
	transformed["start_time"] =
		flattenComputeFutureReservationTimeWindowStartTime(original["startTime"], d, config)
	transformed["end_time"] =
		flattenComputeFutureReservationTimeWindowEndTime(original["endTime"], d, config)
	transformed["duration"] =
		flattenComputeFutureReservationTimeWindowDuration(original["duration"], d, config)
	return []interface{}{transformed}
}
func flattenComputeFutureReservationTimeWindowStartTime(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenComputeFutureReservationTimeWindowEndTime(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenComputeFutureReservationTimeWindowDuration(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return nil
	}
	original := v.(map[string]interface{})
	if len(original) == 0 {
		return nil
	}
	transformed := make(map[string]interface{})
	transformed["seconds"] =
		flattenComputeFutureReservationTimeWindowDurationSeconds(original["seconds"], d, config)
	transformed["nanos"] =
		flattenComputeFutureReservationTimeWindowDurationNanos(original["nanos"], d, config)
	return []interface{}{transformed}
}
func flattenComputeFutureReservationTimeWindowDurationSeconds(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenComputeFutureReservationTimeWindowDurationNanos(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	// Handles the string fixed64 format
	if strVal, ok := v.(string); ok {
		if intVal, err := tpgresource.StringToFixed64(strVal); err == nil {
			return intVal
		}
	}

	// number values are represented as float64
	if floatVal, ok := v.(float64); ok {
		intVal := int(floatVal)
		return intVal
	}

	return v // let terraform core handle it otherwise
}

func flattenComputeFutureReservationShareSettings(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return nil
	}
	original := v.(map[string]interface{})
	if len(original) == 0 {
		return nil
	}
	transformed := make(map[string]interface{})
	transformed["share_type"] =
		flattenComputeFutureReservationShareSettingsShareType(original["shareType"], d, config)
	transformed["projects"] =
		flattenComputeFutureReservationShareSettingsProjects(original["projects"], d, config)
	transformed["project_map"] =
		flattenComputeFutureReservationShareSettingsProjectMap(original["projectMap"], d, config)
	return []interface{}{transformed}
}
func flattenComputeFutureReservationShareSettingsShareType(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenComputeFutureReservationShareSettingsProjects(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenComputeFutureReservationShareSettingsProjectMap(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return v
	}
	l := v.(map[string]interface{})
	transformed := make([]interface{}, 0, len(l))
	for k, raw := range l {
		original := raw.(map[string]interface{})
		transformed = append(transformed, map[string]interface{}{
			"id":         k,
			"project_id": flattenComputeFutureReservationShareSettingsProjectMapProjectId(original["projectId"], d, config),
		})
	}
	return transformed
}
func flattenComputeFutureReservationShareSettingsProjectMapProjectId(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenComputeFutureReservationNamePrefix(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenComputeFutureReservationStatus(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return nil
	}
	original := v.(map[string]interface{})
	if len(original) == 0 {
		return nil
	}
	transformed := make(map[string]interface{})
	transformed["procurement_status"] =
		flattenComputeFutureReservationStatusProcurementStatus(original["procurementStatus"], d, config)
	transformed["lock_time"] =
		flattenComputeFutureReservationStatusLockTime(original["lockTime"], d, config)
	transformed["auto_created_reservations"] =
		flattenComputeFutureReservationStatusAutoCreatedReservations(original["autoCreatedReservations"], d, config)
	transformed["fulfilled_count"] =
		flattenComputeFutureReservationStatusFulfilledCount(original["fulfilledCount"], d, config)
	transformed["specific_sku_properties"] =
		flattenComputeFutureReservationStatusSpecificSkuProperties(original["specificSkuProperties"], d, config)
	transformed["amendment_status"] =
		flattenComputeFutureReservationStatusAmendmentStatus(original["amendmentStatus"], d, config)
	transformed["last_known_good_state"] =
		flattenComputeFutureReservationStatusLastKnownGoodState(original["lastKnownGoodState"], d, config)
	return []interface{}{transformed}
}
func flattenComputeFutureReservationStatusProcurementStatus(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenComputeFutureReservationStatusLockTime(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenComputeFutureReservationStatusAutoCreatedReservations(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenComputeFutureReservationStatusFulfilledCount(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenComputeFutureReservationStatusSpecificSkuProperties(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return nil
	}
	original := v.(map[string]interface{})
	if len(original) == 0 {
		return nil
	}
	transformed := make(map[string]interface{})
	transformed["source_instance_template_id"] =
		flattenComputeFutureReservationStatusSpecificSkuPropertiesSourceInstanceTemplateId(original["sourceInstanceTemplateId"], d, config)
	return []interface{}{transformed}
}
func flattenComputeFutureReservationStatusSpecificSkuPropertiesSourceInstanceTemplateId(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenComputeFutureReservationStatusAmendmentStatus(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenComputeFutureReservationStatusLastKnownGoodState(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return nil
	}
	original := v.(map[string]interface{})
	if len(original) == 0 {
		return nil
	}
	transformed := make(map[string]interface{})
	transformed["future_reservation_specs"] =
		flattenComputeFutureReservationStatusLastKnownGoodStateFutureReservationSpecs(original["futureReservationSpecs"], d, config)
	transformed["procurement_status"] =
		flattenComputeFutureReservationStatusLastKnownGoodStateProcurementStatus(original["procurementStatus"], d, config)
	transformed["name_prefix"] =
		flattenComputeFutureReservationStatusLastKnownGoodStateNamePrefix(original["namePrefix"], d, config)
	transformed["description"] =
		flattenComputeFutureReservationStatusLastKnownGoodStateDescription(original["description"], d, config)
	transformed["lock_time"] =
		flattenComputeFutureReservationStatusLastKnownGoodStateLockTime(original["lockTime"], d, config)
	transformed["existing_matching_usage_info"] =
		flattenComputeFutureReservationStatusLastKnownGoodStateExistingMatchingUsageInfo(original["existingMatchingUsageInfo"], d, config)
	return []interface{}{transformed}
}
func flattenComputeFutureReservationStatusLastKnownGoodStateFutureReservationSpecs(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return nil
	}
	original := v.(map[string]interface{})
	if len(original) == 0 {
		return nil
	}
	transformed := make(map[string]interface{})
	transformed["specific_sku_properties"] =
		flattenComputeFutureReservationStatusLastKnownGoodStateFutureReservationSpecsSpecificSkuProperties(original["specificSkuProperties"], d, config)
	transformed["time_window"] =
		flattenComputeFutureReservationStatusLastKnownGoodStateFutureReservationSpecsTimeWindow(original["timeWindow"], d, config)
	transformed["share_settings"] =
		flattenComputeFutureReservationStatusLastKnownGoodStateFutureReservationSpecsShareSettings(original["shareSettings"], d, config)
	return []interface{}{transformed}
}
func flattenComputeFutureReservationStatusLastKnownGoodStateFutureReservationSpecsSpecificSkuProperties(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return nil
	}
	original := v.(map[string]interface{})
	if len(original) == 0 {
		return nil
	}
	transformed := make(map[string]interface{})
	transformed["instance_properties"] =
		flattenComputeFutureReservationStatusLastKnownGoodStateFutureReservationSpecsSpecificSkuPropertiesInstanceProperties(original["instanceProperties"], d, config)
	transformed["total_count"] =
		flattenComputeFutureReservationStatusLastKnownGoodStateFutureReservationSpecsSpecificSkuPropertiesTotalCount(original["totalCount"], d, config)
	transformed["source_instance_template"] =
		flattenComputeFutureReservationStatusLastKnownGoodStateFutureReservationSpecsSpecificSkuPropertiesSourceInstanceTemplate(original["sourceInstanceTemplate"], d, config)
	return []interface{}{transformed}
}
func flattenComputeFutureReservationStatusLastKnownGoodStateFutureReservationSpecsSpecificSkuPropertiesInstanceProperties(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return nil
	}
	original := v.(map[string]interface{})
	if len(original) == 0 {
		return nil
	}
	transformed := make(map[string]interface{})
	transformed["machine_type"] =
		flattenComputeFutureReservationStatusLastKnownGoodStateFutureReservationSpecsSpecificSkuPropertiesInstancePropertiesMachineType(original["machineType"], d, config)
	transformed["guest_accelerators"] =
		flattenComputeFutureReservationStatusLastKnownGoodStateFutureReservationSpecsSpecificSkuPropertiesInstancePropertiesGuestAccelerators(original["guestAccelerators"], d, config)
	transformed["min_cpu_platform"] =
		flattenComputeFutureReservationStatusLastKnownGoodStateFutureReservationSpecsSpecificSkuPropertiesInstancePropertiesMinCpuPlatform(original["minCpuPlatform"], d, config)
	transformed["local_ssds"] =
		flattenComputeFutureReservationStatusLastKnownGoodStateFutureReservationSpecsSpecificSkuPropertiesInstancePropertiesLocalSsds(original["localSsds"], d, config)
	transformed["maintenance_freeze_duration_hours"] =
		flattenComputeFutureReservationStatusLastKnownGoodStateFutureReservationSpecsSpecificSkuPropertiesInstancePropertiesMaintenanceFreezeDurationHours(original["maintenanceFreezeDurationHours"], d, config)
	transformed["location_hint"] =
		flattenComputeFutureReservationStatusLastKnownGoodStateFutureReservationSpecsSpecificSkuPropertiesInstancePropertiesLocationHint(original["locationHint"], d, config)
	transformed["maintenance_interval"] =
		flattenComputeFutureReservationStatusLastKnownGoodStateFutureReservationSpecsSpecificSkuPropertiesInstancePropertiesMaintenanceInterval(original["maintenanceInterval"], d, config)
	return []interface{}{transformed}
}
func flattenComputeFutureReservationStatusLastKnownGoodStateFutureReservationSpecsSpecificSkuPropertiesInstancePropertiesMachineType(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenComputeFutureReservationStatusLastKnownGoodStateFutureReservationSpecsSpecificSkuPropertiesInstancePropertiesGuestAccelerators(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return v
	}
	l := v.([]interface{})
	transformed := make([]interface{}, 0, len(l))
	for _, raw := range l {
		original := raw.(map[string]interface{})
		if len(original) < 1 {
			// Do not include empty json objects coming back from the api
			continue
		}
		transformed = append(transformed, map[string]interface{}{
			"accelerator_type":  flattenComputeFutureReservationStatusLastKnownGoodStateFutureReservationSpecsSpecificSkuPropertiesInstancePropertiesGuestAcceleratorsAcceleratorType(original["acceleratorType"], d, config),
			"accelerator_count": flattenComputeFutureReservationStatusLastKnownGoodStateFutureReservationSpecsSpecificSkuPropertiesInstancePropertiesGuestAcceleratorsAcceleratorCount(original["acceleratorCount"], d, config),
		})
	}
	return transformed
}
func flattenComputeFutureReservationStatusLastKnownGoodStateFutureReservationSpecsSpecificSkuPropertiesInstancePropertiesGuestAcceleratorsAcceleratorType(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenComputeFutureReservationStatusLastKnownGoodStateFutureReservationSpecsSpecificSkuPropertiesInstancePropertiesGuestAcceleratorsAcceleratorCount(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	// Handles the string fixed64 format
	if strVal, ok := v.(string); ok {
		if intVal, err := tpgresource.StringToFixed64(strVal); err == nil {
			return intVal
		}
	}

	// number values are represented as float64
	if floatVal, ok := v.(float64); ok {
		intVal := int(floatVal)
		return intVal
	}

	return v // let terraform core handle it otherwise
}

func flattenComputeFutureReservationStatusLastKnownGoodStateFutureReservationSpecsSpecificSkuPropertiesInstancePropertiesMinCpuPlatform(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenComputeFutureReservationStatusLastKnownGoodStateFutureReservationSpecsSpecificSkuPropertiesInstancePropertiesLocalSsds(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return v
	}
	l := v.([]interface{})
	transformed := make([]interface{}, 0, len(l))
	for _, raw := range l {
		original := raw.(map[string]interface{})
		if len(original) < 1 {
			// Do not include empty json objects coming back from the api
			continue
		}
		transformed = append(transformed, map[string]interface{}{
			"disk_size_gb": flattenComputeFutureReservationStatusLastKnownGoodStateFutureReservationSpecsSpecificSkuPropertiesInstancePropertiesLocalSsdsDiskSizeGb(original["diskSizeGb"], d, config),
			"interface":    flattenComputeFutureReservationStatusLastKnownGoodStateFutureReservationSpecsSpecificSkuPropertiesInstancePropertiesLocalSsdsInterface(original["interface"], d, config),
		})
	}
	return transformed
}
func flattenComputeFutureReservationStatusLastKnownGoodStateFutureReservationSpecsSpecificSkuPropertiesInstancePropertiesLocalSsdsDiskSizeGb(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenComputeFutureReservationStatusLastKnownGoodStateFutureReservationSpecsSpecificSkuPropertiesInstancePropertiesLocalSsdsInterface(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenComputeFutureReservationStatusLastKnownGoodStateFutureReservationSpecsSpecificSkuPropertiesInstancePropertiesMaintenanceFreezeDurationHours(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	// Handles the string fixed64 format
	if strVal, ok := v.(string); ok {
		if intVal, err := tpgresource.StringToFixed64(strVal); err == nil {
			return intVal
		}
	}

	// number values are represented as float64
	if floatVal, ok := v.(float64); ok {
		intVal := int(floatVal)
		return intVal
	}

	return v // let terraform core handle it otherwise
}

func flattenComputeFutureReservationStatusLastKnownGoodStateFutureReservationSpecsSpecificSkuPropertiesInstancePropertiesLocationHint(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenComputeFutureReservationStatusLastKnownGoodStateFutureReservationSpecsSpecificSkuPropertiesInstancePropertiesMaintenanceInterval(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenComputeFutureReservationStatusLastKnownGoodStateFutureReservationSpecsSpecificSkuPropertiesTotalCount(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenComputeFutureReservationStatusLastKnownGoodStateFutureReservationSpecsSpecificSkuPropertiesSourceInstanceTemplate(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenComputeFutureReservationStatusLastKnownGoodStateFutureReservationSpecsTimeWindow(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return nil
	}
	original := v.(map[string]interface{})
	if len(original) == 0 {
		return nil
	}
	transformed := make(map[string]interface{})
	transformed["start_time"] =
		flattenComputeFutureReservationStatusLastKnownGoodStateFutureReservationSpecsTimeWindowStartTime(original["startTime"], d, config)
	transformed["end_time"] =
		flattenComputeFutureReservationStatusLastKnownGoodStateFutureReservationSpecsTimeWindowEndTime(original["endTime"], d, config)
	transformed["duration"] =
		flattenComputeFutureReservationStatusLastKnownGoodStateFutureReservationSpecsTimeWindowDuration(original["duration"], d, config)
	return []interface{}{transformed}
}
func flattenComputeFutureReservationStatusLastKnownGoodStateFutureReservationSpecsTimeWindowStartTime(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenComputeFutureReservationStatusLastKnownGoodStateFutureReservationSpecsTimeWindowEndTime(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenComputeFutureReservationStatusLastKnownGoodStateFutureReservationSpecsTimeWindowDuration(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return nil
	}
	original := v.(map[string]interface{})
	if len(original) == 0 {
		return nil
	}
	transformed := make(map[string]interface{})
	transformed["seconds"] =
		flattenComputeFutureReservationStatusLastKnownGoodStateFutureReservationSpecsTimeWindowDurationSeconds(original["seconds"], d, config)
	transformed["nanos"] =
		flattenComputeFutureReservationStatusLastKnownGoodStateFutureReservationSpecsTimeWindowDurationNanos(original["nanos"], d, config)
	return []interface{}{transformed}
}
func flattenComputeFutureReservationStatusLastKnownGoodStateFutureReservationSpecsTimeWindowDurationSeconds(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenComputeFutureReservationStatusLastKnownGoodStateFutureReservationSpecsTimeWindowDurationNanos(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	// Handles the string fixed64 format
	if strVal, ok := v.(string); ok {
		if intVal, err := tpgresource.StringToFixed64(strVal); err == nil {
			return intVal
		}
	}

	// number values are represented as float64
	if floatVal, ok := v.(float64); ok {
		intVal := int(floatVal)
		return intVal
	}

	return v // let terraform core handle it otherwise
}

func flattenComputeFutureReservationStatusLastKnownGoodStateFutureReservationSpecsShareSettings(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return nil
	}
	original := v.(map[string]interface{})
	if len(original) == 0 {
		return nil
	}
	transformed := make(map[string]interface{})
	transformed["share_type"] =
		flattenComputeFutureReservationStatusLastKnownGoodStateFutureReservationSpecsShareSettingsShareType(original["shareType"], d, config)
	transformed["projects"] =
		flattenComputeFutureReservationStatusLastKnownGoodStateFutureReservationSpecsShareSettingsProjects(original["projects"], d, config)
	transformed["project_map"] =
		flattenComputeFutureReservationStatusLastKnownGoodStateFutureReservationSpecsShareSettingsProjectMap(original["projectMap"], d, config)
	return []interface{}{transformed}
}
func flattenComputeFutureReservationStatusLastKnownGoodStateFutureReservationSpecsShareSettingsShareType(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenComputeFutureReservationStatusLastKnownGoodStateFutureReservationSpecsShareSettingsProjects(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenComputeFutureReservationStatusLastKnownGoodStateFutureReservationSpecsShareSettingsProjectMap(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return v
	}
	l := v.(map[string]interface{})
	transformed := make([]interface{}, 0, len(l))
	for k, raw := range l {
		original := raw.(map[string]interface{})
		transformed = append(transformed, map[string]interface{}{
			"project":    k,
			"project_id": flattenComputeFutureReservationStatusLastKnownGoodStateFutureReservationSpecsShareSettingsProjectMapProjectId(original["projectId"], d, config),
		})
	}
	return transformed
}
func flattenComputeFutureReservationStatusLastKnownGoodStateFutureReservationSpecsShareSettingsProjectMapProjectId(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenComputeFutureReservationStatusLastKnownGoodStateProcurementStatus(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenComputeFutureReservationStatusLastKnownGoodStateNamePrefix(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenComputeFutureReservationStatusLastKnownGoodStateDescription(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenComputeFutureReservationStatusLastKnownGoodStateLockTime(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenComputeFutureReservationStatusLastKnownGoodStateExistingMatchingUsageInfo(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return nil
	}
	original := v.(map[string]interface{})
	if len(original) == 0 {
		return nil
	}
	transformed := make(map[string]interface{})
	transformed["count"] =
		flattenComputeFutureReservationStatusLastKnownGoodStateExistingMatchingUsageInfoCount(original["count"], d, config)
	transformed["time_stamp"] =
		flattenComputeFutureReservationStatusLastKnownGoodStateExistingMatchingUsageInfoTimeStamp(original["timeStamp"], d, config)
	return []interface{}{transformed}
}
func flattenComputeFutureReservationStatusLastKnownGoodStateExistingMatchingUsageInfoCount(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenComputeFutureReservationStatusLastKnownGoodStateExistingMatchingUsageInfoTimeStamp(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenComputeFutureReservationPlanningStatus(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenComputeFutureReservationSpecificReservationRequired(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenComputeFutureReservationReservationName(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenComputeFutureReservationDeploymentType(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenComputeFutureReservationReservationMode(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenComputeFutureReservationCommitmentInfo(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return nil
	}
	original := v.(map[string]interface{})
	if len(original) == 0 {
		return nil
	}
	transformed := make(map[string]interface{})
	transformed["commitment_plan"] =
		flattenComputeFutureReservationCommitmentInfoCommitmentPlan(original["commitmentPlan"], d, config)
	transformed["commitment_name"] =
		flattenComputeFutureReservationCommitmentInfoCommitmentName(original["commitmentName"], d, config)
	transformed["previous_commitment_terms"] =
		flattenComputeFutureReservationCommitmentInfoPreviousCommitmentTerms(original["previousCommitmentTerms"], d, config)
	return []interface{}{transformed}
}
func flattenComputeFutureReservationCommitmentInfoCommitmentPlan(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenComputeFutureReservationCommitmentInfoCommitmentName(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenComputeFutureReservationCommitmentInfoPreviousCommitmentTerms(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenComputeFutureReservationSchedulingType(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenComputeFutureReservationSpecificSkuProperties(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return nil
	}
	original := v.(map[string]interface{})
	if len(original) == 0 {
		return nil
	}
	transformed := make(map[string]interface{})
	transformed["instance_properties"] =
		flattenComputeFutureReservationSpecificSkuPropertiesInstanceProperties(original["instanceProperties"], d, config)
	transformed["total_count"] =
		flattenComputeFutureReservationSpecificSkuPropertiesTotalCount(original["totalCount"], d, config)
	transformed["source_instance_template"] =
		flattenComputeFutureReservationSpecificSkuPropertiesSourceInstanceTemplate(original["sourceInstanceTemplate"], d, config)
	return []interface{}{transformed}
}
func flattenComputeFutureReservationSpecificSkuPropertiesInstanceProperties(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return nil
	}
	original := v.(map[string]interface{})
	if len(original) == 0 {
		return nil
	}
	transformed := make(map[string]interface{})
	transformed["machine_type"] =
		flattenComputeFutureReservationSpecificSkuPropertiesInstancePropertiesMachineType(original["machineType"], d, config)
	transformed["guest_accelerators"] =
		flattenComputeFutureReservationSpecificSkuPropertiesInstancePropertiesGuestAccelerators(original["guestAccelerators"], d, config)
	transformed["min_cpu_platform"] =
		flattenComputeFutureReservationSpecificSkuPropertiesInstancePropertiesMinCpuPlatform(original["minCpuPlatform"], d, config)
	transformed["local_ssds"] =
		flattenComputeFutureReservationSpecificSkuPropertiesInstancePropertiesLocalSsds(original["localSsds"], d, config)
	transformed["maintenance_freeze_duration_hours"] =
		flattenComputeFutureReservationSpecificSkuPropertiesInstancePropertiesMaintenanceFreezeDurationHours(original["maintenanceFreezeDurationHours"], d, config)
	transformed["location_hint"] =
		flattenComputeFutureReservationSpecificSkuPropertiesInstancePropertiesLocationHint(original["locationHint"], d, config)
	transformed["maintenance_interval"] =
		flattenComputeFutureReservationSpecificSkuPropertiesInstancePropertiesMaintenanceInterval(original["maintenanceInterval"], d, config)
	return []interface{}{transformed}
}
func flattenComputeFutureReservationSpecificSkuPropertiesInstancePropertiesMachineType(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenComputeFutureReservationSpecificSkuPropertiesInstancePropertiesGuestAccelerators(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return v
	}
	l := v.([]interface{})
	transformed := make([]interface{}, 0, len(l))
	for _, raw := range l {
		original := raw.(map[string]interface{})
		if len(original) < 1 {
			// Do not include empty json objects coming back from the api
			continue
		}
		transformed = append(transformed, map[string]interface{}{
			"accelerator_type":  flattenComputeFutureReservationSpecificSkuPropertiesInstancePropertiesGuestAcceleratorsAcceleratorType(original["acceleratorType"], d, config),
			"accelerator_count": flattenComputeFutureReservationSpecificSkuPropertiesInstancePropertiesGuestAcceleratorsAcceleratorCount(original["acceleratorCount"], d, config),
		})
	}
	return transformed
}
func flattenComputeFutureReservationSpecificSkuPropertiesInstancePropertiesGuestAcceleratorsAcceleratorType(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenComputeFutureReservationSpecificSkuPropertiesInstancePropertiesGuestAcceleratorsAcceleratorCount(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	// Handles the string fixed64 format
	if strVal, ok := v.(string); ok {
		if intVal, err := tpgresource.StringToFixed64(strVal); err == nil {
			return intVal
		}
	}

	// number values are represented as float64
	if floatVal, ok := v.(float64); ok {
		intVal := int(floatVal)
		return intVal
	}

	return v // let terraform core handle it otherwise
}

func flattenComputeFutureReservationSpecificSkuPropertiesInstancePropertiesMinCpuPlatform(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenComputeFutureReservationSpecificSkuPropertiesInstancePropertiesLocalSsds(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return v
	}
	l := v.([]interface{})
	transformed := make([]interface{}, 0, len(l))
	for _, raw := range l {
		original := raw.(map[string]interface{})
		if len(original) < 1 {
			// Do not include empty json objects coming back from the api
			continue
		}
		transformed = append(transformed, map[string]interface{}{
			"disk_size_gb": flattenComputeFutureReservationSpecificSkuPropertiesInstancePropertiesLocalSsdsDiskSizeGb(original["diskSizeGb"], d, config),
			"interface":    flattenComputeFutureReservationSpecificSkuPropertiesInstancePropertiesLocalSsdsInterface(original["interface"], d, config),
		})
	}
	return transformed
}
func flattenComputeFutureReservationSpecificSkuPropertiesInstancePropertiesLocalSsdsDiskSizeGb(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenComputeFutureReservationSpecificSkuPropertiesInstancePropertiesLocalSsdsInterface(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenComputeFutureReservationSpecificSkuPropertiesInstancePropertiesMaintenanceFreezeDurationHours(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	// Handles the string fixed64 format
	if strVal, ok := v.(string); ok {
		if intVal, err := tpgresource.StringToFixed64(strVal); err == nil {
			return intVal
		}
	}

	// number values are represented as float64
	if floatVal, ok := v.(float64); ok {
		intVal := int(floatVal)
		return intVal
	}

	return v // let terraform core handle it otherwise
}

func flattenComputeFutureReservationSpecificSkuPropertiesInstancePropertiesLocationHint(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenComputeFutureReservationSpecificSkuPropertiesInstancePropertiesMaintenanceInterval(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenComputeFutureReservationSpecificSkuPropertiesTotalCount(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenComputeFutureReservationSpecificSkuPropertiesSourceInstanceTemplate(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenComputeFutureReservationAutoCreatedReservationsDuration(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return nil
	}
	original := v.(map[string]interface{})
	if len(original) == 0 {
		return nil
	}
	transformed := make(map[string]interface{})
	transformed["seconds"] =
		flattenComputeFutureReservationAutoCreatedReservationsDurationSeconds(original["seconds"], d, config)
	transformed["nanos"] =
		flattenComputeFutureReservationAutoCreatedReservationsDurationNanos(original["nanos"], d, config)
	return []interface{}{transformed}
}
func flattenComputeFutureReservationAutoCreatedReservationsDurationSeconds(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenComputeFutureReservationAutoCreatedReservationsDurationNanos(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	// Handles the string fixed64 format
	if strVal, ok := v.(string); ok {
		if intVal, err := tpgresource.StringToFixed64(strVal); err == nil {
			return intVal
		}
	}

	// number values are represented as float64
	if floatVal, ok := v.(float64); ok {
		intVal := int(floatVal)
		return intVal
	}

	return v // let terraform core handle it otherwise
}

func flattenComputeFutureReservationName(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func expandComputeFutureReservationDescription(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandComputeFutureReservationTimeWindow(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	l := v.([]interface{})
	if len(l) == 0 || l[0] == nil {
		return nil, nil
	}
	raw := l[0]
	original := raw.(map[string]interface{})
	transformed := make(map[string]interface{})

	transformedStartTime, err := expandComputeFutureReservationTimeWindowStartTime(original["start_time"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedStartTime); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["startTime"] = transformedStartTime
	}

	transformedEndTime, err := expandComputeFutureReservationTimeWindowEndTime(original["end_time"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedEndTime); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["endTime"] = transformedEndTime
	}

	transformedDuration, err := expandComputeFutureReservationTimeWindowDuration(original["duration"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedDuration); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["duration"] = transformedDuration
	}

	return transformed, nil
}

func expandComputeFutureReservationTimeWindowStartTime(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandComputeFutureReservationTimeWindowEndTime(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandComputeFutureReservationTimeWindowDuration(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	l := v.([]interface{})
	if len(l) == 0 || l[0] == nil {
		return nil, nil
	}
	raw := l[0]
	original := raw.(map[string]interface{})
	transformed := make(map[string]interface{})

	transformedSeconds, err := expandComputeFutureReservationTimeWindowDurationSeconds(original["seconds"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedSeconds); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["seconds"] = transformedSeconds
	}

	transformedNanos, err := expandComputeFutureReservationTimeWindowDurationNanos(original["nanos"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedNanos); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["nanos"] = transformedNanos
	}

	return transformed, nil
}

func expandComputeFutureReservationTimeWindowDurationSeconds(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandComputeFutureReservationTimeWindowDurationNanos(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandComputeFutureReservationShareSettings(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	l := v.([]interface{})
	if len(l) == 0 || l[0] == nil {
		return nil, nil
	}
	raw := l[0]
	original := raw.(map[string]interface{})
	transformed := make(map[string]interface{})

	transformedShareType, err := expandComputeFutureReservationShareSettingsShareType(original["share_type"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedShareType); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["shareType"] = transformedShareType
	}

	transformedProjects, err := expandComputeFutureReservationShareSettingsProjects(original["projects"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedProjects); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["projects"] = transformedProjects
	}

	transformedProjectMap, err := expandComputeFutureReservationShareSettingsProjectMap(original["project_map"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedProjectMap); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["projectMap"] = transformedProjectMap
	}

	return transformed, nil
}

func expandComputeFutureReservationShareSettingsShareType(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandComputeFutureReservationShareSettingsProjects(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandComputeFutureReservationShareSettingsProjectMap(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (map[string]interface{}, error) {
	if v == nil {
		return map[string]interface{}{}, nil
	}
	m := make(map[string]interface{})
	for _, raw := range v.(*schema.Set).List() {
		original := raw.(map[string]interface{})
		transformed := make(map[string]interface{})

		transformedProjectId, err := expandComputeFutureReservationShareSettingsProjectMapProjectId(original["project_id"], d, config)
		if err != nil {
			return nil, err
		} else if val := reflect.ValueOf(transformedProjectId); val.IsValid() && !tpgresource.IsEmptyValue(val) {
			transformed["projectId"] = transformedProjectId
		}

		transformedId, err := tpgresource.ExpandString(original["id"], d, config)
		if err != nil {
			return nil, err
		}
		m[transformedId] = transformed
	}
	return m, nil
}

func expandComputeFutureReservationShareSettingsProjectMapProjectId(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandComputeFutureReservationNamePrefix(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandComputeFutureReservationPlanningStatus(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandComputeFutureReservationAutoDeleteAutoCreatedReservations(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandComputeFutureReservationSpecificReservationRequired(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandComputeFutureReservationReservationName(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandComputeFutureReservationDeploymentType(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandComputeFutureReservationReservationMode(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandComputeFutureReservationCommitmentInfo(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	l := v.([]interface{})
	if len(l) == 0 || l[0] == nil {
		return nil, nil
	}
	raw := l[0]
	original := raw.(map[string]interface{})
	transformed := make(map[string]interface{})

	transformedCommitmentPlan, err := expandComputeFutureReservationCommitmentInfoCommitmentPlan(original["commitment_plan"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedCommitmentPlan); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["commitmentPlan"] = transformedCommitmentPlan
	}

	transformedCommitmentName, err := expandComputeFutureReservationCommitmentInfoCommitmentName(original["commitment_name"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedCommitmentName); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["commitmentName"] = transformedCommitmentName
	}

	transformedPreviousCommitmentTerms, err := expandComputeFutureReservationCommitmentInfoPreviousCommitmentTerms(original["previous_commitment_terms"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedPreviousCommitmentTerms); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["previousCommitmentTerms"] = transformedPreviousCommitmentTerms
	}

	return transformed, nil
}

func expandComputeFutureReservationCommitmentInfoCommitmentPlan(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandComputeFutureReservationCommitmentInfoCommitmentName(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandComputeFutureReservationCommitmentInfoPreviousCommitmentTerms(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandComputeFutureReservationSchedulingType(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandComputeFutureReservationSpecificSkuProperties(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	l := v.([]interface{})
	if len(l) == 0 || l[0] == nil {
		return nil, nil
	}
	raw := l[0]
	original := raw.(map[string]interface{})
	transformed := make(map[string]interface{})

	transformedInstanceProperties, err := expandComputeFutureReservationSpecificSkuPropertiesInstanceProperties(original["instance_properties"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedInstanceProperties); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["instanceProperties"] = transformedInstanceProperties
	}

	transformedTotalCount, err := expandComputeFutureReservationSpecificSkuPropertiesTotalCount(original["total_count"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedTotalCount); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["totalCount"] = transformedTotalCount
	}

	transformedSourceInstanceTemplate, err := expandComputeFutureReservationSpecificSkuPropertiesSourceInstanceTemplate(original["source_instance_template"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedSourceInstanceTemplate); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["sourceInstanceTemplate"] = transformedSourceInstanceTemplate
	}

	return transformed, nil
}

func expandComputeFutureReservationSpecificSkuPropertiesInstanceProperties(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	l := v.([]interface{})
	if len(l) == 0 || l[0] == nil {
		return nil, nil
	}
	raw := l[0]
	original := raw.(map[string]interface{})
	transformed := make(map[string]interface{})

	transformedMachineType, err := expandComputeFutureReservationSpecificSkuPropertiesInstancePropertiesMachineType(original["machine_type"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedMachineType); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["machineType"] = transformedMachineType
	}

	transformedGuestAccelerators, err := expandComputeFutureReservationSpecificSkuPropertiesInstancePropertiesGuestAccelerators(original["guest_accelerators"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedGuestAccelerators); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["guestAccelerators"] = transformedGuestAccelerators
	}

	transformedMinCpuPlatform, err := expandComputeFutureReservationSpecificSkuPropertiesInstancePropertiesMinCpuPlatform(original["min_cpu_platform"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedMinCpuPlatform); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["minCpuPlatform"] = transformedMinCpuPlatform
	}

	transformedLocalSsds, err := expandComputeFutureReservationSpecificSkuPropertiesInstancePropertiesLocalSsds(original["local_ssds"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedLocalSsds); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["localSsds"] = transformedLocalSsds
	}

	transformedMaintenanceFreezeDurationHours, err := expandComputeFutureReservationSpecificSkuPropertiesInstancePropertiesMaintenanceFreezeDurationHours(original["maintenance_freeze_duration_hours"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedMaintenanceFreezeDurationHours); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["maintenanceFreezeDurationHours"] = transformedMaintenanceFreezeDurationHours
	}

	transformedLocationHint, err := expandComputeFutureReservationSpecificSkuPropertiesInstancePropertiesLocationHint(original["location_hint"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedLocationHint); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["locationHint"] = transformedLocationHint
	}

	transformedMaintenanceInterval, err := expandComputeFutureReservationSpecificSkuPropertiesInstancePropertiesMaintenanceInterval(original["maintenance_interval"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedMaintenanceInterval); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["maintenanceInterval"] = transformedMaintenanceInterval
	}

	return transformed, nil
}

func expandComputeFutureReservationSpecificSkuPropertiesInstancePropertiesMachineType(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandComputeFutureReservationSpecificSkuPropertiesInstancePropertiesGuestAccelerators(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	l := v.([]interface{})
	req := make([]interface{}, 0, len(l))
	for _, raw := range l {
		if raw == nil {
			continue
		}
		original := raw.(map[string]interface{})
		transformed := make(map[string]interface{})

		transformedAcceleratorType, err := expandComputeFutureReservationSpecificSkuPropertiesInstancePropertiesGuestAcceleratorsAcceleratorType(original["accelerator_type"], d, config)
		if err != nil {
			return nil, err
		} else if val := reflect.ValueOf(transformedAcceleratorType); val.IsValid() && !tpgresource.IsEmptyValue(val) {
			transformed["acceleratorType"] = transformedAcceleratorType
		}

		transformedAcceleratorCount, err := expandComputeFutureReservationSpecificSkuPropertiesInstancePropertiesGuestAcceleratorsAcceleratorCount(original["accelerator_count"], d, config)
		if err != nil {
			return nil, err
		} else if val := reflect.ValueOf(transformedAcceleratorCount); val.IsValid() && !tpgresource.IsEmptyValue(val) {
			transformed["acceleratorCount"] = transformedAcceleratorCount
		}

		req = append(req, transformed)
	}
	return req, nil
}

func expandComputeFutureReservationSpecificSkuPropertiesInstancePropertiesGuestAcceleratorsAcceleratorType(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandComputeFutureReservationSpecificSkuPropertiesInstancePropertiesGuestAcceleratorsAcceleratorCount(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandComputeFutureReservationSpecificSkuPropertiesInstancePropertiesMinCpuPlatform(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandComputeFutureReservationSpecificSkuPropertiesInstancePropertiesLocalSsds(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	l := v.([]interface{})
	req := make([]interface{}, 0, len(l))
	for _, raw := range l {
		if raw == nil {
			continue
		}
		original := raw.(map[string]interface{})
		transformed := make(map[string]interface{})

		transformedDiskSizeGb, err := expandComputeFutureReservationSpecificSkuPropertiesInstancePropertiesLocalSsdsDiskSizeGb(original["disk_size_gb"], d, config)
		if err != nil {
			return nil, err
		} else if val := reflect.ValueOf(transformedDiskSizeGb); val.IsValid() && !tpgresource.IsEmptyValue(val) {
			transformed["diskSizeGb"] = transformedDiskSizeGb
		}

		transformedInterface, err := expandComputeFutureReservationSpecificSkuPropertiesInstancePropertiesLocalSsdsInterface(original["interface"], d, config)
		if err != nil {
			return nil, err
		} else if val := reflect.ValueOf(transformedInterface); val.IsValid() && !tpgresource.IsEmptyValue(val) {
			transformed["interface"] = transformedInterface
		}

		req = append(req, transformed)
	}
	return req, nil
}

func expandComputeFutureReservationSpecificSkuPropertiesInstancePropertiesLocalSsdsDiskSizeGb(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandComputeFutureReservationSpecificSkuPropertiesInstancePropertiesLocalSsdsInterface(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandComputeFutureReservationSpecificSkuPropertiesInstancePropertiesMaintenanceFreezeDurationHours(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandComputeFutureReservationSpecificSkuPropertiesInstancePropertiesLocationHint(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandComputeFutureReservationSpecificSkuPropertiesInstancePropertiesMaintenanceInterval(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandComputeFutureReservationSpecificSkuPropertiesTotalCount(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandComputeFutureReservationSpecificSkuPropertiesSourceInstanceTemplate(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandComputeFutureReservationAutoCreatedReservationsDeleteTime(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandComputeFutureReservationAutoCreatedReservationsDuration(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	l := v.([]interface{})
	if len(l) == 0 || l[0] == nil {
		return nil, nil
	}
	raw := l[0]
	original := raw.(map[string]interface{})
	transformed := make(map[string]interface{})

	transformedSeconds, err := expandComputeFutureReservationAutoCreatedReservationsDurationSeconds(original["seconds"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedSeconds); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["seconds"] = transformedSeconds
	}

	transformedNanos, err := expandComputeFutureReservationAutoCreatedReservationsDurationNanos(original["nanos"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedNanos); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["nanos"] = transformedNanos
	}

	return transformed, nil
}

func expandComputeFutureReservationAutoCreatedReservationsDurationSeconds(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandComputeFutureReservationAutoCreatedReservationsDurationNanos(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandComputeFutureReservationName(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func resourceComputeFutureReservationUpdateEncoder(d *schema.ResourceData, meta interface{}, obj map[string]interface{}) (map[string]interface{}, error) {
	nameProp := d.Get("name")
	if v, ok := d.GetOkExists("name"); !tpgresource.IsEmptyValue(reflect.ValueOf(v)) && (ok || !reflect.DeepEqual(v, nameProp)) {
		obj["name"] = nameProp
	}
	return obj, nil
}
