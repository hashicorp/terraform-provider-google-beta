// Copyright (c) HashiCorp, Inc.
// SPDX-License-Identifier: MPL-2.0

// ----------------------------------------------------------------------------
//
//     ***     AUTO GENERATED CODE    ***    Type: MMv1     ***
//
// ----------------------------------------------------------------------------
//
//     This code is generated by Magic Modules using the following:
//
//     Configuration: https://github.com/GoogleCloudPlatform/magic-modules/tree/main/mmv1/products/compute/RegionResizeRequest.yaml
//     Template:      https://github.com/GoogleCloudPlatform/magic-modules/tree/main/mmv1/templates/terraform/resource.go.tmpl
//
//     DO NOT EDIT this file directly. Any changes made to this file will be
//     overwritten during the next generation cycle.
//
// ----------------------------------------------------------------------------

package compute

import (
	"fmt"
	"log"
	"net/http"
	"reflect"
	"time"

	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/customdiff"
	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/schema"

	"github.com/hashicorp/terraform-provider-google-beta/google-beta/tpgresource"
	transport_tpg "github.com/hashicorp/terraform-provider-google-beta/google-beta/transport"
)

func ResourceComputeRegionResizeRequest() *schema.Resource {
	return &schema.Resource{
		Create: resourceComputeRegionResizeRequestCreate,
		Read:   resourceComputeRegionResizeRequestRead,
		Delete: resourceComputeRegionResizeRequestDelete,

		Importer: &schema.ResourceImporter{
			State: resourceComputeRegionResizeRequestImport,
		},

		Timeouts: &schema.ResourceTimeout{
			Create: schema.DefaultTimeout(20 * time.Minute),
			Delete: schema.DefaultTimeout(20 * time.Minute),
		},

		CustomizeDiff: customdiff.All(
			tpgresource.DefaultProviderProject,
		),

		Schema: map[string]*schema.Schema{
			"instance_group_manager": {
				Type:             schema.TypeString,
				Required:         true,
				ForceNew:         true,
				DiffSuppressFunc: tpgresource.CompareSelfLinkOrResourceName,
				Description:      `The reference of the regional instance group manager this ResizeRequest is a part of.`,
			},
			"name": {
				Type:        schema.TypeString,
				Required:    true,
				ForceNew:    true,
				Description: `The name of this resize request. The name must be 1-63 characters long, and comply with RFC1035.`,
			},
			"resize_by": {
				Type:        schema.TypeInt,
				Required:    true,
				ForceNew:    true,
				Description: `The number of instances to be created by this resize request. The group's target size will be increased by this number.`,
			},
			"description": {
				Type:        schema.TypeString,
				Optional:    true,
				ForceNew:    true,
				Description: `An optional description of this resize-request.`,
			},
			"region": {
				Type:             schema.TypeString,
				Computed:         true,
				Optional:         true,
				ForceNew:         true,
				DiffSuppressFunc: tpgresource.CompareSelfLinkOrResourceName,
				Description:      `The reference of the compute region scoping this request. If it is not provided, the provider region is used.`,
			},
			"requested_run_duration": {
				Type:        schema.TypeList,
				Optional:    true,
				ForceNew:    true,
				Description: `Requested run duration for instances that will be created by this request. At the end of the run duration instances will be deleted.`,
				MaxItems:    1,
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						"seconds": {
							Type:        schema.TypeString,
							Required:    true,
							ForceNew:    true,
							Description: `Span of time at a resolution of a second. Must be from 600 to 604800 inclusive. Note: minimum and maximum allowed range for requestedRunDuration is 10 minutes (600 seconds) and 7 days(604800 seconds) correspondingly.`,
						},
						"nanos": {
							Type:        schema.TypeInt,
							Optional:    true,
							ForceNew:    true,
							Description: `Span of time that's a fraction of a second at nanosecond resolution. Durations less than one second are represented with a 0 seconds field and a positive nanos field. Must be from 0 to 999,999,999 inclusive.`,
						},
					},
				},
			},
			"creation_timestamp": {
				Type:        schema.TypeString,
				Computed:    true,
				Description: `The creation timestamp for this resize request in RFC3339 text format.`,
			},
			"state": {
				Type:        schema.TypeString,
				Computed:    true,
				Description: `Current state of the request.`,
			},
			"status": {
				Type:        schema.TypeList,
				Computed:    true,
				Description: `Status of the request.`,
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						"error": {
							Type:        schema.TypeList,
							Computed:    true,
							Description: `Fatal errors encountered during the queueing or provisioning phases of the ResizeRequest that caused the transition to the FAILED state. Contrary to the lastAttempt errors, this field is final and errors are never removed from here, as the ResizeRequest is not going to retry.`,
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{
									"errors": {
										Type:        schema.TypeList,
										Computed:    true,
										Description: `The array of errors encountered while processing this operation.`,
										Elem: &schema.Resource{
											Schema: map[string]*schema.Schema{
												"code": {
													Type:        schema.TypeString,
													Computed:    true,
													Description: `The error type identifier for this error.`,
												},
												"error_details": {
													Type:        schema.TypeList,
													Computed:    true,
													Description: `An array of messages that contain the error details. There is a set of defined message types to use for providing details.The syntax depends on the error code. For example, QuotaExceededInfo will have details when the error code is QUOTA_EXCEEDED.`,
													Elem: &schema.Resource{
														Schema: map[string]*schema.Schema{
															"error_info": {
																Type:        schema.TypeList,
																Computed:    true,
																Description: `A nested object resource.`,
																Elem: &schema.Resource{
																	Schema: map[string]*schema.Schema{
																		"domain": {
																			Type:        schema.TypeString,
																			Computed:    true,
																			Description: `The logical grouping to which the "reason" belongs. The error domain is typically the registered service name of the tool or product that generates the error. Example: "pubsub.googleapis.com".`,
																		},
																		"metadatas": {
																			Type:        schema.TypeMap,
																			Computed:    true,
																			Description: `Additional structured details about this error.`,
																			Elem:        &schema.Schema{Type: schema.TypeString},
																		},
																		"reason": {
																			Type:        schema.TypeString,
																			Computed:    true,
																			Description: `The reason of the error. This is a constant value that identifies the proximate cause of the error. Error reasons are unique within a particular domain of errors.`,
																		},
																	},
																},
															},
															"help": {
																Type:        schema.TypeList,
																Computed:    true,
																Description: `A nested object resource.`,
																Elem: &schema.Resource{
																	Schema: map[string]*schema.Schema{
																		"links": {
																			Type:        schema.TypeList,
																			Computed:    true,
																			Description: `A nested object resource.`,
																			Elem: &schema.Resource{
																				Schema: map[string]*schema.Schema{
																					"description": {
																						Type:        schema.TypeString,
																						Computed:    true,
																						Description: `Describes what the link offers.`,
																					},
																					"url": {
																						Type:        schema.TypeString,
																						Computed:    true,
																						Description: `The URL of the link.`,
																					},
																				},
																			},
																		},
																	},
																},
															},
															"localized_message": {
																Type:        schema.TypeList,
																Computed:    true,
																Description: `A nested object resource.`,
																Elem: &schema.Resource{
																	Schema: map[string]*schema.Schema{
																		"locale": {
																			Type:        schema.TypeString,
																			Computed:    true,
																			Description: `The locale used following the specification defined at https://www.rfc-editor.org/rfc/bcp/bcp47.txt. Examples are: "en-US", "fr-CH", "es-MX"`,
																		},
																		"message": {
																			Type:        schema.TypeString,
																			Computed:    true,
																			Description: `The localized error message in the above locale.`,
																		},
																	},
																},
															},
															"quota_info": {
																Type:        schema.TypeList,
																Computed:    true,
																Description: `A nested object resource.`,
																Elem: &schema.Resource{
																	Schema: map[string]*schema.Schema{
																		"dimensions": {
																			Type:        schema.TypeMap,
																			Computed:    true,
																			Description: `The map holding related quota dimensions`,
																			Elem:        &schema.Schema{Type: schema.TypeString},
																		},
																		"future_limit": {
																			Type:        schema.TypeInt,
																			Computed:    true,
																			Description: `Future quota limit being rolled out. The limit's unit depends on the quota type or metric.`,
																		},
																		"limit": {
																			Type:        schema.TypeInt,
																			Computed:    true,
																			Description: `Current effective quota limit. The limit's unit depends on the quota type or metric.`,
																		},
																		"limit_name": {
																			Type:        schema.TypeString,
																			Computed:    true,
																			Description: `The name of the quota limit.`,
																		},
																		"metric_name": {
																			Type:        schema.TypeString,
																			Computed:    true,
																			Description: `The Compute Engine quota metric name.`,
																		},
																		"rollout_status": {
																			Type:        schema.TypeString,
																			Computed:    true,
																			Description: `Rollout status of the future quota limit.`,
																		},
																	},
																},
															},
														},
													},
												},
												"location": {
													Type:        schema.TypeString,
													Computed:    true,
													Description: `Indicates the field in the request that caused the error. This property is optional.`,
												},
												"message": {
													Type:        schema.TypeString,
													Computed:    true,
													Description: `An optional, human-readable error message.`,
												},
											},
										},
									},
								},
							},
						},
						"last_attempt": {
							Type:        schema.TypeList,
							Computed:    true,
							Description: `Information about the last attempt to fulfill the request. The value is temporary since the ResizeRequest can retry, as long as it's still active and the last attempt value can either be cleared or replaced with a different error. Since ResizeRequest retries infrequently, the value may be stale and no longer show an active problem. The value is cleared when ResizeRequest transitions to the final state (becomes inactive). If the final state is FAILED the error describing it will be storred in the "error" field only.`,
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{
									"error": {
										Type:        schema.TypeList,
										Computed:    true,
										Description: `Fatal errors encountered during the queueing or provisioning phases of the ResizeRequest that caused the transition to the FAILED state. Contrary to the lastAttempt errors, this field is final and errors are never removed from here, as the ResizeRequest is not going to retry.`,
										Elem: &schema.Resource{
											Schema: map[string]*schema.Schema{
												"errors": {
													Type:        schema.TypeList,
													Computed:    true,
													Description: `The array of errors encountered while processing this operation.`,
													Elem: &schema.Resource{
														Schema: map[string]*schema.Schema{
															"code": {
																Type:        schema.TypeString,
																Computed:    true,
																Description: `The error type identifier for this error.`,
															},
															"error_details": {
																Type:        schema.TypeList,
																Computed:    true,
																Description: `An array of messages that contain the error details. There is a set of defined message types to use for providing details.The syntax depends on the error code. For example, QuotaExceededInfo will have details when the error code is QUOTA_EXCEEDED.`,
																Elem: &schema.Resource{
																	Schema: map[string]*schema.Schema{
																		"error_info": {
																			Type:        schema.TypeList,
																			Computed:    true,
																			Description: `A nested object resource.`,
																			Elem: &schema.Resource{
																				Schema: map[string]*schema.Schema{
																					"domain": {
																						Type:        schema.TypeString,
																						Computed:    true,
																						Description: `The logical grouping to which the "reason" belongs. The error domain is typically the registered service name of the tool or product that generates the error. Example: "pubsub.googleapis.com".`,
																					},
																					"metadatas": {
																						Type:        schema.TypeMap,
																						Computed:    true,
																						Description: `Additional structured details about this error.`,
																						Elem:        &schema.Schema{Type: schema.TypeString},
																					},
																					"reason": {
																						Type:        schema.TypeString,
																						Computed:    true,
																						Description: `The reason of the error. This is a constant value that identifies the proximate cause of the error. Error reasons are unique within a particular domain of errors.`,
																					},
																				},
																			},
																		},
																		"help": {
																			Type:        schema.TypeList,
																			Computed:    true,
																			Description: `A nested object resource.`,
																			Elem: &schema.Resource{
																				Schema: map[string]*schema.Schema{
																					"links": {
																						Type:        schema.TypeList,
																						Computed:    true,
																						Description: `A nested object resource.`,
																						Elem: &schema.Resource{
																							Schema: map[string]*schema.Schema{
																								"description": {
																									Type:        schema.TypeString,
																									Computed:    true,
																									Description: `Describes what the link offers.`,
																								},
																								"url": {
																									Type:        schema.TypeString,
																									Computed:    true,
																									Description: `The URL of the link.`,
																								},
																							},
																						},
																					},
																				},
																			},
																		},
																		"localized_message": {
																			Type:        schema.TypeList,
																			Computed:    true,
																			Description: `A nested object resource.`,
																			Elem: &schema.Resource{
																				Schema: map[string]*schema.Schema{
																					"locale": {
																						Type:        schema.TypeString,
																						Computed:    true,
																						Description: `The locale used following the specification defined at https://www.rfc-editor.org/rfc/bcp/bcp47.txt. Examples are: "en-US", "fr-CH", "es-MX"`,
																					},
																					"message": {
																						Type:        schema.TypeString,
																						Computed:    true,
																						Description: `The localized error message in the above locale.`,
																					},
																				},
																			},
																		},
																		"quota_info": {
																			Type:        schema.TypeList,
																			Computed:    true,
																			Description: `A nested object resource.`,
																			Elem: &schema.Resource{
																				Schema: map[string]*schema.Schema{
																					"dimensions": {
																						Type:        schema.TypeMap,
																						Computed:    true,
																						Description: `The map holding related quota dimensions`,
																						Elem:        &schema.Schema{Type: schema.TypeString},
																					},
																					"future_limit": {
																						Type:        schema.TypeInt,
																						Computed:    true,
																						Description: `Future quota limit being rolled out. The limit's unit depends on the quota type or metric.`,
																					},
																					"limit": {
																						Type:        schema.TypeInt,
																						Computed:    true,
																						Description: `Current effective quota limit. The limit's unit depends on the quota type or metric.`,
																					},
																					"limit_name": {
																						Type:        schema.TypeString,
																						Computed:    true,
																						Description: `The name of the quota limit.`,
																					},
																					"metric_name": {
																						Type:        schema.TypeString,
																						Computed:    true,
																						Description: `The Compute Engine quota metric name.`,
																					},
																					"rollout_status": {
																						Type:        schema.TypeString,
																						Computed:    true,
																						Description: `Rollout status of the future quota limit.`,
																					},
																				},
																			},
																		},
																	},
																},
															},
															"location": {
																Type:        schema.TypeString,
																Computed:    true,
																Description: `Indicates the field in the request that caused the error. This property is optional.`,
															},
															"message": {
																Type:        schema.TypeString,
																Computed:    true,
																Description: `An optional, human-readable error message.`,
															},
														},
													},
												},
											},
										},
									},
								},
							},
						},
					},
				},
			},
			"project": {
				Type:     schema.TypeString,
				Optional: true,
				Computed: true,
				ForceNew: true,
			},
		},
		UseJSONNumber: true,
	}
}

func resourceComputeRegionResizeRequestCreate(d *schema.ResourceData, meta interface{}) error {
	config := meta.(*transport_tpg.Config)
	userAgent, err := tpgresource.GenerateUserAgentString(d, config.UserAgent)
	if err != nil {
		return err
	}

	obj := make(map[string]interface{})
	nameProp, err := expandComputeRegionResizeRequestName(d.Get("name"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("name"); !tpgresource.IsEmptyValue(reflect.ValueOf(nameProp)) && (ok || !reflect.DeepEqual(v, nameProp)) {
		obj["name"] = nameProp
	}
	descriptionProp, err := expandComputeRegionResizeRequestDescription(d.Get("description"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("description"); !tpgresource.IsEmptyValue(reflect.ValueOf(descriptionProp)) && (ok || !reflect.DeepEqual(v, descriptionProp)) {
		obj["description"] = descriptionProp
	}
	resizeByProp, err := expandComputeRegionResizeRequestResizeBy(d.Get("resize_by"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("resize_by"); !tpgresource.IsEmptyValue(reflect.ValueOf(resizeByProp)) && (ok || !reflect.DeepEqual(v, resizeByProp)) {
		obj["resizeBy"] = resizeByProp
	}
	requestedRunDurationProp, err := expandComputeRegionResizeRequestRequestedRunDuration(d.Get("requested_run_duration"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("requested_run_duration"); !tpgresource.IsEmptyValue(reflect.ValueOf(requestedRunDurationProp)) && (ok || !reflect.DeepEqual(v, requestedRunDurationProp)) {
		obj["requestedRunDuration"] = requestedRunDurationProp
	}
	regionProp, err := expandComputeRegionResizeRequestRegion(d.Get("region"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("region"); !tpgresource.IsEmptyValue(reflect.ValueOf(regionProp)) && (ok || !reflect.DeepEqual(v, regionProp)) {
		obj["region"] = regionProp
	}

	url, err := tpgresource.ReplaceVars(d, config, "{{ComputeBasePath}}projects/{{project}}/regions/{{region}}/instanceGroupManagers/{{instance_group_manager}}/resizeRequests")
	if err != nil {
		return err
	}

	log.Printf("[DEBUG] Creating new RegionResizeRequest: %#v", obj)
	billingProject := ""

	project, err := tpgresource.GetProject(d, config)
	if err != nil {
		return fmt.Errorf("Error fetching project for RegionResizeRequest: %s", err)
	}
	billingProject = project

	// err == nil indicates that the billing_project value was found
	if bp, err := tpgresource.GetBillingProject(d, config); err == nil {
		billingProject = bp
	}

	headers := make(http.Header)
	res, err := transport_tpg.SendRequest(transport_tpg.SendRequestOptions{
		Config:    config,
		Method:    "POST",
		Project:   billingProject,
		RawURL:    url,
		UserAgent: userAgent,
		Body:      obj,
		Timeout:   d.Timeout(schema.TimeoutCreate),
		Headers:   headers,
	})
	if err != nil {
		return fmt.Errorf("Error creating RegionResizeRequest: %s", err)
	}

	// Store the ID now
	id, err := tpgresource.ReplaceVars(d, config, "projects/{{project}}/regions/{{region}}/instanceGroupManagers/{{instance_group_manager}}/resizeRequests/{{name}}")
	if err != nil {
		return fmt.Errorf("Error constructing id: %s", err)
	}
	d.SetId(id)

	err = ComputeOperationWaitTime(
		config, res, project, "Creating RegionResizeRequest", userAgent,
		d.Timeout(schema.TimeoutCreate))

	if err != nil {
		// The resource didn't actually create
		d.SetId("")
		return fmt.Errorf("Error waiting to create RegionResizeRequest: %s", err)
	}

	log.Printf("[DEBUG] Finished creating RegionResizeRequest %q: %#v", d.Id(), res)

	return resourceComputeRegionResizeRequestRead(d, meta)
}

func resourceComputeRegionResizeRequestRead(d *schema.ResourceData, meta interface{}) error {
	config := meta.(*transport_tpg.Config)
	userAgent, err := tpgresource.GenerateUserAgentString(d, config.UserAgent)
	if err != nil {
		return err
	}

	url, err := tpgresource.ReplaceVars(d, config, "{{ComputeBasePath}}projects/{{project}}/regions/{{region}}/instanceGroupManagers/{{instance_group_manager}}/resizeRequests/{{name}}")
	if err != nil {
		return err
	}

	billingProject := ""

	project, err := tpgresource.GetProject(d, config)
	if err != nil {
		return fmt.Errorf("Error fetching project for RegionResizeRequest: %s", err)
	}
	billingProject = project

	// err == nil indicates that the billing_project value was found
	if bp, err := tpgresource.GetBillingProject(d, config); err == nil {
		billingProject = bp
	}

	headers := make(http.Header)
	res, err := transport_tpg.SendRequest(transport_tpg.SendRequestOptions{
		Config:    config,
		Method:    "GET",
		Project:   billingProject,
		RawURL:    url,
		UserAgent: userAgent,
		Headers:   headers,
	})
	if err != nil {
		return transport_tpg.HandleNotFoundError(err, d, fmt.Sprintf("ComputeRegionResizeRequest %q", d.Id()))
	}

	if err := d.Set("project", project); err != nil {
		return fmt.Errorf("Error reading RegionResizeRequest: %s", err)
	}

	if err := d.Set("creation_timestamp", flattenComputeRegionResizeRequestCreationTimestamp(res["creationTimestamp"], d, config)); err != nil {
		return fmt.Errorf("Error reading RegionResizeRequest: %s", err)
	}
	if err := d.Set("state", flattenComputeRegionResizeRequestState(res["state"], d, config)); err != nil {
		return fmt.Errorf("Error reading RegionResizeRequest: %s", err)
	}
	if err := d.Set("name", flattenComputeRegionResizeRequestName(res["name"], d, config)); err != nil {
		return fmt.Errorf("Error reading RegionResizeRequest: %s", err)
	}
	if err := d.Set("description", flattenComputeRegionResizeRequestDescription(res["description"], d, config)); err != nil {
		return fmt.Errorf("Error reading RegionResizeRequest: %s", err)
	}
	if err := d.Set("resize_by", flattenComputeRegionResizeRequestResizeBy(res["resizeBy"], d, config)); err != nil {
		return fmt.Errorf("Error reading RegionResizeRequest: %s", err)
	}
	if err := d.Set("requested_run_duration", flattenComputeRegionResizeRequestRequestedRunDuration(res["requestedRunDuration"], d, config)); err != nil {
		return fmt.Errorf("Error reading RegionResizeRequest: %s", err)
	}
	if err := d.Set("status", flattenComputeRegionResizeRequestStatus(res["status"], d, config)); err != nil {
		return fmt.Errorf("Error reading RegionResizeRequest: %s", err)
	}
	if err := d.Set("region", flattenComputeRegionResizeRequestRegion(res["region"], d, config)); err != nil {
		return fmt.Errorf("Error reading RegionResizeRequest: %s", err)
	}

	return nil
}

func resourceComputeRegionResizeRequestDelete(d *schema.ResourceData, meta interface{}) error {
	config := meta.(*transport_tpg.Config)
	userAgent, err := tpgresource.GenerateUserAgentString(d, config.UserAgent)
	if err != nil {
		return err
	}

	// Get project id
	project, err := tpgresource.GetProject(d, config)
	if err != nil {
		return fmt.Errorf("Error fetching project for resize request: %s", err)
	}

	// Get cancel url
	var cancelUrl string
	cancelUrl, err = tpgresource.ReplaceVars(d, config, "{{ComputeBasePath}}projects/{{project}}/regions/{{region}}/instanceGroupManagers/{{instance_group_manager}}/resizeRequests/{{name}}/cancel")

	if err != nil {
		return err
	}

	// Get delete url
	var deleteUrl string
	deleteUrl, err = tpgresource.ReplaceVars(d, config, "{{ComputeBasePath}}projects/{{project}}/regions/{{region}}/instanceGroupManagers/{{instance_group_manager}}/resizeRequests/{{name}}")
	if err != nil {
		return err
	}

	// If a resize request is in the CREATING or ACCEPTED state, it must be canceled before it can be deleted. If a resize request is NOT in any of the mentioned state, it can be directly deleted.
	if d.Get("state") == "CREATING" || d.Get("state") == "ACCEPTED" {
		// cancel resize request
		res, err := transport_tpg.SendRequest(transport_tpg.SendRequestOptions{
			Config:    config,
			Method:    "POST",
			Project:   project,
			RawURL:    cancelUrl,
			UserAgent: userAgent,
			Timeout:   d.Timeout(schema.TimeoutDelete),
		})

		if err != nil {
			return transport_tpg.HandleNotFoundError(err, d, "ResizeRequest")
		}

		err = ComputeOperationWaitTime(
			config, res, project, "Cancelling the resize request", userAgent,
			d.Timeout(schema.TimeoutDelete))

		if err != nil {
			return err
		}
	}

	// delete resize request
	res, err := transport_tpg.SendRequest(transport_tpg.SendRequestOptions{
		Config:    config,
		Method:    "DELETE",
		Project:   project,
		RawURL:    deleteUrl,
		UserAgent: userAgent,
		Timeout:   d.Timeout(schema.TimeoutDelete),
	})

	err = ComputeOperationWaitTime(
		config, res, project, "Deleting the resize request", userAgent,
		d.Timeout(schema.TimeoutDelete))

	if err != nil {
		return err
	}
	return nil
}

func resourceComputeRegionResizeRequestImport(d *schema.ResourceData, meta interface{}) ([]*schema.ResourceData, error) {
	config := meta.(*transport_tpg.Config)
	if err := tpgresource.ParseImportId([]string{
		"^projects/(?P<project>[^/]+)/regions/(?P<region>[^/]+)/instanceGroupManagers/(?P<instance_group_manager>[^/]+)/resizeRequests/(?P<name>[^/]+)$",
		"^(?P<project>[^/]+)/(?P<region>[^/]+)/(?P<instance_group_manager>[^/]+)/(?P<name>[^/]+)$",
		"^(?P<region>[^/]+)/(?P<instance_group_manager>[^/]+)/(?P<name>[^/]+)$",
		"^(?P<instance_group_manager>[^/]+)/(?P<name>[^/]+)$",
	}, d, config); err != nil {
		return nil, err
	}

	// Replace import id for the resource id
	id, err := tpgresource.ReplaceVars(d, config, "projects/{{project}}/regions/{{region}}/instanceGroupManagers/{{instance_group_manager}}/resizeRequests/{{name}}")
	if err != nil {
		return nil, fmt.Errorf("Error constructing id: %s", err)
	}
	d.SetId(id)

	return []*schema.ResourceData{d}, nil
}

func flattenComputeRegionResizeRequestCreationTimestamp(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenComputeRegionResizeRequestState(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenComputeRegionResizeRequestName(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenComputeRegionResizeRequestDescription(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenComputeRegionResizeRequestResizeBy(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	// Handles the string fixed64 format
	if strVal, ok := v.(string); ok {
		if intVal, err := tpgresource.StringToFixed64(strVal); err == nil {
			return intVal
		}
	}

	// number values are represented as float64
	if floatVal, ok := v.(float64); ok {
		intVal := int(floatVal)
		return intVal
	}

	return v // let terraform core handle it otherwise
}

func flattenComputeRegionResizeRequestRequestedRunDuration(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return nil
	}
	original := v.(map[string]interface{})
	if len(original) == 0 {
		return nil
	}
	transformed := make(map[string]interface{})
	transformed["seconds"] =
		flattenComputeRegionResizeRequestRequestedRunDurationSeconds(original["seconds"], d, config)
	transformed["nanos"] =
		flattenComputeRegionResizeRequestRequestedRunDurationNanos(original["nanos"], d, config)
	return []interface{}{transformed}
}
func flattenComputeRegionResizeRequestRequestedRunDurationSeconds(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenComputeRegionResizeRequestRequestedRunDurationNanos(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	// Handles the string fixed64 format
	if strVal, ok := v.(string); ok {
		if intVal, err := tpgresource.StringToFixed64(strVal); err == nil {
			return intVal
		}
	}

	// number values are represented as float64
	if floatVal, ok := v.(float64); ok {
		intVal := int(floatVal)
		return intVal
	}

	return v // let terraform core handle it otherwise
}

func flattenComputeRegionResizeRequestStatus(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return nil
	}
	original := v.(map[string]interface{})
	if len(original) == 0 {
		return nil
	}
	transformed := make(map[string]interface{})
	transformed["error"] =
		flattenComputeRegionResizeRequestStatusError(original["error"], d, config)
	transformed["last_attempt"] =
		flattenComputeRegionResizeRequestStatusLastAttempt(original["lastAttempt"], d, config)
	return []interface{}{transformed}
}
func flattenComputeRegionResizeRequestStatusError(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return nil
	}
	original := v.(map[string]interface{})
	if len(original) == 0 {
		return nil
	}
	transformed := make(map[string]interface{})
	transformed["errors"] =
		flattenComputeRegionResizeRequestStatusErrorErrors(original["errors"], d, config)
	return []interface{}{transformed}
}
func flattenComputeRegionResizeRequestStatusErrorErrors(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return v
	}
	l := v.([]interface{})
	transformed := make([]interface{}, 0, len(l))
	for _, raw := range l {
		original := raw.(map[string]interface{})
		if len(original) < 1 {
			// Do not include empty json objects coming back from the api
			continue
		}
		transformed = append(transformed, map[string]interface{}{
			"code":          flattenComputeRegionResizeRequestStatusErrorErrorsCode(original["code"], d, config),
			"location":      flattenComputeRegionResizeRequestStatusErrorErrorsLocation(original["location"], d, config),
			"message":       flattenComputeRegionResizeRequestStatusErrorErrorsMessage(original["message"], d, config),
			"error_details": flattenComputeRegionResizeRequestStatusErrorErrorsErrorDetails(original["errorDetails"], d, config),
		})
	}
	return transformed
}
func flattenComputeRegionResizeRequestStatusErrorErrorsCode(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenComputeRegionResizeRequestStatusErrorErrorsLocation(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenComputeRegionResizeRequestStatusErrorErrorsMessage(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenComputeRegionResizeRequestStatusErrorErrorsErrorDetails(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return v
	}
	l := v.([]interface{})
	transformed := make([]interface{}, 0, len(l))
	for _, raw := range l {
		original := raw.(map[string]interface{})
		if len(original) < 1 {
			// Do not include empty json objects coming back from the api
			continue
		}
		transformed = append(transformed, map[string]interface{}{
			"error_info":        flattenComputeRegionResizeRequestStatusErrorErrorsErrorDetailsErrorInfo(original["errorInfo"], d, config),
			"quota_info":        flattenComputeRegionResizeRequestStatusErrorErrorsErrorDetailsQuotaInfo(original["quotaInfo"], d, config),
			"help":              flattenComputeRegionResizeRequestStatusErrorErrorsErrorDetailsHelp(original["help"], d, config),
			"localized_message": flattenComputeRegionResizeRequestStatusErrorErrorsErrorDetailsLocalizedMessage(original["localizedMessage"], d, config),
		})
	}
	return transformed
}
func flattenComputeRegionResizeRequestStatusErrorErrorsErrorDetailsErrorInfo(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return nil
	}
	original := v.(map[string]interface{})
	if len(original) == 0 {
		return nil
	}
	transformed := make(map[string]interface{})
	transformed["reason"] =
		flattenComputeRegionResizeRequestStatusErrorErrorsErrorDetailsErrorInfoReason(original["reason"], d, config)
	transformed["domain"] =
		flattenComputeRegionResizeRequestStatusErrorErrorsErrorDetailsErrorInfoDomain(original["domain"], d, config)
	transformed["metadatas"] =
		flattenComputeRegionResizeRequestStatusErrorErrorsErrorDetailsErrorInfoMetadatas(original["metadatas"], d, config)
	return []interface{}{transformed}
}
func flattenComputeRegionResizeRequestStatusErrorErrorsErrorDetailsErrorInfoReason(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenComputeRegionResizeRequestStatusErrorErrorsErrorDetailsErrorInfoDomain(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenComputeRegionResizeRequestStatusErrorErrorsErrorDetailsErrorInfoMetadatas(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenComputeRegionResizeRequestStatusErrorErrorsErrorDetailsQuotaInfo(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return nil
	}
	original := v.(map[string]interface{})
	if len(original) == 0 {
		return nil
	}
	transformed := make(map[string]interface{})
	transformed["metric_name"] =
		flattenComputeRegionResizeRequestStatusErrorErrorsErrorDetailsQuotaInfoMetricName(original["metricName"], d, config)
	transformed["limit_name"] =
		flattenComputeRegionResizeRequestStatusErrorErrorsErrorDetailsQuotaInfoLimitName(original["limitName"], d, config)
	transformed["dimensions"] =
		flattenComputeRegionResizeRequestStatusErrorErrorsErrorDetailsQuotaInfoDimensions(original["dimensions"], d, config)
	transformed["limit"] =
		flattenComputeRegionResizeRequestStatusErrorErrorsErrorDetailsQuotaInfoLimit(original["limit"], d, config)
	transformed["future_limit"] =
		flattenComputeRegionResizeRequestStatusErrorErrorsErrorDetailsQuotaInfoFutureLimit(original["futureLimit"], d, config)
	transformed["rollout_status"] =
		flattenComputeRegionResizeRequestStatusErrorErrorsErrorDetailsQuotaInfoRolloutStatus(original["rolloutStatus"], d, config)
	return []interface{}{transformed}
}
func flattenComputeRegionResizeRequestStatusErrorErrorsErrorDetailsQuotaInfoMetricName(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenComputeRegionResizeRequestStatusErrorErrorsErrorDetailsQuotaInfoLimitName(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenComputeRegionResizeRequestStatusErrorErrorsErrorDetailsQuotaInfoDimensions(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenComputeRegionResizeRequestStatusErrorErrorsErrorDetailsQuotaInfoLimit(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	// Handles the string fixed64 format
	if strVal, ok := v.(string); ok {
		if intVal, err := tpgresource.StringToFixed64(strVal); err == nil {
			return intVal
		}
	}

	// number values are represented as float64
	if floatVal, ok := v.(float64); ok {
		intVal := int(floatVal)
		return intVal
	}

	return v // let terraform core handle it otherwise
}

func flattenComputeRegionResizeRequestStatusErrorErrorsErrorDetailsQuotaInfoFutureLimit(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	// Handles the string fixed64 format
	if strVal, ok := v.(string); ok {
		if intVal, err := tpgresource.StringToFixed64(strVal); err == nil {
			return intVal
		}
	}

	// number values are represented as float64
	if floatVal, ok := v.(float64); ok {
		intVal := int(floatVal)
		return intVal
	}

	return v // let terraform core handle it otherwise
}

func flattenComputeRegionResizeRequestStatusErrorErrorsErrorDetailsQuotaInfoRolloutStatus(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenComputeRegionResizeRequestStatusErrorErrorsErrorDetailsHelp(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return nil
	}
	original := v.(map[string]interface{})
	if len(original) == 0 {
		return nil
	}
	transformed := make(map[string]interface{})
	transformed["links"] =
		flattenComputeRegionResizeRequestStatusErrorErrorsErrorDetailsHelpLinks(original["links"], d, config)
	return []interface{}{transformed}
}
func flattenComputeRegionResizeRequestStatusErrorErrorsErrorDetailsHelpLinks(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return nil
	}
	original := v.(map[string]interface{})
	if len(original) == 0 {
		return nil
	}
	transformed := make(map[string]interface{})
	transformed["description"] =
		flattenComputeRegionResizeRequestStatusErrorErrorsErrorDetailsHelpLinksDescription(original["description"], d, config)
	transformed["url"] =
		flattenComputeRegionResizeRequestStatusErrorErrorsErrorDetailsHelpLinksUrl(original["url"], d, config)
	return []interface{}{transformed}
}
func flattenComputeRegionResizeRequestStatusErrorErrorsErrorDetailsHelpLinksDescription(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenComputeRegionResizeRequestStatusErrorErrorsErrorDetailsHelpLinksUrl(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenComputeRegionResizeRequestStatusErrorErrorsErrorDetailsLocalizedMessage(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return nil
	}
	original := v.(map[string]interface{})
	if len(original) == 0 {
		return nil
	}
	transformed := make(map[string]interface{})
	transformed["locale"] =
		flattenComputeRegionResizeRequestStatusErrorErrorsErrorDetailsLocalizedMessageLocale(original["locale"], d, config)
	transformed["message"] =
		flattenComputeRegionResizeRequestStatusErrorErrorsErrorDetailsLocalizedMessageMessage(original["message"], d, config)
	return []interface{}{transformed}
}
func flattenComputeRegionResizeRequestStatusErrorErrorsErrorDetailsLocalizedMessageLocale(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenComputeRegionResizeRequestStatusErrorErrorsErrorDetailsLocalizedMessageMessage(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenComputeRegionResizeRequestStatusLastAttempt(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return nil
	}
	original := v.(map[string]interface{})
	if len(original) == 0 {
		return nil
	}
	transformed := make(map[string]interface{})
	transformed["error"] =
		flattenComputeRegionResizeRequestStatusLastAttemptError(original["error"], d, config)
	return []interface{}{transformed}
}
func flattenComputeRegionResizeRequestStatusLastAttemptError(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return nil
	}
	original := v.(map[string]interface{})
	if len(original) == 0 {
		return nil
	}
	transformed := make(map[string]interface{})
	transformed["errors"] =
		flattenComputeRegionResizeRequestStatusLastAttemptErrorErrors(original["errors"], d, config)
	return []interface{}{transformed}
}
func flattenComputeRegionResizeRequestStatusLastAttemptErrorErrors(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return v
	}
	l := v.([]interface{})
	transformed := make([]interface{}, 0, len(l))
	for _, raw := range l {
		original := raw.(map[string]interface{})
		if len(original) < 1 {
			// Do not include empty json objects coming back from the api
			continue
		}
		transformed = append(transformed, map[string]interface{}{
			"code":          flattenComputeRegionResizeRequestStatusLastAttemptErrorErrorsCode(original["code"], d, config),
			"location":      flattenComputeRegionResizeRequestStatusLastAttemptErrorErrorsLocation(original["location"], d, config),
			"message":       flattenComputeRegionResizeRequestStatusLastAttemptErrorErrorsMessage(original["message"], d, config),
			"error_details": flattenComputeRegionResizeRequestStatusLastAttemptErrorErrorsErrorDetails(original["errorDetails"], d, config),
		})
	}
	return transformed
}
func flattenComputeRegionResizeRequestStatusLastAttemptErrorErrorsCode(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenComputeRegionResizeRequestStatusLastAttemptErrorErrorsLocation(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenComputeRegionResizeRequestStatusLastAttemptErrorErrorsMessage(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenComputeRegionResizeRequestStatusLastAttemptErrorErrorsErrorDetails(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return v
	}
	l := v.([]interface{})
	transformed := make([]interface{}, 0, len(l))
	for _, raw := range l {
		original := raw.(map[string]interface{})
		if len(original) < 1 {
			// Do not include empty json objects coming back from the api
			continue
		}
		transformed = append(transformed, map[string]interface{}{
			"error_info":        flattenComputeRegionResizeRequestStatusLastAttemptErrorErrorsErrorDetailsErrorInfo(original["errorInfo"], d, config),
			"quota_info":        flattenComputeRegionResizeRequestStatusLastAttemptErrorErrorsErrorDetailsQuotaInfo(original["quotaInfo"], d, config),
			"help":              flattenComputeRegionResizeRequestStatusLastAttemptErrorErrorsErrorDetailsHelp(original["help"], d, config),
			"localized_message": flattenComputeRegionResizeRequestStatusLastAttemptErrorErrorsErrorDetailsLocalizedMessage(original["localizedMessage"], d, config),
		})
	}
	return transformed
}
func flattenComputeRegionResizeRequestStatusLastAttemptErrorErrorsErrorDetailsErrorInfo(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return nil
	}
	original := v.(map[string]interface{})
	if len(original) == 0 {
		return nil
	}
	transformed := make(map[string]interface{})
	transformed["reason"] =
		flattenComputeRegionResizeRequestStatusLastAttemptErrorErrorsErrorDetailsErrorInfoReason(original["reason"], d, config)
	transformed["domain"] =
		flattenComputeRegionResizeRequestStatusLastAttemptErrorErrorsErrorDetailsErrorInfoDomain(original["domain"], d, config)
	transformed["metadatas"] =
		flattenComputeRegionResizeRequestStatusLastAttemptErrorErrorsErrorDetailsErrorInfoMetadatas(original["metadatas"], d, config)
	return []interface{}{transformed}
}
func flattenComputeRegionResizeRequestStatusLastAttemptErrorErrorsErrorDetailsErrorInfoReason(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenComputeRegionResizeRequestStatusLastAttemptErrorErrorsErrorDetailsErrorInfoDomain(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenComputeRegionResizeRequestStatusLastAttemptErrorErrorsErrorDetailsErrorInfoMetadatas(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenComputeRegionResizeRequestStatusLastAttemptErrorErrorsErrorDetailsQuotaInfo(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return nil
	}
	original := v.(map[string]interface{})
	if len(original) == 0 {
		return nil
	}
	transformed := make(map[string]interface{})
	transformed["metric_name"] =
		flattenComputeRegionResizeRequestStatusLastAttemptErrorErrorsErrorDetailsQuotaInfoMetricName(original["metricName"], d, config)
	transformed["limit_name"] =
		flattenComputeRegionResizeRequestStatusLastAttemptErrorErrorsErrorDetailsQuotaInfoLimitName(original["limitName"], d, config)
	transformed["dimensions"] =
		flattenComputeRegionResizeRequestStatusLastAttemptErrorErrorsErrorDetailsQuotaInfoDimensions(original["dimensions"], d, config)
	transformed["limit"] =
		flattenComputeRegionResizeRequestStatusLastAttemptErrorErrorsErrorDetailsQuotaInfoLimit(original["limit"], d, config)
	transformed["future_limit"] =
		flattenComputeRegionResizeRequestStatusLastAttemptErrorErrorsErrorDetailsQuotaInfoFutureLimit(original["futureLimit"], d, config)
	transformed["rollout_status"] =
		flattenComputeRegionResizeRequestStatusLastAttemptErrorErrorsErrorDetailsQuotaInfoRolloutStatus(original["rolloutStatus"], d, config)
	return []interface{}{transformed}
}
func flattenComputeRegionResizeRequestStatusLastAttemptErrorErrorsErrorDetailsQuotaInfoMetricName(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenComputeRegionResizeRequestStatusLastAttemptErrorErrorsErrorDetailsQuotaInfoLimitName(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenComputeRegionResizeRequestStatusLastAttemptErrorErrorsErrorDetailsQuotaInfoDimensions(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenComputeRegionResizeRequestStatusLastAttemptErrorErrorsErrorDetailsQuotaInfoLimit(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	// Handles the string fixed64 format
	if strVal, ok := v.(string); ok {
		if intVal, err := tpgresource.StringToFixed64(strVal); err == nil {
			return intVal
		}
	}

	// number values are represented as float64
	if floatVal, ok := v.(float64); ok {
		intVal := int(floatVal)
		return intVal
	}

	return v // let terraform core handle it otherwise
}

func flattenComputeRegionResizeRequestStatusLastAttemptErrorErrorsErrorDetailsQuotaInfoFutureLimit(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	// Handles the string fixed64 format
	if strVal, ok := v.(string); ok {
		if intVal, err := tpgresource.StringToFixed64(strVal); err == nil {
			return intVal
		}
	}

	// number values are represented as float64
	if floatVal, ok := v.(float64); ok {
		intVal := int(floatVal)
		return intVal
	}

	return v // let terraform core handle it otherwise
}

func flattenComputeRegionResizeRequestStatusLastAttemptErrorErrorsErrorDetailsQuotaInfoRolloutStatus(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenComputeRegionResizeRequestStatusLastAttemptErrorErrorsErrorDetailsHelp(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return nil
	}
	original := v.(map[string]interface{})
	if len(original) == 0 {
		return nil
	}
	transformed := make(map[string]interface{})
	transformed["links"] =
		flattenComputeRegionResizeRequestStatusLastAttemptErrorErrorsErrorDetailsHelpLinks(original["links"], d, config)
	return []interface{}{transformed}
}
func flattenComputeRegionResizeRequestStatusLastAttemptErrorErrorsErrorDetailsHelpLinks(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return nil
	}
	original := v.(map[string]interface{})
	if len(original) == 0 {
		return nil
	}
	transformed := make(map[string]interface{})
	transformed["description"] =
		flattenComputeRegionResizeRequestStatusLastAttemptErrorErrorsErrorDetailsHelpLinksDescription(original["description"], d, config)
	transformed["url"] =
		flattenComputeRegionResizeRequestStatusLastAttemptErrorErrorsErrorDetailsHelpLinksUrl(original["url"], d, config)
	return []interface{}{transformed}
}
func flattenComputeRegionResizeRequestStatusLastAttemptErrorErrorsErrorDetailsHelpLinksDescription(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenComputeRegionResizeRequestStatusLastAttemptErrorErrorsErrorDetailsHelpLinksUrl(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenComputeRegionResizeRequestStatusLastAttemptErrorErrorsErrorDetailsLocalizedMessage(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return nil
	}
	original := v.(map[string]interface{})
	if len(original) == 0 {
		return nil
	}
	transformed := make(map[string]interface{})
	transformed["locale"] =
		flattenComputeRegionResizeRequestStatusLastAttemptErrorErrorsErrorDetailsLocalizedMessageLocale(original["locale"], d, config)
	transformed["message"] =
		flattenComputeRegionResizeRequestStatusLastAttemptErrorErrorsErrorDetailsLocalizedMessageMessage(original["message"], d, config)
	return []interface{}{transformed}
}
func flattenComputeRegionResizeRequestStatusLastAttemptErrorErrorsErrorDetailsLocalizedMessageLocale(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenComputeRegionResizeRequestStatusLastAttemptErrorErrorsErrorDetailsLocalizedMessageMessage(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenComputeRegionResizeRequestRegion(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return v
	}
	return tpgresource.GetResourceNameFromSelfLink(v.(string))
}

func expandComputeRegionResizeRequestName(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandComputeRegionResizeRequestDescription(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandComputeRegionResizeRequestResizeBy(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandComputeRegionResizeRequestRequestedRunDuration(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	l := v.([]interface{})
	if len(l) == 0 || l[0] == nil {
		return nil, nil
	}
	raw := l[0]
	original := raw.(map[string]interface{})
	transformed := make(map[string]interface{})

	transformedSeconds, err := expandComputeRegionResizeRequestRequestedRunDurationSeconds(original["seconds"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedSeconds); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["seconds"] = transformedSeconds
	}

	transformedNanos, err := expandComputeRegionResizeRequestRequestedRunDurationNanos(original["nanos"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedNanos); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["nanos"] = transformedNanos
	}

	return transformed, nil
}

func expandComputeRegionResizeRequestRequestedRunDurationSeconds(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandComputeRegionResizeRequestRequestedRunDurationNanos(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandComputeRegionResizeRequestRegion(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	f, err := tpgresource.ParseGlobalFieldValue("regions", v.(string), "project", d, config, true)
	if err != nil {
		return nil, fmt.Errorf("Invalid value for region: %s", err)
	}
	return f.RelativeLink(), nil
}
