// Copyright (c) HashiCorp, Inc.
// SPDX-License-Identifier: MPL-2.0

// ----------------------------------------------------------------------------
//
//     ***     AUTO GENERATED CODE    ***    Type: MMv1     ***
//
// ----------------------------------------------------------------------------
//
//     This code is generated by Magic Modules using the following:
//
//     Configuration: https://github.com/GoogleCloudPlatform/magic-modules/tree/main/mmv1/products/compute/RolloutPlan.yaml
//     Template:      https://github.com/GoogleCloudPlatform/magic-modules/tree/main/mmv1/templates/terraform/resource.go.tmpl
//
//     DO NOT EDIT this file directly. Any changes made to this file will be
//     overwritten during the next generation cycle.
//
// ----------------------------------------------------------------------------

package compute

import (
	"bytes"
	"context"
	"encoding/base64"
	"encoding/json"
	"fmt"
	"log"
	"net/http"
	"reflect"
	"regexp"
	"slices"
	"sort"
	"strconv"
	"strings"
	"time"

	"github.com/hashicorp/errwrap"
	"github.com/hashicorp/go-cty/cty"
	"github.com/hashicorp/terraform-plugin-sdk/v2/diag"
	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/customdiff"
	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/id"
	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/logging"
	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/retry"
	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/schema"
	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/structure"
	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/validation"
	"github.com/hashicorp/terraform-plugin-sdk/v2/terraform"

	"github.com/hashicorp/terraform-provider-google-beta/google-beta/registry"
	"github.com/hashicorp/terraform-provider-google-beta/google-beta/tpgresource"
	transport_tpg "github.com/hashicorp/terraform-provider-google-beta/google-beta/transport"
	"github.com/hashicorp/terraform-provider-google-beta/google-beta/verify"

	"google.golang.org/api/googleapi"
)

var (
	_ = bytes.Clone
	_ = context.WithCancel
	_ = base64.NewDecoder
	_ = json.Marshal
	_ = fmt.Sprintf
	_ = log.Print
	_ = http.Get
	_ = reflect.ValueOf
	_ = regexp.Match
	_ = slices.Min([]int{1})
	_ = sort.IntSlice{}
	_ = strconv.Atoi
	_ = strings.Trim
	_ = time.Now
	_ = errwrap.Wrap
	_ = cty.BoolVal
	_ = diag.Diagnostic{}
	_ = customdiff.All
	_ = id.UniqueId
	_ = logging.LogLevel
	_ = retry.Retry
	_ = schema.Noop
	_ = validation.All
	_ = structure.ExpandJsonFromString
	_ = terraform.State{}
	_ = tpgresource.SetLabels
	_ = transport_tpg.Config{}
	_ = verify.ValidateEnum
	_ = googleapi.Error{}
)

func init() {
	registry.Schema{
		Name:        "google_compute_rollout_plan",
		ProductName: "compute",
		Type:        registry.SchemaTypeResource,
		Schema:      ResourceComputeRolloutPlan(),
	}.Register()
}

func ResourceComputeRolloutPlan() *schema.Resource {
	return &schema.Resource{
		Create: resourceComputeRolloutPlanCreate,
		Read:   resourceComputeRolloutPlanRead,
		Delete: resourceComputeRolloutPlanDelete,

		Importer: &schema.ResourceImporter{
			State: resourceComputeRolloutPlanImport,
		},

		Timeouts: &schema.ResourceTimeout{
			Create: schema.DefaultTimeout(20 * time.Minute),
			Delete: schema.DefaultTimeout(20 * time.Minute),
		},

		CustomizeDiff: customdiff.All(
			tpgresource.DefaultProviderProject,
		),

		Schema: map[string]*schema.Schema{
			"name": {
				Type:     schema.TypeString,
				Required: true,
				ForceNew: true,
				Description: `Name of the resource. Provided by the client when the resource is created.
The name must be 1-63 characters long, and comply with RFC1035.`,
			},
			"waves": {
				Type:        schema.TypeList,
				Required:    true,
				ForceNew:    true,
				Description: `The waves included in this rollout plan.`,
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						"selectors": {
							Type:     schema.TypeList,
							Required: true,
							ForceNew: true,
							Description: `The selectors for this wave. There is a logical AND between each selector
defined in a wave, so a resource must satisfy the criteria of *all* the
specified selectors to be in scope for the wave.`,
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{
									"location_selector": {
										Type:        schema.TypeList,
										Optional:    true,
										ForceNew:    true,
										Description: `Roll out to resources by location.`,
										MaxItems:    1,
										Elem: &schema.Resource{
											Schema: map[string]*schema.Schema{
												"included_locations": {
													Type:        schema.TypeList,
													Optional:    true,
													ForceNew:    true,
													Description: `Example: "us-central1-a"`,
													Elem: &schema.Schema{
														Type: schema.TypeString,
													},
												},
											},
										},
									},
									"resource_hierarchy_selector": {
										Type:        schema.TypeList,
										Optional:    true,
										ForceNew:    true,
										Description: `Roll out to resources by Cloud Resource Manager resource hierarchy nodes such as projects, folders, orgs.`,
										MaxItems:    1,
										Elem: &schema.Resource{
											Schema: map[string]*schema.Schema{
												"included_folders": {
													Type:        schema.TypeList,
													Optional:    true,
													ForceNew:    true,
													Description: `Format: "folders/{folder_id}"`,
													Elem: &schema.Schema{
														Type: schema.TypeString,
													},
												},
												"included_organizations": {
													Type:        schema.TypeList,
													Optional:    true,
													ForceNew:    true,
													Description: `Format: "organizations/{organization_id}"`,
													Elem: &schema.Schema{
														Type: schema.TypeString,
													},
												},
												"included_projects": {
													Type:        schema.TypeList,
													Optional:    true,
													ForceNew:    true,
													Description: `Format: "projects/{project_id}"`,
													Elem: &schema.Schema{
														Type: schema.TypeString,
													},
												},
											},
										},
									},
								},
							},
						},
						"validation": {
							Type:        schema.TypeList,
							Required:    true,
							ForceNew:    true,
							Description: `The validation to be performed before progressing to the next wave.`,
							MaxItems:    1,
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{
									"type": {
										Type:     schema.TypeString,
										Required: true,
										ForceNew: true,
										Description: `The type of the validation. Possible values:
"manual": The system waits for an end-user approval API before progressing to the next wave.
"time": The system waits for a user specified duration before progressing to the next wave.`,
									},
									"time_based_validation_metadata": {
										Type:        schema.TypeList,
										Optional:    true,
										ForceNew:    true,
										Description: `Metadata required if type = "time".`,
										MaxItems:    1,
										Elem: &schema.Resource{
											Schema: map[string]*schema.Schema{
												"wait_duration": {
													Type:     schema.TypeString,
													Optional: true,
													ForceNew: true,
													Description: `The duration that the system waits in between waves. This wait starts
after all changes in the wave are rolled out.`,
												},
											},
										},
									},
								},
							},
						},
						"display_name": {
							Type:        schema.TypeString,
							Optional:    true,
							ForceNew:    true,
							Description: `The display name of this wave of the rollout plan.`,
						},
						"orchestration_options": {
							Type:        schema.TypeList,
							Optional:    true,
							ForceNew:    true,
							Description: `Options to control the pace of orchestration of a wave.`,
							MaxItems:    1,
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{
									"delays": {
										Type:        schema.TypeList,
										Optional:    true,
										ForceNew:    true,
										Description: `Delays, if any, to be added between batches of projects.`,
										Elem: &schema.Resource{
											Schema: map[string]*schema.Schema{
												"delimiter": {
													Type:         schema.TypeString,
													Optional:     true,
													ForceNew:     true,
													ValidateFunc: verify.ValidateEnum([]string{"DELIMITER_UNSPECIFIED", "DELIMITER_LOCATION", "DELIMITER_BATCH", ""}),
													Description:  `Controls whether the delay should only be added between batches of projects corresponding to different locations, or also between batches of projects corresponding to the same location. Possible values: ["DELIMITER_UNSPECIFIED", "DELIMITER_LOCATION", "DELIMITER_BATCH"]`,
												},
												"duration": {
													Type:        schema.TypeString,
													Optional:    true,
													ForceNew:    true,
													Description: `The duration of the delay, if any, to be added between batches of projects.`,
												},
												"type": {
													Type:         schema.TypeString,
													Optional:     true,
													ForceNew:     true,
													ValidateFunc: verify.ValidateEnum([]string{"TYPE_UNSPECIFIED", "TYPE_OFFSET", "TYPE_MINIMUM", ""}),
													Description:  `Controls whether the specified duration is to be added at the end of each batch, or if the total processing time for each batch will be padded if needed to meet the specified duration. Possible values: ["TYPE_UNSPECIFIED", "TYPE_OFFSET", "TYPE_MINIMUM"]`,
												},
											},
										},
									},
									"max_concurrent_locations": {
										Type:        schema.TypeInt,
										Optional:    true,
										ForceNew:    true,
										Description: `Maximum number of locations to be orchestrated in parallel.`,
									},
									"max_concurrent_resources_per_location": {
										Type:        schema.TypeInt,
										Optional:    true,
										ForceNew:    true,
										Description: `Maximum number of resources to be orchestrated per location in parallel.`,
									},
								},
							},
						},
						"number": {
							Type:        schema.TypeInt,
							Computed:    true,
							Description: `The wave number.`,
						},
					},
				},
			},
			"description": {
				Type:        schema.TypeString,
				Optional:    true,
				ForceNew:    true,
				Description: `An optional description of this resource.`,
			},
			"location_scope": {
				Type:         schema.TypeString,
				Optional:     true,
				ForceNew:     true,
				ValidateFunc: verify.ValidateEnum([]string{"LOCATION_SCOPE_UNSPECIFIED", "ZONAL", "REGIONAL", ""}),
				Description:  `The location scope of the rollout plan. Possible values: ["LOCATION_SCOPE_UNSPECIFIED", "ZONAL", "REGIONAL"]`,
			},
			"project": {
				Type:     schema.TypeString,
				Optional: true,
				Computed: true,
				ForceNew: true,
			},
			"self_link": {
				Type:     schema.TypeString,
				Computed: true,
			},
		},
		UseJSONNumber: true,
	}
}

func resourceComputeRolloutPlanCreate(d *schema.ResourceData, meta interface{}) error {
	config := meta.(*transport_tpg.Config)
	userAgent, err := tpgresource.GenerateUserAgentString(d, config.UserAgent)
	if err != nil {
		return err
	}

	obj := make(map[string]interface{})
	descriptionProp, err := expandComputeRolloutPlanDescription(d.Get("description"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("description"); !tpgresource.IsEmptyValue(reflect.ValueOf(descriptionProp)) && (ok || !reflect.DeepEqual(v, descriptionProp)) {
		obj["description"] = descriptionProp
	}
	locationScopeProp, err := expandComputeRolloutPlanLocationScope(d.Get("location_scope"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("location_scope"); !tpgresource.IsEmptyValue(reflect.ValueOf(locationScopeProp)) && (ok || !reflect.DeepEqual(v, locationScopeProp)) {
		obj["locationScope"] = locationScopeProp
	}
	wavesProp, err := expandComputeRolloutPlanWaves(d.Get("waves"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("waves"); !tpgresource.IsEmptyValue(reflect.ValueOf(wavesProp)) && (ok || !reflect.DeepEqual(v, wavesProp)) {
		obj["waves"] = wavesProp
	}
	nameProp, err := expandComputeRolloutPlanName(d.Get("name"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("name"); !tpgresource.IsEmptyValue(reflect.ValueOf(nameProp)) && (ok || !reflect.DeepEqual(v, nameProp)) {
		obj["name"] = nameProp
	}

	url, err := tpgresource.ReplaceVars(d, config, "{{ComputeBasePath}}projects/{{project}}/global/rolloutPlans")
	if err != nil {
		return err
	}

	log.Printf("[DEBUG] Creating new RolloutPlan: %#v", obj)
	billingProject := ""

	project, err := tpgresource.GetProject(d, config)
	if err != nil {
		return fmt.Errorf("Error fetching project for RolloutPlan: %s", err)
	}
	billingProject = project

	// err == nil indicates that the billing_project value was found
	if bp, err := tpgresource.GetBillingProject(d, config); err == nil {
		billingProject = bp
	}

	headers := make(http.Header)
	res, err := transport_tpg.SendRequest(transport_tpg.SendRequestOptions{
		Config:    config,
		Method:    "POST",
		Project:   billingProject,
		RawURL:    url,
		UserAgent: userAgent,
		Body:      obj,
		Timeout:   d.Timeout(schema.TimeoutCreate),
		Headers:   headers,
	})
	if err != nil {
		return fmt.Errorf("Error creating RolloutPlan: %s", err)
	}

	// Store the ID now
	id, err := tpgresource.ReplaceVars(d, config, "projects/{{project}}/global/rolloutPlans/{{name}}")
	if err != nil {
		return fmt.Errorf("Error constructing id: %s", err)
	}
	d.SetId(id)

	err = ComputeOperationWaitTime(
		config, res, project, "Creating RolloutPlan", userAgent,
		d.Timeout(schema.TimeoutCreate))

	if err != nil {
		// The resource didn't actually create
		d.SetId("")
		return fmt.Errorf("Error waiting to create RolloutPlan: %s", err)
	}

	log.Printf("[DEBUG] Finished creating RolloutPlan %q: %#v", d.Id(), res)

	return resourceComputeRolloutPlanRead(d, meta)
}

func resourceComputeRolloutPlanRead(d *schema.ResourceData, meta interface{}) error {
	config := meta.(*transport_tpg.Config)
	userAgent, err := tpgresource.GenerateUserAgentString(d, config.UserAgent)
	if err != nil {
		return err
	}

	url, err := tpgresource.ReplaceVars(d, config, "{{ComputeBasePath}}projects/{{project}}/global/rolloutPlans/{{name}}")
	if err != nil {
		return err
	}

	billingProject := ""

	project, err := tpgresource.GetProject(d, config)
	if err != nil {
		return fmt.Errorf("Error fetching project for RolloutPlan: %s", err)
	}
	billingProject = project

	// err == nil indicates that the billing_project value was found
	if bp, err := tpgresource.GetBillingProject(d, config); err == nil {
		billingProject = bp
	}

	headers := make(http.Header)
	res, err := transport_tpg.SendRequest(transport_tpg.SendRequestOptions{
		Config:    config,
		Method:    "GET",
		Project:   billingProject,
		RawURL:    url,
		UserAgent: userAgent,
		Headers:   headers,
	})
	if err != nil {
		return transport_tpg.HandleNotFoundError(err, d, fmt.Sprintf("ComputeRolloutPlan %q", d.Id()))
	}

	if err := d.Set("project", project); err != nil {
		return fmt.Errorf("Error reading RolloutPlan: %s", err)
	}

	if err := d.Set("description", flattenComputeRolloutPlanDescription(res["description"], d, config)); err != nil {
		return fmt.Errorf("Error reading RolloutPlan: %s", err)
	}
	if err := d.Set("location_scope", flattenComputeRolloutPlanLocationScope(res["locationScope"], d, config)); err != nil {
		return fmt.Errorf("Error reading RolloutPlan: %s", err)
	}
	if err := d.Set("waves", flattenComputeRolloutPlanWaves(res["waves"], d, config)); err != nil {
		return fmt.Errorf("Error reading RolloutPlan: %s", err)
	}
	if err := d.Set("name", flattenComputeRolloutPlanName(res["name"], d, config)); err != nil {
		return fmt.Errorf("Error reading RolloutPlan: %s", err)
	}
	if err := d.Set("self_link", tpgresource.ConvertSelfLinkToV1(res["selfLink"].(string))); err != nil {
		return fmt.Errorf("Error reading RolloutPlan: %s", err)
	}

	return nil
}

func resourceComputeRolloutPlanDelete(d *schema.ResourceData, meta interface{}) error {
	config := meta.(*transport_tpg.Config)
	userAgent, err := tpgresource.GenerateUserAgentString(d, config.UserAgent)
	if err != nil {
		return err
	}

	billingProject := ""

	project, err := tpgresource.GetProject(d, config)
	if err != nil {
		return fmt.Errorf("Error fetching project for RolloutPlan: %s", err)
	}
	billingProject = project

	url, err := tpgresource.ReplaceVars(d, config, "{{ComputeBasePath}}projects/{{project}}/global/rolloutPlans/{{name}}")
	if err != nil {
		return err
	}

	var obj map[string]interface{}

	// err == nil indicates that the billing_project value was found
	if bp, err := tpgresource.GetBillingProject(d, config); err == nil {
		billingProject = bp
	}

	headers := make(http.Header)

	log.Printf("[DEBUG] Deleting RolloutPlan %q", d.Id())
	res, err := transport_tpg.SendRequest(transport_tpg.SendRequestOptions{
		Config:    config,
		Method:    "DELETE",
		Project:   billingProject,
		RawURL:    url,
		UserAgent: userAgent,
		Body:      obj,
		Timeout:   d.Timeout(schema.TimeoutDelete),
		Headers:   headers,
	})
	if err != nil {
		return transport_tpg.HandleNotFoundError(err, d, "RolloutPlan")
	}

	err = ComputeOperationWaitTime(
		config, res, project, "Deleting RolloutPlan", userAgent,
		d.Timeout(schema.TimeoutDelete))

	if err != nil {
		return err
	}

	log.Printf("[DEBUG] Finished deleting RolloutPlan %q: %#v", d.Id(), res)
	return nil
}

func resourceComputeRolloutPlanImport(d *schema.ResourceData, meta interface{}) ([]*schema.ResourceData, error) {
	config := meta.(*transport_tpg.Config)
	if err := tpgresource.ParseImportId([]string{
		"^projects/(?P<project>[^/]+)/global/rolloutPlans/(?P<name>[^/]+)$",
		"^(?P<project>[^/]+)/(?P<name>[^/]+)$",
		"^(?P<name>[^/]+)$",
	}, d, config); err != nil {
		return nil, err
	}

	// Replace import id for the resource id
	id, err := tpgresource.ReplaceVars(d, config, "projects/{{project}}/global/rolloutPlans/{{name}}")
	if err != nil {
		return nil, fmt.Errorf("Error constructing id: %s", err)
	}
	d.SetId(id)

	return []*schema.ResourceData{d}, nil
}

func flattenComputeRolloutPlanDescription(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenComputeRolloutPlanLocationScope(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenComputeRolloutPlanWaves(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return v
	}
	l := v.([]interface{})
	transformed := make([]interface{}, 0, len(l))
	for _, raw := range l {
		original := raw.(map[string]interface{})
		if len(original) < 1 {
			// Do not include empty json objects coming back from the api
			continue
		}
		transformed = append(transformed, map[string]interface{}{
			"display_name":          flattenComputeRolloutPlanWavesDisplayName(original["displayName"], d, config),
			"number":                flattenComputeRolloutPlanWavesNumber(original["number"], d, config),
			"selectors":             flattenComputeRolloutPlanWavesSelectors(original["selectors"], d, config),
			"validation":            flattenComputeRolloutPlanWavesValidation(original["validation"], d, config),
			"orchestration_options": flattenComputeRolloutPlanWavesOrchestrationOptions(original["orchestrationOptions"], d, config),
		})
	}
	return transformed
}
func flattenComputeRolloutPlanWavesDisplayName(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenComputeRolloutPlanWavesNumber(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	// Handles the string fixed64 format
	if strVal, ok := v.(string); ok {
		if intVal, err := tpgresource.StringToFixed64(strVal); err == nil {
			return intVal
		}
	}

	// number values are represented as float64
	if floatVal, ok := v.(float64); ok {
		intVal := int(floatVal)
		return intVal
	}

	return v // let terraform core handle it otherwise
}

func flattenComputeRolloutPlanWavesSelectors(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return v
	}
	l := v.([]interface{})
	transformed := make([]interface{}, 0, len(l))
	for _, raw := range l {
		original := raw.(map[string]interface{})
		if len(original) < 1 {
			// Do not include empty json objects coming back from the api
			continue
		}
		transformed = append(transformed, map[string]interface{}{
			"resource_hierarchy_selector": flattenComputeRolloutPlanWavesSelectorsResourceHierarchySelector(original["resourceHierarchySelector"], d, config),
			"location_selector":           flattenComputeRolloutPlanWavesSelectorsLocationSelector(original["locationSelector"], d, config),
		})
	}
	return transformed
}
func flattenComputeRolloutPlanWavesSelectorsResourceHierarchySelector(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return nil
	}
	original := v.(map[string]interface{})
	if len(original) == 0 {
		return nil
	}
	transformed := make(map[string]interface{})
	transformed["included_organizations"] =
		flattenComputeRolloutPlanWavesSelectorsResourceHierarchySelectorIncludedOrganizations(original["includedOrganizations"], d, config)
	transformed["included_folders"] =
		flattenComputeRolloutPlanWavesSelectorsResourceHierarchySelectorIncludedFolders(original["includedFolders"], d, config)
	transformed["included_projects"] =
		flattenComputeRolloutPlanWavesSelectorsResourceHierarchySelectorIncludedProjects(original["includedProjects"], d, config)
	return []interface{}{transformed}
}
func flattenComputeRolloutPlanWavesSelectorsResourceHierarchySelectorIncludedOrganizations(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenComputeRolloutPlanWavesSelectorsResourceHierarchySelectorIncludedFolders(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenComputeRolloutPlanWavesSelectorsResourceHierarchySelectorIncludedProjects(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenComputeRolloutPlanWavesSelectorsLocationSelector(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return nil
	}
	original := v.(map[string]interface{})
	if len(original) == 0 {
		return nil
	}
	transformed := make(map[string]interface{})
	transformed["included_locations"] =
		flattenComputeRolloutPlanWavesSelectorsLocationSelectorIncludedLocations(original["includedLocations"], d, config)
	return []interface{}{transformed}
}
func flattenComputeRolloutPlanWavesSelectorsLocationSelectorIncludedLocations(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenComputeRolloutPlanWavesValidation(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return nil
	}
	original := v.(map[string]interface{})
	if len(original) == 0 {
		return nil
	}
	transformed := make(map[string]interface{})
	transformed["type"] =
		flattenComputeRolloutPlanWavesValidationType(original["type"], d, config)
	transformed["time_based_validation_metadata"] =
		flattenComputeRolloutPlanWavesValidationTimeBasedValidationMetadata(original["timeBasedValidationMetadata"], d, config)
	return []interface{}{transformed}
}
func flattenComputeRolloutPlanWavesValidationType(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenComputeRolloutPlanWavesValidationTimeBasedValidationMetadata(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return nil
	}
	original := v.(map[string]interface{})
	if len(original) == 0 {
		return nil
	}
	transformed := make(map[string]interface{})
	transformed["wait_duration"] =
		flattenComputeRolloutPlanWavesValidationTimeBasedValidationMetadataWaitDuration(original["waitDuration"], d, config)
	return []interface{}{transformed}
}
func flattenComputeRolloutPlanWavesValidationTimeBasedValidationMetadataWaitDuration(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenComputeRolloutPlanWavesOrchestrationOptions(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return nil
	}
	original := v.(map[string]interface{})
	if len(original) == 0 {
		return nil
	}
	transformed := make(map[string]interface{})
	transformed["max_concurrent_locations"] =
		flattenComputeRolloutPlanWavesOrchestrationOptionsMaxConcurrentLocations(original["maxConcurrentLocations"], d, config)
	transformed["max_concurrent_resources_per_location"] =
		flattenComputeRolloutPlanWavesOrchestrationOptionsMaxConcurrentResourcesPerLocation(original["maxConcurrentResourcesPerLocation"], d, config)
	transformed["delays"] =
		flattenComputeRolloutPlanWavesOrchestrationOptionsDelays(original["delays"], d, config)
	return []interface{}{transformed}
}
func flattenComputeRolloutPlanWavesOrchestrationOptionsMaxConcurrentLocations(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	// Handles the string fixed64 format
	if strVal, ok := v.(string); ok {
		if intVal, err := tpgresource.StringToFixed64(strVal); err == nil {
			return intVal
		}
	}

	// number values are represented as float64
	if floatVal, ok := v.(float64); ok {
		intVal := int(floatVal)
		return intVal
	}

	return v // let terraform core handle it otherwise
}

func flattenComputeRolloutPlanWavesOrchestrationOptionsMaxConcurrentResourcesPerLocation(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	// Handles the string fixed64 format
	if strVal, ok := v.(string); ok {
		if intVal, err := tpgresource.StringToFixed64(strVal); err == nil {
			return intVal
		}
	}

	// number values are represented as float64
	if floatVal, ok := v.(float64); ok {
		intVal := int(floatVal)
		return intVal
	}

	return v // let terraform core handle it otherwise
}

func flattenComputeRolloutPlanWavesOrchestrationOptionsDelays(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return v
	}
	l := v.([]interface{})
	transformed := make([]interface{}, 0, len(l))
	for _, raw := range l {
		original := raw.(map[string]interface{})
		if len(original) < 1 {
			// Do not include empty json objects coming back from the api
			continue
		}
		transformed = append(transformed, map[string]interface{}{
			"duration":  flattenComputeRolloutPlanWavesOrchestrationOptionsDelaysDuration(original["duration"], d, config),
			"delimiter": flattenComputeRolloutPlanWavesOrchestrationOptionsDelaysDelimiter(original["delimiter"], d, config),
			"type":      flattenComputeRolloutPlanWavesOrchestrationOptionsDelaysType(original["type"], d, config),
		})
	}
	return transformed
}
func flattenComputeRolloutPlanWavesOrchestrationOptionsDelaysDuration(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenComputeRolloutPlanWavesOrchestrationOptionsDelaysDelimiter(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenComputeRolloutPlanWavesOrchestrationOptionsDelaysType(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenComputeRolloutPlanName(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func expandComputeRolloutPlanDescription(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandComputeRolloutPlanLocationScope(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandComputeRolloutPlanWaves(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	if v == nil {
		return nil, nil
	}
	l := v.([]interface{})
	req := make([]interface{}, 0, len(l))
	for _, raw := range l {
		if raw == nil {
			continue
		}
		original := raw.(map[string]interface{})
		transformed := make(map[string]interface{})

		transformedDisplayName, err := expandComputeRolloutPlanWavesDisplayName(original["display_name"], d, config)
		if err != nil {
			return nil, err
		} else if val := reflect.ValueOf(transformedDisplayName); val.IsValid() && !tpgresource.IsEmptyValue(val) {
			transformed["displayName"] = transformedDisplayName
		}

		transformedNumber, err := expandComputeRolloutPlanWavesNumber(original["number"], d, config)
		if err != nil {
			return nil, err
		} else if val := reflect.ValueOf(transformedNumber); val.IsValid() && !tpgresource.IsEmptyValue(val) {
			transformed["number"] = transformedNumber
		}

		transformedSelectors, err := expandComputeRolloutPlanWavesSelectors(original["selectors"], d, config)
		if err != nil {
			return nil, err
		} else if val := reflect.ValueOf(transformedSelectors); val.IsValid() && !tpgresource.IsEmptyValue(val) {
			transformed["selectors"] = transformedSelectors
		}

		transformedValidation, err := expandComputeRolloutPlanWavesValidation(original["validation"], d, config)
		if err != nil {
			return nil, err
		} else if val := reflect.ValueOf(transformedValidation); val.IsValid() && !tpgresource.IsEmptyValue(val) {
			transformed["validation"] = transformedValidation
		}

		transformedOrchestrationOptions, err := expandComputeRolloutPlanWavesOrchestrationOptions(original["orchestration_options"], d, config)
		if err != nil {
			return nil, err
		} else if val := reflect.ValueOf(transformedOrchestrationOptions); val.IsValid() && !tpgresource.IsEmptyValue(val) {
			transformed["orchestrationOptions"] = transformedOrchestrationOptions
		}

		req = append(req, transformed)
	}
	return req, nil
}

func expandComputeRolloutPlanWavesDisplayName(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandComputeRolloutPlanWavesNumber(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandComputeRolloutPlanWavesSelectors(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	if v == nil {
		return nil, nil
	}
	l := v.([]interface{})
	req := make([]interface{}, 0, len(l))
	for _, raw := range l {
		if raw == nil {
			continue
		}
		original := raw.(map[string]interface{})
		transformed := make(map[string]interface{})

		transformedResourceHierarchySelector, err := expandComputeRolloutPlanWavesSelectorsResourceHierarchySelector(original["resource_hierarchy_selector"], d, config)
		if err != nil {
			return nil, err
		} else if val := reflect.ValueOf(transformedResourceHierarchySelector); val.IsValid() && !tpgresource.IsEmptyValue(val) {
			transformed["resourceHierarchySelector"] = transformedResourceHierarchySelector
		}

		transformedLocationSelector, err := expandComputeRolloutPlanWavesSelectorsLocationSelector(original["location_selector"], d, config)
		if err != nil {
			return nil, err
		} else if val := reflect.ValueOf(transformedLocationSelector); val.IsValid() && !tpgresource.IsEmptyValue(val) {
			transformed["locationSelector"] = transformedLocationSelector
		}

		req = append(req, transformed)
	}
	return req, nil
}

func expandComputeRolloutPlanWavesSelectorsResourceHierarchySelector(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	if v == nil {
		return nil, nil
	}
	l := v.([]interface{})
	if len(l) == 0 || l[0] == nil {
		return nil, nil
	}
	raw := l[0]
	original := raw.(map[string]interface{})
	transformed := make(map[string]interface{})

	transformedIncludedOrganizations, err := expandComputeRolloutPlanWavesSelectorsResourceHierarchySelectorIncludedOrganizations(original["included_organizations"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedIncludedOrganizations); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["includedOrganizations"] = transformedIncludedOrganizations
	}

	transformedIncludedFolders, err := expandComputeRolloutPlanWavesSelectorsResourceHierarchySelectorIncludedFolders(original["included_folders"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedIncludedFolders); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["includedFolders"] = transformedIncludedFolders
	}

	transformedIncludedProjects, err := expandComputeRolloutPlanWavesSelectorsResourceHierarchySelectorIncludedProjects(original["included_projects"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedIncludedProjects); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["includedProjects"] = transformedIncludedProjects
	}

	return transformed, nil
}

func expandComputeRolloutPlanWavesSelectorsResourceHierarchySelectorIncludedOrganizations(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandComputeRolloutPlanWavesSelectorsResourceHierarchySelectorIncludedFolders(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandComputeRolloutPlanWavesSelectorsResourceHierarchySelectorIncludedProjects(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandComputeRolloutPlanWavesSelectorsLocationSelector(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	if v == nil {
		return nil, nil
	}
	l := v.([]interface{})
	if len(l) == 0 || l[0] == nil {
		return nil, nil
	}
	raw := l[0]
	original := raw.(map[string]interface{})
	transformed := make(map[string]interface{})

	transformedIncludedLocations, err := expandComputeRolloutPlanWavesSelectorsLocationSelectorIncludedLocations(original["included_locations"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedIncludedLocations); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["includedLocations"] = transformedIncludedLocations
	}

	return transformed, nil
}

func expandComputeRolloutPlanWavesSelectorsLocationSelectorIncludedLocations(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandComputeRolloutPlanWavesValidation(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	if v == nil {
		return nil, nil
	}
	l := v.([]interface{})
	if len(l) == 0 || l[0] == nil {
		return nil, nil
	}
	raw := l[0]
	original := raw.(map[string]interface{})
	transformed := make(map[string]interface{})

	transformedType, err := expandComputeRolloutPlanWavesValidationType(original["type"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedType); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["type"] = transformedType
	}

	transformedTimeBasedValidationMetadata, err := expandComputeRolloutPlanWavesValidationTimeBasedValidationMetadata(original["time_based_validation_metadata"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedTimeBasedValidationMetadata); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["timeBasedValidationMetadata"] = transformedTimeBasedValidationMetadata
	}

	return transformed, nil
}

func expandComputeRolloutPlanWavesValidationType(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandComputeRolloutPlanWavesValidationTimeBasedValidationMetadata(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	if v == nil {
		return nil, nil
	}
	l := v.([]interface{})
	if len(l) == 0 || l[0] == nil {
		return nil, nil
	}
	raw := l[0]
	original := raw.(map[string]interface{})
	transformed := make(map[string]interface{})

	transformedWaitDuration, err := expandComputeRolloutPlanWavesValidationTimeBasedValidationMetadataWaitDuration(original["wait_duration"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedWaitDuration); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["waitDuration"] = transformedWaitDuration
	}

	return transformed, nil
}

func expandComputeRolloutPlanWavesValidationTimeBasedValidationMetadataWaitDuration(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandComputeRolloutPlanWavesOrchestrationOptions(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	if v == nil {
		return nil, nil
	}
	l := v.([]interface{})
	if len(l) == 0 || l[0] == nil {
		return nil, nil
	}
	raw := l[0]
	original := raw.(map[string]interface{})
	transformed := make(map[string]interface{})

	transformedMaxConcurrentLocations, err := expandComputeRolloutPlanWavesOrchestrationOptionsMaxConcurrentLocations(original["max_concurrent_locations"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedMaxConcurrentLocations); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["maxConcurrentLocations"] = transformedMaxConcurrentLocations
	}

	transformedMaxConcurrentResourcesPerLocation, err := expandComputeRolloutPlanWavesOrchestrationOptionsMaxConcurrentResourcesPerLocation(original["max_concurrent_resources_per_location"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedMaxConcurrentResourcesPerLocation); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["maxConcurrentResourcesPerLocation"] = transformedMaxConcurrentResourcesPerLocation
	}

	transformedDelays, err := expandComputeRolloutPlanWavesOrchestrationOptionsDelays(original["delays"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedDelays); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["delays"] = transformedDelays
	}

	return transformed, nil
}

func expandComputeRolloutPlanWavesOrchestrationOptionsMaxConcurrentLocations(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandComputeRolloutPlanWavesOrchestrationOptionsMaxConcurrentResourcesPerLocation(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandComputeRolloutPlanWavesOrchestrationOptionsDelays(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	if v == nil {
		return nil, nil
	}
	l := v.([]interface{})
	req := make([]interface{}, 0, len(l))
	for _, raw := range l {
		if raw == nil {
			continue
		}
		original := raw.(map[string]interface{})
		transformed := make(map[string]interface{})

		transformedDuration, err := expandComputeRolloutPlanWavesOrchestrationOptionsDelaysDuration(original["duration"], d, config)
		if err != nil {
			return nil, err
		} else if val := reflect.ValueOf(transformedDuration); val.IsValid() && !tpgresource.IsEmptyValue(val) {
			transformed["duration"] = transformedDuration
		}

		transformedDelimiter, err := expandComputeRolloutPlanWavesOrchestrationOptionsDelaysDelimiter(original["delimiter"], d, config)
		if err != nil {
			return nil, err
		} else if val := reflect.ValueOf(transformedDelimiter); val.IsValid() && !tpgresource.IsEmptyValue(val) {
			transformed["delimiter"] = transformedDelimiter
		}

		transformedType, err := expandComputeRolloutPlanWavesOrchestrationOptionsDelaysType(original["type"], d, config)
		if err != nil {
			return nil, err
		} else if val := reflect.ValueOf(transformedType); val.IsValid() && !tpgresource.IsEmptyValue(val) {
			transformed["type"] = transformedType
		}

		req = append(req, transformed)
	}
	return req, nil
}

func expandComputeRolloutPlanWavesOrchestrationOptionsDelaysDuration(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandComputeRolloutPlanWavesOrchestrationOptionsDelaysDelimiter(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandComputeRolloutPlanWavesOrchestrationOptionsDelaysType(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandComputeRolloutPlanName(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}
