// Copyright (c) HashiCorp, Inc.
// SPDX-License-Identifier: MPL-2.0

// ----------------------------------------------------------------------------
//
//     ***     AUTO GENERATED CODE    ***    Type: MMv1     ***
//
// ----------------------------------------------------------------------------
//
//     This file is automatically generated by Magic Modules and manual
//     changes will be clobbered when the file is regenerated.
//
//     Please read more about how to change this file in
//     .github/CONTRIBUTING.md.
//
// ----------------------------------------------------------------------------

package vertexai

import (
	"fmt"
	"log"
	"reflect"
	"strings"
	"time"

	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/customdiff"
	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/schema"

	"github.com/hashicorp/terraform-provider-google-beta/google-beta/tpgresource"
	transport_tpg "github.com/hashicorp/terraform-provider-google-beta/google-beta/transport"
	"github.com/hashicorp/terraform-provider-google-beta/google-beta/verify"
)

func ResourceVertexAIFeatureOnlineStoreFeatureview() *schema.Resource {
	return &schema.Resource{
		Create: resourceVertexAIFeatureOnlineStoreFeatureviewCreate,
		Read:   resourceVertexAIFeatureOnlineStoreFeatureviewRead,
		Update: resourceVertexAIFeatureOnlineStoreFeatureviewUpdate,
		Delete: resourceVertexAIFeatureOnlineStoreFeatureviewDelete,

		Importer: &schema.ResourceImporter{
			State: resourceVertexAIFeatureOnlineStoreFeatureviewImport,
		},

		Timeouts: &schema.ResourceTimeout{
			Create: schema.DefaultTimeout(20 * time.Minute),
			Update: schema.DefaultTimeout(20 * time.Minute),
			Delete: schema.DefaultTimeout(20 * time.Minute),
		},

		CustomizeDiff: customdiff.All(
			tpgresource.SetLabelsDiff,
			tpgresource.DefaultProviderProject,
		),

		Schema: map[string]*schema.Schema{
			"feature_online_store": {
				Type:        schema.TypeString,
				Required:    true,
				ForceNew:    true,
				Description: `The name of the FeatureOnlineStore to use for the featureview.`,
			},
			"region": {
				Type:        schema.TypeString,
				Required:    true,
				ForceNew:    true,
				Description: `The region for the resource. It should be the same as the featureonlinestore region.`,
			},
			"big_query_source": {
				Type:        schema.TypeList,
				Optional:    true,
				Description: `Configures how data is supposed to be extracted from a BigQuery source to be loaded onto the FeatureOnlineStore.`,
				MaxItems:    1,
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						"entity_id_columns": {
							Type:        schema.TypeList,
							Required:    true,
							Description: `Columns to construct entityId / row keys. Start by supporting 1 only.`,
							Elem: &schema.Schema{
								Type: schema.TypeString,
							},
						},
						"uri": {
							Type:        schema.TypeString,
							Required:    true,
							Description: `The BigQuery view URI that will be materialized on each sync trigger based on FeatureView.SyncConfig.`,
						},
					},
				},
				ExactlyOneOf: []string{"big_query_source", "feature_registry_source"},
			},
			"feature_registry_source": {
				Type:        schema.TypeList,
				Optional:    true,
				Description: `Configures the features from a Feature Registry source that need to be loaded onto the FeatureOnlineStore.`,
				MaxItems:    1,
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						"feature_groups": {
							Type:        schema.TypeList,
							Required:    true,
							Description: `List of features that need to be synced to Online Store.`,
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{
									"feature_group_id": {
										Type:        schema.TypeString,
										Required:    true,
										Description: `Identifier of the feature group.`,
									},
									"feature_ids": {
										Type:        schema.TypeList,
										Required:    true,
										Description: `Identifiers of features under the feature group.`,
										Elem: &schema.Schema{
											Type: schema.TypeString,
										},
									},
								},
							},
						},
					},
				},
				ConflictsWith: []string{"vector_search_config"},
				ExactlyOneOf:  []string{"big_query_source", "feature_registry_source"},
			},
			"labels": {
				Type:     schema.TypeMap,
				Optional: true,
				Description: `A set of key/value label pairs to assign to this FeatureView.


**Note**: This field is non-authoritative, and will only manage the labels present in your configuration.
Please refer to the field 'effective_labels' for all of the labels present on the resource.`,
				Elem: &schema.Schema{Type: schema.TypeString},
			},
			"name": {
				Type:        schema.TypeString,
				Optional:    true,
				ForceNew:    true,
				Description: `Name of the FeatureView. This value may be up to 60 characters, and valid characters are [a-z0-9_]. The first character cannot be a number.`,
			},
			"sync_config": {
				Type:        schema.TypeList,
				Optional:    true,
				Description: `Configures when data is to be synced/updated for this FeatureView. At the end of the sync the latest featureValues for each entityId of this FeatureView are made ready for online serving.`,
				MaxItems:    1,
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						"cron": {
							Type:     schema.TypeString,
							Computed: true,
							Optional: true,
							Description: `Cron schedule (https://en.wikipedia.org/wiki/Cron) to launch scheduled runs.
To explicitly set a timezone to the cron tab, apply a prefix in the cron tab: "CRON_TZ=${IANA_TIME_ZONE}" or "TZ=${IANA_TIME_ZONE}".`,
						},
					},
				},
			},
			"vector_search_config": {
				Type:        schema.TypeList,
				Optional:    true,
				ForceNew:    true,
				Description: `Configuration for vector search. It contains the required configurations to create an index from source data, so that approximate nearest neighbor (a.k.a ANN) algorithms search can be performed during online serving.`,
				MaxItems:    1,
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						"embedding_column": {
							Type:        schema.TypeString,
							Required:    true,
							Description: `Column of embedding. This column contains the source data to create index for vector search.`,
						},
						"brute_force_config": {
							Type:        schema.TypeList,
							Optional:    true,
							Description: `Configuration options for using brute force search, which simply implements the standard linear search in the database for each query. It is primarily meant for benchmarking and to generate the ground truth for approximate search.`,
							MaxItems:    1,
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{},
							},
							ExactlyOneOf: []string{},
						},
						"crowding_column": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: `Column of crowding. This column contains crowding attribute which is a constraint on a neighbor list produced by nearest neighbor search requiring that no more than some value k' of the k neighbors returned have the same value of crowdingAttribute.`,
						},
						"distance_measure_type": {
							Type:         schema.TypeString,
							Optional:     true,
							ValidateFunc: verify.ValidateEnum([]string{"SQUARED_L2_DISTANCE", "COSINE_DISTANCE", "DOT_PRODUCT_DISTANCE", ""}),
							Description: `The distance measure used in nearest neighbor search.
For details on allowed values, see the [API documentation](https://cloud.google.com/vertex-ai/docs/reference/rest/v1beta1/projects.locations.featureOnlineStores.featureViews#DistanceMeasureType). Possible values: ["SQUARED_L2_DISTANCE", "COSINE_DISTANCE", "DOT_PRODUCT_DISTANCE"]`,
						},
						"embedding_dimension": {
							Type:        schema.TypeInt,
							Optional:    true,
							Description: `The number of dimensions of the input embedding.`,
						},
						"filter_columns": {
							Type:        schema.TypeList,
							Optional:    true,
							Description: `Columns of features that are used to filter vector search results.`,
							Elem: &schema.Schema{
								Type: schema.TypeString,
							},
						},
						"tree_ah_config": {
							Type:        schema.TypeList,
							Optional:    true,
							Description: `Configuration options for the tree-AH algorithm (Shallow tree + Asymmetric Hashing). Please refer to this paper for more details: https://arxiv.org/abs/1908.10396`,
							MaxItems:    1,
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{
									"leaf_node_embedding_count": {
										Type:        schema.TypeString,
										Computed:    true,
										Optional:    true,
										Description: `Number of embeddings on each leaf node. The default value is 1000 if not set.`,
									},
								},
							},
							ExactlyOneOf: []string{},
						},
					},
				},
				ConflictsWith: []string{"feature_registry_source"},
			},
			"create_time": {
				Type:        schema.TypeString,
				Computed:    true,
				Description: `The timestamp of when the featureOnlinestore was created in RFC3339 UTC "Zulu" format, with nanosecond resolution and up to nine fractional digits.`,
			},
			"effective_labels": {
				Type:        schema.TypeMap,
				Computed:    true,
				Description: `All of labels (key/value pairs) present on the resource in GCP, including the labels configured through Terraform, other clients and services.`,
				Elem:        &schema.Schema{Type: schema.TypeString},
			},
			"terraform_labels": {
				Type:     schema.TypeMap,
				Computed: true,
				Description: `The combination of labels configured directly on the resource
 and default labels configured on the provider.`,
				Elem: &schema.Schema{Type: schema.TypeString},
			},
			"update_time": {
				Type:        schema.TypeString,
				Computed:    true,
				Description: `The timestamp of when the featureOnlinestore was last updated in RFC3339 UTC "Zulu" format, with nanosecond resolution and up to nine fractional digits.`,
			},
			"project": {
				Type:     schema.TypeString,
				Optional: true,
				Computed: true,
				ForceNew: true,
			},
		},
		UseJSONNumber: true,
	}
}

func resourceVertexAIFeatureOnlineStoreFeatureviewCreate(d *schema.ResourceData, meta interface{}) error {
	config := meta.(*transport_tpg.Config)
	userAgent, err := tpgresource.GenerateUserAgentString(d, config.UserAgent)
	if err != nil {
		return err
	}

	obj := make(map[string]interface{})
	syncConfigProp, err := expandVertexAIFeatureOnlineStoreFeatureviewSyncConfig(d.Get("sync_config"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("sync_config"); !tpgresource.IsEmptyValue(reflect.ValueOf(syncConfigProp)) && (ok || !reflect.DeepEqual(v, syncConfigProp)) {
		obj["syncConfig"] = syncConfigProp
	}
	bigQuerySourceProp, err := expandVertexAIFeatureOnlineStoreFeatureviewBigQuerySource(d.Get("big_query_source"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("big_query_source"); !tpgresource.IsEmptyValue(reflect.ValueOf(bigQuerySourceProp)) && (ok || !reflect.DeepEqual(v, bigQuerySourceProp)) {
		obj["bigQuerySource"] = bigQuerySourceProp
	}
	featureRegistrySourceProp, err := expandVertexAIFeatureOnlineStoreFeatureviewFeatureRegistrySource(d.Get("feature_registry_source"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("feature_registry_source"); !tpgresource.IsEmptyValue(reflect.ValueOf(featureRegistrySourceProp)) && (ok || !reflect.DeepEqual(v, featureRegistrySourceProp)) {
		obj["featureRegistrySource"] = featureRegistrySourceProp
	}
	vectorSearchConfigProp, err := expandVertexAIFeatureOnlineStoreFeatureviewVectorSearchConfig(d.Get("vector_search_config"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("vector_search_config"); !tpgresource.IsEmptyValue(reflect.ValueOf(vectorSearchConfigProp)) && (ok || !reflect.DeepEqual(v, vectorSearchConfigProp)) {
		obj["vectorSearchConfig"] = vectorSearchConfigProp
	}
	labelsProp, err := expandVertexAIFeatureOnlineStoreFeatureviewEffectiveLabels(d.Get("effective_labels"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("effective_labels"); !tpgresource.IsEmptyValue(reflect.ValueOf(labelsProp)) && (ok || !reflect.DeepEqual(v, labelsProp)) {
		obj["labels"] = labelsProp
	}

	url, err := tpgresource.ReplaceVars(d, config, "{{VertexAIBasePath}}projects/{{project}}/locations/{{region}}/featureOnlineStores/{{feature_online_store}}/featureViews?featureViewId={{name}}")
	if err != nil {
		return err
	}

	log.Printf("[DEBUG] Creating new FeatureOnlineStoreFeatureview: %#v", obj)
	billingProject := ""

	project, err := tpgresource.GetProject(d, config)
	if err != nil {
		return fmt.Errorf("Error fetching project for FeatureOnlineStoreFeatureview: %s", err)
	}
	billingProject = project

	// err == nil indicates that the billing_project value was found
	if bp, err := tpgresource.GetBillingProject(d, config); err == nil {
		billingProject = bp
	}

	res, err := transport_tpg.SendRequest(transport_tpg.SendRequestOptions{
		Config:    config,
		Method:    "POST",
		Project:   billingProject,
		RawURL:    url,
		UserAgent: userAgent,
		Body:      obj,
		Timeout:   d.Timeout(schema.TimeoutCreate),
	})
	if err != nil {
		return fmt.Errorf("Error creating FeatureOnlineStoreFeatureview: %s", err)
	}

	// Store the ID now
	id, err := tpgresource.ReplaceVars(d, config, "projects/{{project}}/locations/{{region}}/featureOnlineStores/{{feature_online_store}}/featureViews/{{name}}")
	if err != nil {
		return fmt.Errorf("Error constructing id: %s", err)
	}
	d.SetId(id)

	// Use the resource in the operation response to populate
	// identity fields and d.Id() before read
	var opRes map[string]interface{}
	err = VertexAIOperationWaitTimeWithResponse(
		config, res, &opRes, project, "Creating FeatureOnlineStoreFeatureview", userAgent,
		d.Timeout(schema.TimeoutCreate))
	if err != nil {
		// The resource didn't actually create
		d.SetId("")

		return fmt.Errorf("Error waiting to create FeatureOnlineStoreFeatureview: %s", err)
	}

	// This may have caused the ID to update - update it if so.
	id, err = tpgresource.ReplaceVars(d, config, "projects/{{project}}/locations/{{region}}/featureOnlineStores/{{feature_online_store}}/featureViews/{{name}}")
	if err != nil {
		return fmt.Errorf("Error constructing id: %s", err)
	}
	d.SetId(id)

	log.Printf("[DEBUG] Finished creating FeatureOnlineStoreFeatureview %q: %#v", d.Id(), res)

	return resourceVertexAIFeatureOnlineStoreFeatureviewRead(d, meta)
}

func resourceVertexAIFeatureOnlineStoreFeatureviewRead(d *schema.ResourceData, meta interface{}) error {
	config := meta.(*transport_tpg.Config)
	userAgent, err := tpgresource.GenerateUserAgentString(d, config.UserAgent)
	if err != nil {
		return err
	}

	url, err := tpgresource.ReplaceVars(d, config, "{{VertexAIBasePath}}projects/{{project}}/locations/{{region}}/featureOnlineStores/{{feature_online_store}}/featureViews/{{name}}")
	if err != nil {
		return err
	}

	billingProject := ""

	project, err := tpgresource.GetProject(d, config)
	if err != nil {
		return fmt.Errorf("Error fetching project for FeatureOnlineStoreFeatureview: %s", err)
	}
	billingProject = project

	// err == nil indicates that the billing_project value was found
	if bp, err := tpgresource.GetBillingProject(d, config); err == nil {
		billingProject = bp
	}

	res, err := transport_tpg.SendRequest(transport_tpg.SendRequestOptions{
		Config:    config,
		Method:    "GET",
		Project:   billingProject,
		RawURL:    url,
		UserAgent: userAgent,
	})
	if err != nil {
		return transport_tpg.HandleNotFoundError(err, d, fmt.Sprintf("VertexAIFeatureOnlineStoreFeatureview %q", d.Id()))
	}

	if err := d.Set("project", project); err != nil {
		return fmt.Errorf("Error reading FeatureOnlineStoreFeatureview: %s", err)
	}

	if err := d.Set("create_time", flattenVertexAIFeatureOnlineStoreFeatureviewCreateTime(res["createTime"], d, config)); err != nil {
		return fmt.Errorf("Error reading FeatureOnlineStoreFeatureview: %s", err)
	}
	if err := d.Set("update_time", flattenVertexAIFeatureOnlineStoreFeatureviewUpdateTime(res["updateTime"], d, config)); err != nil {
		return fmt.Errorf("Error reading FeatureOnlineStoreFeatureview: %s", err)
	}
	if err := d.Set("labels", flattenVertexAIFeatureOnlineStoreFeatureviewLabels(res["labels"], d, config)); err != nil {
		return fmt.Errorf("Error reading FeatureOnlineStoreFeatureview: %s", err)
	}
	if err := d.Set("sync_config", flattenVertexAIFeatureOnlineStoreFeatureviewSyncConfig(res["syncConfig"], d, config)); err != nil {
		return fmt.Errorf("Error reading FeatureOnlineStoreFeatureview: %s", err)
	}
	if err := d.Set("big_query_source", flattenVertexAIFeatureOnlineStoreFeatureviewBigQuerySource(res["bigQuerySource"], d, config)); err != nil {
		return fmt.Errorf("Error reading FeatureOnlineStoreFeatureview: %s", err)
	}
	if err := d.Set("feature_registry_source", flattenVertexAIFeatureOnlineStoreFeatureviewFeatureRegistrySource(res["featureRegistrySource"], d, config)); err != nil {
		return fmt.Errorf("Error reading FeatureOnlineStoreFeatureview: %s", err)
	}
	if err := d.Set("vector_search_config", flattenVertexAIFeatureOnlineStoreFeatureviewVectorSearchConfig(res["vectorSearchConfig"], d, config)); err != nil {
		return fmt.Errorf("Error reading FeatureOnlineStoreFeatureview: %s", err)
	}
	if err := d.Set("terraform_labels", flattenVertexAIFeatureOnlineStoreFeatureviewTerraformLabels(res["labels"], d, config)); err != nil {
		return fmt.Errorf("Error reading FeatureOnlineStoreFeatureview: %s", err)
	}
	if err := d.Set("effective_labels", flattenVertexAIFeatureOnlineStoreFeatureviewEffectiveLabels(res["labels"], d, config)); err != nil {
		return fmt.Errorf("Error reading FeatureOnlineStoreFeatureview: %s", err)
	}

	return nil
}

func resourceVertexAIFeatureOnlineStoreFeatureviewUpdate(d *schema.ResourceData, meta interface{}) error {
	config := meta.(*transport_tpg.Config)
	userAgent, err := tpgresource.GenerateUserAgentString(d, config.UserAgent)
	if err != nil {
		return err
	}

	billingProject := ""

	project, err := tpgresource.GetProject(d, config)
	if err != nil {
		return fmt.Errorf("Error fetching project for FeatureOnlineStoreFeatureview: %s", err)
	}
	billingProject = project

	obj := make(map[string]interface{})
	syncConfigProp, err := expandVertexAIFeatureOnlineStoreFeatureviewSyncConfig(d.Get("sync_config"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("sync_config"); !tpgresource.IsEmptyValue(reflect.ValueOf(v)) && (ok || !reflect.DeepEqual(v, syncConfigProp)) {
		obj["syncConfig"] = syncConfigProp
	}
	bigQuerySourceProp, err := expandVertexAIFeatureOnlineStoreFeatureviewBigQuerySource(d.Get("big_query_source"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("big_query_source"); !tpgresource.IsEmptyValue(reflect.ValueOf(v)) && (ok || !reflect.DeepEqual(v, bigQuerySourceProp)) {
		obj["bigQuerySource"] = bigQuerySourceProp
	}
	featureRegistrySourceProp, err := expandVertexAIFeatureOnlineStoreFeatureviewFeatureRegistrySource(d.Get("feature_registry_source"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("feature_registry_source"); !tpgresource.IsEmptyValue(reflect.ValueOf(v)) && (ok || !reflect.DeepEqual(v, featureRegistrySourceProp)) {
		obj["featureRegistrySource"] = featureRegistrySourceProp
	}
	labelsProp, err := expandVertexAIFeatureOnlineStoreFeatureviewEffectiveLabels(d.Get("effective_labels"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("effective_labels"); !tpgresource.IsEmptyValue(reflect.ValueOf(v)) && (ok || !reflect.DeepEqual(v, labelsProp)) {
		obj["labels"] = labelsProp
	}

	url, err := tpgresource.ReplaceVars(d, config, "{{VertexAIBasePath}}projects/{{project}}/locations/{{region}}/featureOnlineStores/{{feature_online_store}}/featureViews/{{name}}")
	if err != nil {
		return err
	}

	log.Printf("[DEBUG] Updating FeatureOnlineStoreFeatureview %q: %#v", d.Id(), obj)
	updateMask := []string{}

	if d.HasChange("sync_config") {
		updateMask = append(updateMask, "syncConfig")
	}

	if d.HasChange("big_query_source") {
		updateMask = append(updateMask, "bigQuerySource")
	}

	if d.HasChange("feature_registry_source") {
		updateMask = append(updateMask, "featureRegistrySource")
	}

	if d.HasChange("effective_labels") {
		updateMask = append(updateMask, "labels")
	}
	// updateMask is a URL parameter but not present in the schema, so ReplaceVars
	// won't set it
	url, err = transport_tpg.AddQueryParams(url, map[string]string{"updateMask": strings.Join(updateMask, ",")})
	if err != nil {
		return err
	}

	// err == nil indicates that the billing_project value was found
	if bp, err := tpgresource.GetBillingProject(d, config); err == nil {
		billingProject = bp
	}

	// if updateMask is empty we are not updating anything so skip the post
	if len(updateMask) > 0 {
		res, err := transport_tpg.SendRequest(transport_tpg.SendRequestOptions{
			Config:    config,
			Method:    "PATCH",
			Project:   billingProject,
			RawURL:    url,
			UserAgent: userAgent,
			Body:      obj,
			Timeout:   d.Timeout(schema.TimeoutUpdate),
		})

		if err != nil {
			return fmt.Errorf("Error updating FeatureOnlineStoreFeatureview %q: %s", d.Id(), err)
		} else {
			log.Printf("[DEBUG] Finished updating FeatureOnlineStoreFeatureview %q: %#v", d.Id(), res)
		}

	}

	return resourceVertexAIFeatureOnlineStoreFeatureviewRead(d, meta)
}

func resourceVertexAIFeatureOnlineStoreFeatureviewDelete(d *schema.ResourceData, meta interface{}) error {
	config := meta.(*transport_tpg.Config)
	userAgent, err := tpgresource.GenerateUserAgentString(d, config.UserAgent)
	if err != nil {
		return err
	}

	billingProject := ""

	project, err := tpgresource.GetProject(d, config)
	if err != nil {
		return fmt.Errorf("Error fetching project for FeatureOnlineStoreFeatureview: %s", err)
	}
	billingProject = project

	url, err := tpgresource.ReplaceVars(d, config, "{{VertexAIBasePath}}projects/{{project}}/locations/{{region}}/featureOnlineStores/{{feature_online_store}}/featureViews/{{name}}")
	if err != nil {
		return err
	}

	var obj map[string]interface{}

	// err == nil indicates that the billing_project value was found
	if bp, err := tpgresource.GetBillingProject(d, config); err == nil {
		billingProject = bp
	}

	log.Printf("[DEBUG] Deleting FeatureOnlineStoreFeatureview %q", d.Id())
	res, err := transport_tpg.SendRequest(transport_tpg.SendRequestOptions{
		Config:    config,
		Method:    "DELETE",
		Project:   billingProject,
		RawURL:    url,
		UserAgent: userAgent,
		Body:      obj,
		Timeout:   d.Timeout(schema.TimeoutDelete),
	})
	if err != nil {
		return transport_tpg.HandleNotFoundError(err, d, "FeatureOnlineStoreFeatureview")
	}

	err = VertexAIOperationWaitTime(
		config, res, project, "Deleting FeatureOnlineStoreFeatureview", userAgent,
		d.Timeout(schema.TimeoutDelete))

	if err != nil {
		return err
	}

	log.Printf("[DEBUG] Finished deleting FeatureOnlineStoreFeatureview %q: %#v", d.Id(), res)
	return nil
}

func resourceVertexAIFeatureOnlineStoreFeatureviewImport(d *schema.ResourceData, meta interface{}) ([]*schema.ResourceData, error) {
	config := meta.(*transport_tpg.Config)
	if err := tpgresource.ParseImportId([]string{
		"^projects/(?P<project>[^/]+)/locations/(?P<region>[^/]+)/featureOnlineStores/(?P<feature_online_store>[^/]+)/featureViews/(?P<name>[^/]+)$",
		"^(?P<project>[^/]+)/(?P<region>[^/]+)/(?P<feature_online_store>[^/]+)/(?P<name>[^/]+)$",
		"^(?P<region>[^/]+)/(?P<feature_online_store>[^/]+)/(?P<name>[^/]+)$",
		"^(?P<feature_online_store>[^/]+)/(?P<name>[^/]+)$",
	}, d, config); err != nil {
		return nil, err
	}

	// Replace import id for the resource id
	id, err := tpgresource.ReplaceVars(d, config, "projects/{{project}}/locations/{{region}}/featureOnlineStores/{{feature_online_store}}/featureViews/{{name}}")
	if err != nil {
		return nil, fmt.Errorf("Error constructing id: %s", err)
	}
	d.SetId(id)

	return []*schema.ResourceData{d}, nil
}

func flattenVertexAIFeatureOnlineStoreFeatureviewCreateTime(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenVertexAIFeatureOnlineStoreFeatureviewUpdateTime(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenVertexAIFeatureOnlineStoreFeatureviewLabels(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return v
	}

	transformed := make(map[string]interface{})
	if l, ok := d.GetOkExists("labels"); ok {
		for k := range l.(map[string]interface{}) {
			transformed[k] = v.(map[string]interface{})[k]
		}
	}

	return transformed
}

func flattenVertexAIFeatureOnlineStoreFeatureviewSyncConfig(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return nil
	}
	original := v.(map[string]interface{})
	if len(original) == 0 {
		return nil
	}
	transformed := make(map[string]interface{})
	transformed["cron"] =
		flattenVertexAIFeatureOnlineStoreFeatureviewSyncConfigCron(original["cron"], d, config)
	return []interface{}{transformed}
}
func flattenVertexAIFeatureOnlineStoreFeatureviewSyncConfigCron(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenVertexAIFeatureOnlineStoreFeatureviewBigQuerySource(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return nil
	}
	original := v.(map[string]interface{})
	if len(original) == 0 {
		return nil
	}
	transformed := make(map[string]interface{})
	transformed["uri"] =
		flattenVertexAIFeatureOnlineStoreFeatureviewBigQuerySourceUri(original["uri"], d, config)
	transformed["entity_id_columns"] =
		flattenVertexAIFeatureOnlineStoreFeatureviewBigQuerySourceEntityIdColumns(original["entityIdColumns"], d, config)
	return []interface{}{transformed}
}
func flattenVertexAIFeatureOnlineStoreFeatureviewBigQuerySourceUri(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenVertexAIFeatureOnlineStoreFeatureviewBigQuerySourceEntityIdColumns(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenVertexAIFeatureOnlineStoreFeatureviewFeatureRegistrySource(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return nil
	}
	original := v.(map[string]interface{})
	if len(original) == 0 {
		return nil
	}
	transformed := make(map[string]interface{})
	transformed["feature_groups"] =
		flattenVertexAIFeatureOnlineStoreFeatureviewFeatureRegistrySourceFeatureGroups(original["featureGroups"], d, config)
	return []interface{}{transformed}
}
func flattenVertexAIFeatureOnlineStoreFeatureviewFeatureRegistrySourceFeatureGroups(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return v
	}
	l := v.([]interface{})
	transformed := make([]interface{}, 0, len(l))
	for _, raw := range l {
		original := raw.(map[string]interface{})
		if len(original) < 1 {
			// Do not include empty json objects coming back from the api
			continue
		}
		transformed = append(transformed, map[string]interface{}{
			"feature_group_id": flattenVertexAIFeatureOnlineStoreFeatureviewFeatureRegistrySourceFeatureGroupsFeatureGroupId(original["featureGroupId"], d, config),
			"feature_ids":      flattenVertexAIFeatureOnlineStoreFeatureviewFeatureRegistrySourceFeatureGroupsFeatureIds(original["featureIds"], d, config),
		})
	}
	return transformed
}
func flattenVertexAIFeatureOnlineStoreFeatureviewFeatureRegistrySourceFeatureGroupsFeatureGroupId(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenVertexAIFeatureOnlineStoreFeatureviewFeatureRegistrySourceFeatureGroupsFeatureIds(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenVertexAIFeatureOnlineStoreFeatureviewVectorSearchConfig(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return nil
	}
	original := v.(map[string]interface{})
	if len(original) == 0 {
		return nil
	}
	transformed := make(map[string]interface{})
	transformed["embedding_column"] =
		flattenVertexAIFeatureOnlineStoreFeatureviewVectorSearchConfigEmbeddingColumn(original["embeddingColumn"], d, config)
	transformed["filter_columns"] =
		flattenVertexAIFeatureOnlineStoreFeatureviewVectorSearchConfigFilterColumns(original["filterColumns"], d, config)
	transformed["crowding_column"] =
		flattenVertexAIFeatureOnlineStoreFeatureviewVectorSearchConfigCrowdingColumn(original["crowdingColumn"], d, config)
	transformed["distance_measure_type"] =
		flattenVertexAIFeatureOnlineStoreFeatureviewVectorSearchConfigDistanceMeasureType(original["distanceMeasureType"], d, config)
	transformed["tree_ah_config"] =
		flattenVertexAIFeatureOnlineStoreFeatureviewVectorSearchConfigTreeAhConfig(original["treeAhConfig"], d, config)
	transformed["brute_force_config"] =
		flattenVertexAIFeatureOnlineStoreFeatureviewVectorSearchConfigBruteForceConfig(original["bruteForceConfig"], d, config)
	transformed["embedding_dimension"] =
		flattenVertexAIFeatureOnlineStoreFeatureviewVectorSearchConfigEmbeddingDimension(original["embeddingDimension"], d, config)
	return []interface{}{transformed}
}
func flattenVertexAIFeatureOnlineStoreFeatureviewVectorSearchConfigEmbeddingColumn(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenVertexAIFeatureOnlineStoreFeatureviewVectorSearchConfigFilterColumns(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenVertexAIFeatureOnlineStoreFeatureviewVectorSearchConfigCrowdingColumn(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenVertexAIFeatureOnlineStoreFeatureviewVectorSearchConfigDistanceMeasureType(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenVertexAIFeatureOnlineStoreFeatureviewVectorSearchConfigTreeAhConfig(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return nil
	}
	original := v.(map[string]interface{})
	if len(original) == 0 {
		return nil
	}
	transformed := make(map[string]interface{})
	transformed["leaf_node_embedding_count"] =
		flattenVertexAIFeatureOnlineStoreFeatureviewVectorSearchConfigTreeAhConfigLeafNodeEmbeddingCount(original["leafNodeEmbeddingCount"], d, config)
	return []interface{}{transformed}
}
func flattenVertexAIFeatureOnlineStoreFeatureviewVectorSearchConfigTreeAhConfigLeafNodeEmbeddingCount(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenVertexAIFeatureOnlineStoreFeatureviewVectorSearchConfigBruteForceConfig(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return nil
	}
	transformed := make(map[string]interface{})
	return []interface{}{transformed}
}

func flattenVertexAIFeatureOnlineStoreFeatureviewVectorSearchConfigEmbeddingDimension(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	// Handles the string fixed64 format
	if strVal, ok := v.(string); ok {
		if intVal, err := tpgresource.StringToFixed64(strVal); err == nil {
			return intVal
		}
	}

	// number values are represented as float64
	if floatVal, ok := v.(float64); ok {
		intVal := int(floatVal)
		return intVal
	}

	return v // let terraform core handle it otherwise
}

func flattenVertexAIFeatureOnlineStoreFeatureviewTerraformLabels(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return v
	}

	transformed := make(map[string]interface{})
	if l, ok := d.GetOkExists("terraform_labels"); ok {
		for k := range l.(map[string]interface{}) {
			transformed[k] = v.(map[string]interface{})[k]
		}
	}

	return transformed
}

func flattenVertexAIFeatureOnlineStoreFeatureviewEffectiveLabels(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func expandVertexAIFeatureOnlineStoreFeatureviewSyncConfig(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	l := v.([]interface{})
	if len(l) == 0 || l[0] == nil {
		return nil, nil
	}
	raw := l[0]
	original := raw.(map[string]interface{})
	transformed := make(map[string]interface{})

	transformedCron, err := expandVertexAIFeatureOnlineStoreFeatureviewSyncConfigCron(original["cron"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedCron); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["cron"] = transformedCron
	}

	return transformed, nil
}

func expandVertexAIFeatureOnlineStoreFeatureviewSyncConfigCron(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandVertexAIFeatureOnlineStoreFeatureviewBigQuerySource(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	l := v.([]interface{})
	if len(l) == 0 || l[0] == nil {
		return nil, nil
	}
	raw := l[0]
	original := raw.(map[string]interface{})
	transformed := make(map[string]interface{})

	transformedUri, err := expandVertexAIFeatureOnlineStoreFeatureviewBigQuerySourceUri(original["uri"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedUri); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["uri"] = transformedUri
	}

	transformedEntityIdColumns, err := expandVertexAIFeatureOnlineStoreFeatureviewBigQuerySourceEntityIdColumns(original["entity_id_columns"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedEntityIdColumns); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["entityIdColumns"] = transformedEntityIdColumns
	}

	return transformed, nil
}

func expandVertexAIFeatureOnlineStoreFeatureviewBigQuerySourceUri(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandVertexAIFeatureOnlineStoreFeatureviewBigQuerySourceEntityIdColumns(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandVertexAIFeatureOnlineStoreFeatureviewFeatureRegistrySource(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	l := v.([]interface{})
	if len(l) == 0 || l[0] == nil {
		return nil, nil
	}
	raw := l[0]
	original := raw.(map[string]interface{})
	transformed := make(map[string]interface{})

	transformedFeatureGroups, err := expandVertexAIFeatureOnlineStoreFeatureviewFeatureRegistrySourceFeatureGroups(original["feature_groups"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedFeatureGroups); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["featureGroups"] = transformedFeatureGroups
	}

	return transformed, nil
}

func expandVertexAIFeatureOnlineStoreFeatureviewFeatureRegistrySourceFeatureGroups(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	l := v.([]interface{})
	req := make([]interface{}, 0, len(l))
	for _, raw := range l {
		if raw == nil {
			continue
		}
		original := raw.(map[string]interface{})
		transformed := make(map[string]interface{})

		transformedFeatureGroupId, err := expandVertexAIFeatureOnlineStoreFeatureviewFeatureRegistrySourceFeatureGroupsFeatureGroupId(original["feature_group_id"], d, config)
		if err != nil {
			return nil, err
		} else if val := reflect.ValueOf(transformedFeatureGroupId); val.IsValid() && !tpgresource.IsEmptyValue(val) {
			transformed["featureGroupId"] = transformedFeatureGroupId
		}

		transformedFeatureIds, err := expandVertexAIFeatureOnlineStoreFeatureviewFeatureRegistrySourceFeatureGroupsFeatureIds(original["feature_ids"], d, config)
		if err != nil {
			return nil, err
		} else if val := reflect.ValueOf(transformedFeatureIds); val.IsValid() && !tpgresource.IsEmptyValue(val) {
			transformed["featureIds"] = transformedFeatureIds
		}

		req = append(req, transformed)
	}
	return req, nil
}

func expandVertexAIFeatureOnlineStoreFeatureviewFeatureRegistrySourceFeatureGroupsFeatureGroupId(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandVertexAIFeatureOnlineStoreFeatureviewFeatureRegistrySourceFeatureGroupsFeatureIds(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandVertexAIFeatureOnlineStoreFeatureviewVectorSearchConfig(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	l := v.([]interface{})
	if len(l) == 0 || l[0] == nil {
		return nil, nil
	}
	raw := l[0]
	original := raw.(map[string]interface{})
	transformed := make(map[string]interface{})

	transformedEmbeddingColumn, err := expandVertexAIFeatureOnlineStoreFeatureviewVectorSearchConfigEmbeddingColumn(original["embedding_column"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedEmbeddingColumn); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["embeddingColumn"] = transformedEmbeddingColumn
	}

	transformedFilterColumns, err := expandVertexAIFeatureOnlineStoreFeatureviewVectorSearchConfigFilterColumns(original["filter_columns"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedFilterColumns); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["filterColumns"] = transformedFilterColumns
	}

	transformedCrowdingColumn, err := expandVertexAIFeatureOnlineStoreFeatureviewVectorSearchConfigCrowdingColumn(original["crowding_column"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedCrowdingColumn); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["crowdingColumn"] = transformedCrowdingColumn
	}

	transformedDistanceMeasureType, err := expandVertexAIFeatureOnlineStoreFeatureviewVectorSearchConfigDistanceMeasureType(original["distance_measure_type"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedDistanceMeasureType); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["distanceMeasureType"] = transformedDistanceMeasureType
	}

	transformedTreeAhConfig, err := expandVertexAIFeatureOnlineStoreFeatureviewVectorSearchConfigTreeAhConfig(original["tree_ah_config"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedTreeAhConfig); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["treeAhConfig"] = transformedTreeAhConfig
	}

	transformedBruteForceConfig, err := expandVertexAIFeatureOnlineStoreFeatureviewVectorSearchConfigBruteForceConfig(original["brute_force_config"], d, config)
	if err != nil {
		return nil, err
	} else {
		transformed["bruteForceConfig"] = transformedBruteForceConfig
	}

	transformedEmbeddingDimension, err := expandVertexAIFeatureOnlineStoreFeatureviewVectorSearchConfigEmbeddingDimension(original["embedding_dimension"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedEmbeddingDimension); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["embeddingDimension"] = transformedEmbeddingDimension
	}

	return transformed, nil
}

func expandVertexAIFeatureOnlineStoreFeatureviewVectorSearchConfigEmbeddingColumn(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandVertexAIFeatureOnlineStoreFeatureviewVectorSearchConfigFilterColumns(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandVertexAIFeatureOnlineStoreFeatureviewVectorSearchConfigCrowdingColumn(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandVertexAIFeatureOnlineStoreFeatureviewVectorSearchConfigDistanceMeasureType(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandVertexAIFeatureOnlineStoreFeatureviewVectorSearchConfigTreeAhConfig(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	l := v.([]interface{})
	if len(l) == 0 || l[0] == nil {
		return nil, nil
	}
	raw := l[0]
	original := raw.(map[string]interface{})
	transformed := make(map[string]interface{})

	transformedLeafNodeEmbeddingCount, err := expandVertexAIFeatureOnlineStoreFeatureviewVectorSearchConfigTreeAhConfigLeafNodeEmbeddingCount(original["leaf_node_embedding_count"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedLeafNodeEmbeddingCount); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["leafNodeEmbeddingCount"] = transformedLeafNodeEmbeddingCount
	}

	return transformed, nil
}

func expandVertexAIFeatureOnlineStoreFeatureviewVectorSearchConfigTreeAhConfigLeafNodeEmbeddingCount(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandVertexAIFeatureOnlineStoreFeatureviewVectorSearchConfigBruteForceConfig(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	l := v.([]interface{})
	if len(l) == 0 {
		return nil, nil
	}

	if l[0] == nil {
		transformed := make(map[string]interface{})
		return transformed, nil
	}
	transformed := make(map[string]interface{})

	return transformed, nil
}

func expandVertexAIFeatureOnlineStoreFeatureviewVectorSearchConfigEmbeddingDimension(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandVertexAIFeatureOnlineStoreFeatureviewEffectiveLabels(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (map[string]string, error) {
	if v == nil {
		return map[string]string{}, nil
	}
	m := make(map[string]string)
	for k, val := range v.(map[string]interface{}) {
		m[k] = val.(string)
	}
	return m, nil
}
